
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000035a8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  000035a8  0000363c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000310  00800068  00800068  00003644  2**0
                  ALLOC
  3 .stab         00005460  00000000  00000000  00003644  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002f98  00000000  00000000  00008aa4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 e1 04 	jmp	0x9c2	; 0x9c2 <__vector_1>
       8:	0c 94 0e 05 	jmp	0xa1c	; 0xa1c <__vector_2>
       c:	0c 94 3b 05 	jmp	0xa76	; 0xa76 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 c4 0d 	jmp	0x1b88	; 0x1b88 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ea       	ldi	r30, 0xA8	; 168
      68:	f5 e3       	ldi	r31, 0x35	; 53
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 37       	cpi	r26, 0x78	; 120
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <main>
      8a:	0c 94 d2 1a 	jmp	0x35a4	; 0x35a4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_SetPinDirection>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_SetPinDirection+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <DIO_SetPinDirection+0x8>
      9a:	0f 92       	push	r0
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	89 83       	std	Y+1, r24	; 0x01
      a2:	6a 83       	std	Y+2, r22	; 0x02
      a4:	4b 83       	std	Y+3, r20	; 0x03
      a6:	89 81       	ldd	r24, Y+1	; 0x01
      a8:	28 2f       	mov	r18, r24
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	3d 83       	std	Y+5, r19	; 0x05
      ae:	2c 83       	std	Y+4, r18	; 0x04
      b0:	8c 81       	ldd	r24, Y+4	; 0x04
      b2:	9d 81       	ldd	r25, Y+5	; 0x05
      b4:	81 30       	cpi	r24, 0x01	; 1
      b6:	91 05       	cpc	r25, r1
      b8:	09 f4       	brne	.+2      	; 0xbc <DIO_SetPinDirection+0x2a>
      ba:	47 c0       	rjmp	.+142    	; 0x14a <DIO_SetPinDirection+0xb8>
      bc:	2c 81       	ldd	r18, Y+4	; 0x04
      be:	3d 81       	ldd	r19, Y+5	; 0x05
      c0:	22 30       	cpi	r18, 0x02	; 2
      c2:	31 05       	cpc	r19, r1
      c4:	2c f4       	brge	.+10     	; 0xd0 <DIO_SetPinDirection+0x3e>
      c6:	8c 81       	ldd	r24, Y+4	; 0x04
      c8:	9d 81       	ldd	r25, Y+5	; 0x05
      ca:	00 97       	sbiw	r24, 0x00	; 0
      cc:	71 f0       	breq	.+28     	; 0xea <DIO_SetPinDirection+0x58>
      ce:	cb c0       	rjmp	.+406    	; 0x266 <DIO_SetPinDirection+0x1d4>
      d0:	2c 81       	ldd	r18, Y+4	; 0x04
      d2:	3d 81       	ldd	r19, Y+5	; 0x05
      d4:	22 30       	cpi	r18, 0x02	; 2
      d6:	31 05       	cpc	r19, r1
      d8:	09 f4       	brne	.+2      	; 0xdc <DIO_SetPinDirection+0x4a>
      da:	67 c0       	rjmp	.+206    	; 0x1aa <DIO_SetPinDirection+0x118>
      dc:	8c 81       	ldd	r24, Y+4	; 0x04
      de:	9d 81       	ldd	r25, Y+5	; 0x05
      e0:	83 30       	cpi	r24, 0x03	; 3
      e2:	91 05       	cpc	r25, r1
      e4:	09 f4       	brne	.+2      	; 0xe8 <DIO_SetPinDirection+0x56>
      e6:	91 c0       	rjmp	.+290    	; 0x20a <DIO_SetPinDirection+0x178>
      e8:	be c0       	rjmp	.+380    	; 0x266 <DIO_SetPinDirection+0x1d4>
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	88 23       	and	r24, r24
      ee:	a9 f4       	brne	.+42     	; 0x11a <DIO_SetPinDirection+0x88>
      f0:	aa e3       	ldi	r26, 0x3A	; 58
      f2:	b0 e0       	ldi	r27, 0x00	; 0
      f4:	ea e3       	ldi	r30, 0x3A	; 58
      f6:	f0 e0       	ldi	r31, 0x00	; 0
      f8:	80 81       	ld	r24, Z
      fa:	48 2f       	mov	r20, r24
      fc:	8a 81       	ldd	r24, Y+2	; 0x02
      fe:	28 2f       	mov	r18, r24
     100:	30 e0       	ldi	r19, 0x00	; 0
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	02 2e       	mov	r0, r18
     108:	02 c0       	rjmp	.+4      	; 0x10e <DIO_SetPinDirection+0x7c>
     10a:	88 0f       	add	r24, r24
     10c:	99 1f       	adc	r25, r25
     10e:	0a 94       	dec	r0
     110:	e2 f7       	brpl	.-8      	; 0x10a <DIO_SetPinDirection+0x78>
     112:	80 95       	com	r24
     114:	84 23       	and	r24, r20
     116:	8c 93       	st	X, r24
     118:	a6 c0       	rjmp	.+332    	; 0x266 <DIO_SetPinDirection+0x1d4>
     11a:	8b 81       	ldd	r24, Y+3	; 0x03
     11c:	81 30       	cpi	r24, 0x01	; 1
     11e:	09 f0       	breq	.+2      	; 0x122 <DIO_SetPinDirection+0x90>
     120:	a2 c0       	rjmp	.+324    	; 0x266 <DIO_SetPinDirection+0x1d4>
     122:	aa e3       	ldi	r26, 0x3A	; 58
     124:	b0 e0       	ldi	r27, 0x00	; 0
     126:	ea e3       	ldi	r30, 0x3A	; 58
     128:	f0 e0       	ldi	r31, 0x00	; 0
     12a:	80 81       	ld	r24, Z
     12c:	48 2f       	mov	r20, r24
     12e:	8a 81       	ldd	r24, Y+2	; 0x02
     130:	28 2f       	mov	r18, r24
     132:	30 e0       	ldi	r19, 0x00	; 0
     134:	81 e0       	ldi	r24, 0x01	; 1
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	02 2e       	mov	r0, r18
     13a:	02 c0       	rjmp	.+4      	; 0x140 <DIO_SetPinDirection+0xae>
     13c:	88 0f       	add	r24, r24
     13e:	99 1f       	adc	r25, r25
     140:	0a 94       	dec	r0
     142:	e2 f7       	brpl	.-8      	; 0x13c <DIO_SetPinDirection+0xaa>
     144:	84 2b       	or	r24, r20
     146:	8c 93       	st	X, r24
     148:	8e c0       	rjmp	.+284    	; 0x266 <DIO_SetPinDirection+0x1d4>
     14a:	8b 81       	ldd	r24, Y+3	; 0x03
     14c:	88 23       	and	r24, r24
     14e:	a9 f4       	brne	.+42     	; 0x17a <DIO_SetPinDirection+0xe8>
     150:	a7 e3       	ldi	r26, 0x37	; 55
     152:	b0 e0       	ldi	r27, 0x00	; 0
     154:	e7 e3       	ldi	r30, 0x37	; 55
     156:	f0 e0       	ldi	r31, 0x00	; 0
     158:	80 81       	ld	r24, Z
     15a:	48 2f       	mov	r20, r24
     15c:	8a 81       	ldd	r24, Y+2	; 0x02
     15e:	28 2f       	mov	r18, r24
     160:	30 e0       	ldi	r19, 0x00	; 0
     162:	81 e0       	ldi	r24, 0x01	; 1
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	02 2e       	mov	r0, r18
     168:	02 c0       	rjmp	.+4      	; 0x16e <DIO_SetPinDirection+0xdc>
     16a:	88 0f       	add	r24, r24
     16c:	99 1f       	adc	r25, r25
     16e:	0a 94       	dec	r0
     170:	e2 f7       	brpl	.-8      	; 0x16a <DIO_SetPinDirection+0xd8>
     172:	80 95       	com	r24
     174:	84 23       	and	r24, r20
     176:	8c 93       	st	X, r24
     178:	76 c0       	rjmp	.+236    	; 0x266 <DIO_SetPinDirection+0x1d4>
     17a:	8b 81       	ldd	r24, Y+3	; 0x03
     17c:	81 30       	cpi	r24, 0x01	; 1
     17e:	09 f0       	breq	.+2      	; 0x182 <DIO_SetPinDirection+0xf0>
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_SetPinDirection+0x1d4>
     182:	a7 e3       	ldi	r26, 0x37	; 55
     184:	b0 e0       	ldi	r27, 0x00	; 0
     186:	e7 e3       	ldi	r30, 0x37	; 55
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	80 81       	ld	r24, Z
     18c:	48 2f       	mov	r20, r24
     18e:	8a 81       	ldd	r24, Y+2	; 0x02
     190:	28 2f       	mov	r18, r24
     192:	30 e0       	ldi	r19, 0x00	; 0
     194:	81 e0       	ldi	r24, 0x01	; 1
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	02 2e       	mov	r0, r18
     19a:	02 c0       	rjmp	.+4      	; 0x1a0 <DIO_SetPinDirection+0x10e>
     19c:	88 0f       	add	r24, r24
     19e:	99 1f       	adc	r25, r25
     1a0:	0a 94       	dec	r0
     1a2:	e2 f7       	brpl	.-8      	; 0x19c <DIO_SetPinDirection+0x10a>
     1a4:	84 2b       	or	r24, r20
     1a6:	8c 93       	st	X, r24
     1a8:	5e c0       	rjmp	.+188    	; 0x266 <DIO_SetPinDirection+0x1d4>
     1aa:	8b 81       	ldd	r24, Y+3	; 0x03
     1ac:	88 23       	and	r24, r24
     1ae:	a9 f4       	brne	.+42     	; 0x1da <DIO_SetPinDirection+0x148>
     1b0:	a4 e3       	ldi	r26, 0x34	; 52
     1b2:	b0 e0       	ldi	r27, 0x00	; 0
     1b4:	e4 e3       	ldi	r30, 0x34	; 52
     1b6:	f0 e0       	ldi	r31, 0x00	; 0
     1b8:	80 81       	ld	r24, Z
     1ba:	48 2f       	mov	r20, r24
     1bc:	8a 81       	ldd	r24, Y+2	; 0x02
     1be:	28 2f       	mov	r18, r24
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	81 e0       	ldi	r24, 0x01	; 1
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	02 2e       	mov	r0, r18
     1c8:	02 c0       	rjmp	.+4      	; 0x1ce <DIO_SetPinDirection+0x13c>
     1ca:	88 0f       	add	r24, r24
     1cc:	99 1f       	adc	r25, r25
     1ce:	0a 94       	dec	r0
     1d0:	e2 f7       	brpl	.-8      	; 0x1ca <DIO_SetPinDirection+0x138>
     1d2:	80 95       	com	r24
     1d4:	84 23       	and	r24, r20
     1d6:	8c 93       	st	X, r24
     1d8:	46 c0       	rjmp	.+140    	; 0x266 <DIO_SetPinDirection+0x1d4>
     1da:	8b 81       	ldd	r24, Y+3	; 0x03
     1dc:	81 30       	cpi	r24, 0x01	; 1
     1de:	09 f0       	breq	.+2      	; 0x1e2 <DIO_SetPinDirection+0x150>
     1e0:	42 c0       	rjmp	.+132    	; 0x266 <DIO_SetPinDirection+0x1d4>
     1e2:	a4 e3       	ldi	r26, 0x34	; 52
     1e4:	b0 e0       	ldi	r27, 0x00	; 0
     1e6:	e4 e3       	ldi	r30, 0x34	; 52
     1e8:	f0 e0       	ldi	r31, 0x00	; 0
     1ea:	80 81       	ld	r24, Z
     1ec:	48 2f       	mov	r20, r24
     1ee:	8a 81       	ldd	r24, Y+2	; 0x02
     1f0:	28 2f       	mov	r18, r24
     1f2:	30 e0       	ldi	r19, 0x00	; 0
     1f4:	81 e0       	ldi	r24, 0x01	; 1
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	02 2e       	mov	r0, r18
     1fa:	02 c0       	rjmp	.+4      	; 0x200 <DIO_SetPinDirection+0x16e>
     1fc:	88 0f       	add	r24, r24
     1fe:	99 1f       	adc	r25, r25
     200:	0a 94       	dec	r0
     202:	e2 f7       	brpl	.-8      	; 0x1fc <DIO_SetPinDirection+0x16a>
     204:	84 2b       	or	r24, r20
     206:	8c 93       	st	X, r24
     208:	2e c0       	rjmp	.+92     	; 0x266 <DIO_SetPinDirection+0x1d4>
     20a:	8b 81       	ldd	r24, Y+3	; 0x03
     20c:	88 23       	and	r24, r24
     20e:	a9 f4       	brne	.+42     	; 0x23a <DIO_SetPinDirection+0x1a8>
     210:	a1 e3       	ldi	r26, 0x31	; 49
     212:	b0 e0       	ldi	r27, 0x00	; 0
     214:	e1 e3       	ldi	r30, 0x31	; 49
     216:	f0 e0       	ldi	r31, 0x00	; 0
     218:	80 81       	ld	r24, Z
     21a:	48 2f       	mov	r20, r24
     21c:	8a 81       	ldd	r24, Y+2	; 0x02
     21e:	28 2f       	mov	r18, r24
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	02 2e       	mov	r0, r18
     228:	02 c0       	rjmp	.+4      	; 0x22e <DIO_SetPinDirection+0x19c>
     22a:	88 0f       	add	r24, r24
     22c:	99 1f       	adc	r25, r25
     22e:	0a 94       	dec	r0
     230:	e2 f7       	brpl	.-8      	; 0x22a <DIO_SetPinDirection+0x198>
     232:	80 95       	com	r24
     234:	84 23       	and	r24, r20
     236:	8c 93       	st	X, r24
     238:	16 c0       	rjmp	.+44     	; 0x266 <DIO_SetPinDirection+0x1d4>
     23a:	8b 81       	ldd	r24, Y+3	; 0x03
     23c:	81 30       	cpi	r24, 0x01	; 1
     23e:	99 f4       	brne	.+38     	; 0x266 <DIO_SetPinDirection+0x1d4>
     240:	a1 e3       	ldi	r26, 0x31	; 49
     242:	b0 e0       	ldi	r27, 0x00	; 0
     244:	e1 e3       	ldi	r30, 0x31	; 49
     246:	f0 e0       	ldi	r31, 0x00	; 0
     248:	80 81       	ld	r24, Z
     24a:	48 2f       	mov	r20, r24
     24c:	8a 81       	ldd	r24, Y+2	; 0x02
     24e:	28 2f       	mov	r18, r24
     250:	30 e0       	ldi	r19, 0x00	; 0
     252:	81 e0       	ldi	r24, 0x01	; 1
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	02 2e       	mov	r0, r18
     258:	02 c0       	rjmp	.+4      	; 0x25e <DIO_SetPinDirection+0x1cc>
     25a:	88 0f       	add	r24, r24
     25c:	99 1f       	adc	r25, r25
     25e:	0a 94       	dec	r0
     260:	e2 f7       	brpl	.-8      	; 0x25a <DIO_SetPinDirection+0x1c8>
     262:	84 2b       	or	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	0f 90       	pop	r0
     26c:	0f 90       	pop	r0
     26e:	0f 90       	pop	r0
     270:	cf 91       	pop	r28
     272:	df 91       	pop	r29
     274:	08 95       	ret

00000276 <DIO_SetPinValue>:
	}
}


void DIO_SetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
     276:	df 93       	push	r29
     278:	cf 93       	push	r28
     27a:	00 d0       	rcall	.+0      	; 0x27c <DIO_SetPinValue+0x6>
     27c:	00 d0       	rcall	.+0      	; 0x27e <DIO_SetPinValue+0x8>
     27e:	0f 92       	push	r0
     280:	cd b7       	in	r28, 0x3d	; 61
     282:	de b7       	in	r29, 0x3e	; 62
     284:	89 83       	std	Y+1, r24	; 0x01
     286:	6a 83       	std	Y+2, r22	; 0x02
     288:	4b 83       	std	Y+3, r20	; 0x03
	switch(Copy_u8Port)
     28a:	89 81       	ldd	r24, Y+1	; 0x01
     28c:	28 2f       	mov	r18, r24
     28e:	30 e0       	ldi	r19, 0x00	; 0
     290:	3d 83       	std	Y+5, r19	; 0x05
     292:	2c 83       	std	Y+4, r18	; 0x04
     294:	8c 81       	ldd	r24, Y+4	; 0x04
     296:	9d 81       	ldd	r25, Y+5	; 0x05
     298:	81 30       	cpi	r24, 0x01	; 1
     29a:	91 05       	cpc	r25, r1
     29c:	09 f4       	brne	.+2      	; 0x2a0 <DIO_SetPinValue+0x2a>
     29e:	47 c0       	rjmp	.+142    	; 0x32e <DIO_SetPinValue+0xb8>
     2a0:	2c 81       	ldd	r18, Y+4	; 0x04
     2a2:	3d 81       	ldd	r19, Y+5	; 0x05
     2a4:	22 30       	cpi	r18, 0x02	; 2
     2a6:	31 05       	cpc	r19, r1
     2a8:	2c f4       	brge	.+10     	; 0x2b4 <DIO_SetPinValue+0x3e>
     2aa:	8c 81       	ldd	r24, Y+4	; 0x04
     2ac:	9d 81       	ldd	r25, Y+5	; 0x05
     2ae:	00 97       	sbiw	r24, 0x00	; 0
     2b0:	71 f0       	breq	.+28     	; 0x2ce <DIO_SetPinValue+0x58>
     2b2:	cb c0       	rjmp	.+406    	; 0x44a <DIO_SetPinValue+0x1d4>
     2b4:	2c 81       	ldd	r18, Y+4	; 0x04
     2b6:	3d 81       	ldd	r19, Y+5	; 0x05
     2b8:	22 30       	cpi	r18, 0x02	; 2
     2ba:	31 05       	cpc	r19, r1
     2bc:	09 f4       	brne	.+2      	; 0x2c0 <DIO_SetPinValue+0x4a>
     2be:	67 c0       	rjmp	.+206    	; 0x38e <DIO_SetPinValue+0x118>
     2c0:	8c 81       	ldd	r24, Y+4	; 0x04
     2c2:	9d 81       	ldd	r25, Y+5	; 0x05
     2c4:	83 30       	cpi	r24, 0x03	; 3
     2c6:	91 05       	cpc	r25, r1
     2c8:	09 f4       	brne	.+2      	; 0x2cc <DIO_SetPinValue+0x56>
     2ca:	91 c0       	rjmp	.+290    	; 0x3ee <DIO_SetPinValue+0x178>
     2cc:	be c0       	rjmp	.+380    	; 0x44a <DIO_SetPinValue+0x1d4>
	{
	case PORTA:
		if(Copy_u8Value==LOW)
     2ce:	8b 81       	ldd	r24, Y+3	; 0x03
     2d0:	88 23       	and	r24, r24
     2d2:	a9 f4       	brne	.+42     	; 0x2fe <DIO_SetPinValue+0x88>
			CLR_BIT(PORTA_Register,Copy_u8Pin);
     2d4:	ab e3       	ldi	r26, 0x3B	; 59
     2d6:	b0 e0       	ldi	r27, 0x00	; 0
     2d8:	eb e3       	ldi	r30, 0x3B	; 59
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	80 81       	ld	r24, Z
     2de:	48 2f       	mov	r20, r24
     2e0:	8a 81       	ldd	r24, Y+2	; 0x02
     2e2:	28 2f       	mov	r18, r24
     2e4:	30 e0       	ldi	r19, 0x00	; 0
     2e6:	81 e0       	ldi	r24, 0x01	; 1
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	02 2e       	mov	r0, r18
     2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <DIO_SetPinValue+0x7c>
     2ee:	88 0f       	add	r24, r24
     2f0:	99 1f       	adc	r25, r25
     2f2:	0a 94       	dec	r0
     2f4:	e2 f7       	brpl	.-8      	; 0x2ee <DIO_SetPinValue+0x78>
     2f6:	80 95       	com	r24
     2f8:	84 23       	and	r24, r20
     2fa:	8c 93       	st	X, r24
     2fc:	a6 c0       	rjmp	.+332    	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     2fe:	8b 81       	ldd	r24, Y+3	; 0x03
     300:	81 30       	cpi	r24, 0x01	; 1
     302:	09 f0       	breq	.+2      	; 0x306 <DIO_SetPinValue+0x90>
     304:	a2 c0       	rjmp	.+324    	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTA_Register,Copy_u8Pin);
     306:	ab e3       	ldi	r26, 0x3B	; 59
     308:	b0 e0       	ldi	r27, 0x00	; 0
     30a:	eb e3       	ldi	r30, 0x3B	; 59
     30c:	f0 e0       	ldi	r31, 0x00	; 0
     30e:	80 81       	ld	r24, Z
     310:	48 2f       	mov	r20, r24
     312:	8a 81       	ldd	r24, Y+2	; 0x02
     314:	28 2f       	mov	r18, r24
     316:	30 e0       	ldi	r19, 0x00	; 0
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	02 2e       	mov	r0, r18
     31e:	02 c0       	rjmp	.+4      	; 0x324 <DIO_SetPinValue+0xae>
     320:	88 0f       	add	r24, r24
     322:	99 1f       	adc	r25, r25
     324:	0a 94       	dec	r0
     326:	e2 f7       	brpl	.-8      	; 0x320 <DIO_SetPinValue+0xaa>
     328:	84 2b       	or	r24, r20
     32a:	8c 93       	st	X, r24
     32c:	8e c0       	rjmp	.+284    	; 0x44a <DIO_SetPinValue+0x1d4>
		break;
	case PORTB:
		if(Copy_u8Value==LOW)
     32e:	8b 81       	ldd	r24, Y+3	; 0x03
     330:	88 23       	and	r24, r24
     332:	a9 f4       	brne	.+42     	; 0x35e <DIO_SetPinValue+0xe8>
			CLR_BIT(PORTB_Register,Copy_u8Pin);
     334:	a8 e3       	ldi	r26, 0x38	; 56
     336:	b0 e0       	ldi	r27, 0x00	; 0
     338:	e8 e3       	ldi	r30, 0x38	; 56
     33a:	f0 e0       	ldi	r31, 0x00	; 0
     33c:	80 81       	ld	r24, Z
     33e:	48 2f       	mov	r20, r24
     340:	8a 81       	ldd	r24, Y+2	; 0x02
     342:	28 2f       	mov	r18, r24
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	81 e0       	ldi	r24, 0x01	; 1
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	02 2e       	mov	r0, r18
     34c:	02 c0       	rjmp	.+4      	; 0x352 <DIO_SetPinValue+0xdc>
     34e:	88 0f       	add	r24, r24
     350:	99 1f       	adc	r25, r25
     352:	0a 94       	dec	r0
     354:	e2 f7       	brpl	.-8      	; 0x34e <DIO_SetPinValue+0xd8>
     356:	80 95       	com	r24
     358:	84 23       	and	r24, r20
     35a:	8c 93       	st	X, r24
     35c:	76 c0       	rjmp	.+236    	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     35e:	8b 81       	ldd	r24, Y+3	; 0x03
     360:	81 30       	cpi	r24, 0x01	; 1
     362:	09 f0       	breq	.+2      	; 0x366 <DIO_SetPinValue+0xf0>
     364:	72 c0       	rjmp	.+228    	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTB_Register,Copy_u8Pin);
     366:	a8 e3       	ldi	r26, 0x38	; 56
     368:	b0 e0       	ldi	r27, 0x00	; 0
     36a:	e8 e3       	ldi	r30, 0x38	; 56
     36c:	f0 e0       	ldi	r31, 0x00	; 0
     36e:	80 81       	ld	r24, Z
     370:	48 2f       	mov	r20, r24
     372:	8a 81       	ldd	r24, Y+2	; 0x02
     374:	28 2f       	mov	r18, r24
     376:	30 e0       	ldi	r19, 0x00	; 0
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	02 2e       	mov	r0, r18
     37e:	02 c0       	rjmp	.+4      	; 0x384 <DIO_SetPinValue+0x10e>
     380:	88 0f       	add	r24, r24
     382:	99 1f       	adc	r25, r25
     384:	0a 94       	dec	r0
     386:	e2 f7       	brpl	.-8      	; 0x380 <DIO_SetPinValue+0x10a>
     388:	84 2b       	or	r24, r20
     38a:	8c 93       	st	X, r24
     38c:	5e c0       	rjmp	.+188    	; 0x44a <DIO_SetPinValue+0x1d4>
		break;
	case PORTC:
		if(Copy_u8Value==LOW)
     38e:	8b 81       	ldd	r24, Y+3	; 0x03
     390:	88 23       	and	r24, r24
     392:	a9 f4       	brne	.+42     	; 0x3be <DIO_SetPinValue+0x148>
			CLR_BIT(PORTC_Register,Copy_u8Pin);
     394:	a5 e3       	ldi	r26, 0x35	; 53
     396:	b0 e0       	ldi	r27, 0x00	; 0
     398:	e5 e3       	ldi	r30, 0x35	; 53
     39a:	f0 e0       	ldi	r31, 0x00	; 0
     39c:	80 81       	ld	r24, Z
     39e:	48 2f       	mov	r20, r24
     3a0:	8a 81       	ldd	r24, Y+2	; 0x02
     3a2:	28 2f       	mov	r18, r24
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	02 2e       	mov	r0, r18
     3ac:	02 c0       	rjmp	.+4      	; 0x3b2 <DIO_SetPinValue+0x13c>
     3ae:	88 0f       	add	r24, r24
     3b0:	99 1f       	adc	r25, r25
     3b2:	0a 94       	dec	r0
     3b4:	e2 f7       	brpl	.-8      	; 0x3ae <DIO_SetPinValue+0x138>
     3b6:	80 95       	com	r24
     3b8:	84 23       	and	r24, r20
     3ba:	8c 93       	st	X, r24
     3bc:	46 c0       	rjmp	.+140    	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     3be:	8b 81       	ldd	r24, Y+3	; 0x03
     3c0:	81 30       	cpi	r24, 0x01	; 1
     3c2:	09 f0       	breq	.+2      	; 0x3c6 <DIO_SetPinValue+0x150>
     3c4:	42 c0       	rjmp	.+132    	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTC_Register,Copy_u8Pin);
     3c6:	a5 e3       	ldi	r26, 0x35	; 53
     3c8:	b0 e0       	ldi	r27, 0x00	; 0
     3ca:	e5 e3       	ldi	r30, 0x35	; 53
     3cc:	f0 e0       	ldi	r31, 0x00	; 0
     3ce:	80 81       	ld	r24, Z
     3d0:	48 2f       	mov	r20, r24
     3d2:	8a 81       	ldd	r24, Y+2	; 0x02
     3d4:	28 2f       	mov	r18, r24
     3d6:	30 e0       	ldi	r19, 0x00	; 0
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	02 2e       	mov	r0, r18
     3de:	02 c0       	rjmp	.+4      	; 0x3e4 <DIO_SetPinValue+0x16e>
     3e0:	88 0f       	add	r24, r24
     3e2:	99 1f       	adc	r25, r25
     3e4:	0a 94       	dec	r0
     3e6:	e2 f7       	brpl	.-8      	; 0x3e0 <DIO_SetPinValue+0x16a>
     3e8:	84 2b       	or	r24, r20
     3ea:	8c 93       	st	X, r24
     3ec:	2e c0       	rjmp	.+92     	; 0x44a <DIO_SetPinValue+0x1d4>
		break;
	case PORTD:
		if(Copy_u8Value==LOW)
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	88 23       	and	r24, r24
     3f2:	a9 f4       	brne	.+42     	; 0x41e <DIO_SetPinValue+0x1a8>
			CLR_BIT(PORTD_Register,Copy_u8Pin);
     3f4:	a2 e3       	ldi	r26, 0x32	; 50
     3f6:	b0 e0       	ldi	r27, 0x00	; 0
     3f8:	e2 e3       	ldi	r30, 0x32	; 50
     3fa:	f0 e0       	ldi	r31, 0x00	; 0
     3fc:	80 81       	ld	r24, Z
     3fe:	48 2f       	mov	r20, r24
     400:	8a 81       	ldd	r24, Y+2	; 0x02
     402:	28 2f       	mov	r18, r24
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	81 e0       	ldi	r24, 0x01	; 1
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	02 2e       	mov	r0, r18
     40c:	02 c0       	rjmp	.+4      	; 0x412 <DIO_SetPinValue+0x19c>
     40e:	88 0f       	add	r24, r24
     410:	99 1f       	adc	r25, r25
     412:	0a 94       	dec	r0
     414:	e2 f7       	brpl	.-8      	; 0x40e <DIO_SetPinValue+0x198>
     416:	80 95       	com	r24
     418:	84 23       	and	r24, r20
     41a:	8c 93       	st	X, r24
     41c:	16 c0       	rjmp	.+44     	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	99 f4       	brne	.+38     	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTD_Register,Copy_u8Pin);
     424:	a2 e3       	ldi	r26, 0x32	; 50
     426:	b0 e0       	ldi	r27, 0x00	; 0
     428:	e2 e3       	ldi	r30, 0x32	; 50
     42a:	f0 e0       	ldi	r31, 0x00	; 0
     42c:	80 81       	ld	r24, Z
     42e:	48 2f       	mov	r20, r24
     430:	8a 81       	ldd	r24, Y+2	; 0x02
     432:	28 2f       	mov	r18, r24
     434:	30 e0       	ldi	r19, 0x00	; 0
     436:	81 e0       	ldi	r24, 0x01	; 1
     438:	90 e0       	ldi	r25, 0x00	; 0
     43a:	02 2e       	mov	r0, r18
     43c:	02 c0       	rjmp	.+4      	; 0x442 <DIO_SetPinValue+0x1cc>
     43e:	88 0f       	add	r24, r24
     440:	99 1f       	adc	r25, r25
     442:	0a 94       	dec	r0
     444:	e2 f7       	brpl	.-8      	; 0x43e <DIO_SetPinValue+0x1c8>
     446:	84 2b       	or	r24, r20
     448:	8c 93       	st	X, r24
		break;
	default:
		break;
	}
}
     44a:	0f 90       	pop	r0
     44c:	0f 90       	pop	r0
     44e:	0f 90       	pop	r0
     450:	0f 90       	pop	r0
     452:	0f 90       	pop	r0
     454:	cf 91       	pop	r28
     456:	df 91       	pop	r29
     458:	08 95       	ret

0000045a <DIO_GetPinValue>:

u8 DIO_GetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin)
{
     45a:	df 93       	push	r29
     45c:	cf 93       	push	r28
     45e:	00 d0       	rcall	.+0      	; 0x460 <DIO_GetPinValue+0x6>
     460:	00 d0       	rcall	.+0      	; 0x462 <DIO_GetPinValue+0x8>
     462:	0f 92       	push	r0
     464:	cd b7       	in	r28, 0x3d	; 61
     466:	de b7       	in	r29, 0x3e	; 62
     468:	8a 83       	std	Y+2, r24	; 0x02
     46a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Copy_u8LocalVariable;
	switch(Copy_u8Port)
     46c:	8a 81       	ldd	r24, Y+2	; 0x02
     46e:	28 2f       	mov	r18, r24
     470:	30 e0       	ldi	r19, 0x00	; 0
     472:	3d 83       	std	Y+5, r19	; 0x05
     474:	2c 83       	std	Y+4, r18	; 0x04
     476:	4c 81       	ldd	r20, Y+4	; 0x04
     478:	5d 81       	ldd	r21, Y+5	; 0x05
     47a:	41 30       	cpi	r20, 0x01	; 1
     47c:	51 05       	cpc	r21, r1
     47e:	41 f1       	breq	.+80     	; 0x4d0 <DIO_GetPinValue+0x76>
     480:	8c 81       	ldd	r24, Y+4	; 0x04
     482:	9d 81       	ldd	r25, Y+5	; 0x05
     484:	82 30       	cpi	r24, 0x02	; 2
     486:	91 05       	cpc	r25, r1
     488:	34 f4       	brge	.+12     	; 0x496 <DIO_GetPinValue+0x3c>
     48a:	2c 81       	ldd	r18, Y+4	; 0x04
     48c:	3d 81       	ldd	r19, Y+5	; 0x05
     48e:	21 15       	cp	r18, r1
     490:	31 05       	cpc	r19, r1
     492:	61 f0       	breq	.+24     	; 0x4ac <DIO_GetPinValue+0x52>
     494:	52 c0       	rjmp	.+164    	; 0x53a <DIO_GetPinValue+0xe0>
     496:	4c 81       	ldd	r20, Y+4	; 0x04
     498:	5d 81       	ldd	r21, Y+5	; 0x05
     49a:	42 30       	cpi	r20, 0x02	; 2
     49c:	51 05       	cpc	r21, r1
     49e:	51 f1       	breq	.+84     	; 0x4f4 <DIO_GetPinValue+0x9a>
     4a0:	8c 81       	ldd	r24, Y+4	; 0x04
     4a2:	9d 81       	ldd	r25, Y+5	; 0x05
     4a4:	83 30       	cpi	r24, 0x03	; 3
     4a6:	91 05       	cpc	r25, r1
     4a8:	b9 f1       	breq	.+110    	; 0x518 <DIO_GetPinValue+0xbe>
     4aa:	47 c0       	rjmp	.+142    	; 0x53a <DIO_GetPinValue+0xe0>
	{
	case PORTA:
		Copy_u8LocalVariable = GET_BIT(PINA, Copy_u8Pin);
     4ac:	e9 e3       	ldi	r30, 0x39	; 57
     4ae:	f0 e0       	ldi	r31, 0x00	; 0
     4b0:	80 81       	ld	r24, Z
     4b2:	28 2f       	mov	r18, r24
     4b4:	30 e0       	ldi	r19, 0x00	; 0
     4b6:	8b 81       	ldd	r24, Y+3	; 0x03
     4b8:	88 2f       	mov	r24, r24
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	a9 01       	movw	r20, r18
     4be:	02 c0       	rjmp	.+4      	; 0x4c4 <DIO_GetPinValue+0x6a>
     4c0:	55 95       	asr	r21
     4c2:	47 95       	ror	r20
     4c4:	8a 95       	dec	r24
     4c6:	e2 f7       	brpl	.-8      	; 0x4c0 <DIO_GetPinValue+0x66>
     4c8:	ca 01       	movw	r24, r20
     4ca:	81 70       	andi	r24, 0x01	; 1
     4cc:	89 83       	std	Y+1, r24	; 0x01
     4ce:	35 c0       	rjmp	.+106    	; 0x53a <DIO_GetPinValue+0xe0>
		break;
	case PORTB:
		Copy_u8LocalVariable = GET_BIT(PINB, Copy_u8Pin);
     4d0:	e6 e3       	ldi	r30, 0x36	; 54
     4d2:	f0 e0       	ldi	r31, 0x00	; 0
     4d4:	80 81       	ld	r24, Z
     4d6:	28 2f       	mov	r18, r24
     4d8:	30 e0       	ldi	r19, 0x00	; 0
     4da:	8b 81       	ldd	r24, Y+3	; 0x03
     4dc:	88 2f       	mov	r24, r24
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	a9 01       	movw	r20, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_GetPinValue+0x8e>
     4e4:	55 95       	asr	r21
     4e6:	47 95       	ror	r20
     4e8:	8a 95       	dec	r24
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_GetPinValue+0x8a>
     4ec:	ca 01       	movw	r24, r20
     4ee:	81 70       	andi	r24, 0x01	; 1
     4f0:	89 83       	std	Y+1, r24	; 0x01
     4f2:	23 c0       	rjmp	.+70     	; 0x53a <DIO_GetPinValue+0xe0>
		break;
	case PORTC:
		Copy_u8LocalVariable = GET_BIT(PINC, Copy_u8Pin);
     4f4:	e3 e3       	ldi	r30, 0x33	; 51
     4f6:	f0 e0       	ldi	r31, 0x00	; 0
     4f8:	80 81       	ld	r24, Z
     4fa:	28 2f       	mov	r18, r24
     4fc:	30 e0       	ldi	r19, 0x00	; 0
     4fe:	8b 81       	ldd	r24, Y+3	; 0x03
     500:	88 2f       	mov	r24, r24
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	a9 01       	movw	r20, r18
     506:	02 c0       	rjmp	.+4      	; 0x50c <DIO_GetPinValue+0xb2>
     508:	55 95       	asr	r21
     50a:	47 95       	ror	r20
     50c:	8a 95       	dec	r24
     50e:	e2 f7       	brpl	.-8      	; 0x508 <DIO_GetPinValue+0xae>
     510:	ca 01       	movw	r24, r20
     512:	81 70       	andi	r24, 0x01	; 1
     514:	89 83       	std	Y+1, r24	; 0x01
     516:	11 c0       	rjmp	.+34     	; 0x53a <DIO_GetPinValue+0xe0>
		break;
	case PORTD:
		Copy_u8LocalVariable = GET_BIT(PIND, Copy_u8Pin);
     518:	e0 e3       	ldi	r30, 0x30	; 48
     51a:	f0 e0       	ldi	r31, 0x00	; 0
     51c:	80 81       	ld	r24, Z
     51e:	28 2f       	mov	r18, r24
     520:	30 e0       	ldi	r19, 0x00	; 0
     522:	8b 81       	ldd	r24, Y+3	; 0x03
     524:	88 2f       	mov	r24, r24
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	a9 01       	movw	r20, r18
     52a:	02 c0       	rjmp	.+4      	; 0x530 <DIO_GetPinValue+0xd6>
     52c:	55 95       	asr	r21
     52e:	47 95       	ror	r20
     530:	8a 95       	dec	r24
     532:	e2 f7       	brpl	.-8      	; 0x52c <DIO_GetPinValue+0xd2>
     534:	ca 01       	movw	r24, r20
     536:	81 70       	andi	r24, 0x01	; 1
     538:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Copy_u8LocalVariable;
     53a:	89 81       	ldd	r24, Y+1	; 0x01
}
     53c:	0f 90       	pop	r0
     53e:	0f 90       	pop	r0
     540:	0f 90       	pop	r0
     542:	0f 90       	pop	r0
     544:	0f 90       	pop	r0
     546:	cf 91       	pop	r28
     548:	df 91       	pop	r29
     54a:	08 95       	ret

0000054c <DIO_GetPinValueByPtr>:


void DIO_GetPinValueByPtr(u8 Copy_u8Port, u8 Copy_u8Pin, u8 * Copy_u8ptr)
{
     54c:	df 93       	push	r29
     54e:	cf 93       	push	r28
     550:	00 d0       	rcall	.+0      	; 0x552 <DIO_GetPinValueByPtr+0x6>
     552:	00 d0       	rcall	.+0      	; 0x554 <DIO_GetPinValueByPtr+0x8>
     554:	00 d0       	rcall	.+0      	; 0x556 <DIO_GetPinValueByPtr+0xa>
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
     55a:	89 83       	std	Y+1, r24	; 0x01
     55c:	6a 83       	std	Y+2, r22	; 0x02
     55e:	5c 83       	std	Y+4, r21	; 0x04
     560:	4b 83       	std	Y+3, r20	; 0x03
	switch(Copy_u8Port)
     562:	89 81       	ldd	r24, Y+1	; 0x01
     564:	28 2f       	mov	r18, r24
     566:	30 e0       	ldi	r19, 0x00	; 0
     568:	3e 83       	std	Y+6, r19	; 0x06
     56a:	2d 83       	std	Y+5, r18	; 0x05
     56c:	4d 81       	ldd	r20, Y+5	; 0x05
     56e:	5e 81       	ldd	r21, Y+6	; 0x06
     570:	41 30       	cpi	r20, 0x01	; 1
     572:	51 05       	cpc	r21, r1
     574:	59 f1       	breq	.+86     	; 0x5cc <DIO_GetPinValueByPtr+0x80>
     576:	8d 81       	ldd	r24, Y+5	; 0x05
     578:	9e 81       	ldd	r25, Y+6	; 0x06
     57a:	82 30       	cpi	r24, 0x02	; 2
     57c:	91 05       	cpc	r25, r1
     57e:	34 f4       	brge	.+12     	; 0x58c <DIO_GetPinValueByPtr+0x40>
     580:	2d 81       	ldd	r18, Y+5	; 0x05
     582:	3e 81       	ldd	r19, Y+6	; 0x06
     584:	21 15       	cp	r18, r1
     586:	31 05       	cpc	r19, r1
     588:	69 f0       	breq	.+26     	; 0x5a4 <DIO_GetPinValueByPtr+0x58>
     58a:	5b c0       	rjmp	.+182    	; 0x642 <DIO_GetPinValueByPtr+0xf6>
     58c:	4d 81       	ldd	r20, Y+5	; 0x05
     58e:	5e 81       	ldd	r21, Y+6	; 0x06
     590:	42 30       	cpi	r20, 0x02	; 2
     592:	51 05       	cpc	r21, r1
     594:	79 f1       	breq	.+94     	; 0x5f4 <DIO_GetPinValueByPtr+0xa8>
     596:	8d 81       	ldd	r24, Y+5	; 0x05
     598:	9e 81       	ldd	r25, Y+6	; 0x06
     59a:	83 30       	cpi	r24, 0x03	; 3
     59c:	91 05       	cpc	r25, r1
     59e:	09 f4       	brne	.+2      	; 0x5a2 <DIO_GetPinValueByPtr+0x56>
     5a0:	3d c0       	rjmp	.+122    	; 0x61c <DIO_GetPinValueByPtr+0xd0>
     5a2:	4f c0       	rjmp	.+158    	; 0x642 <DIO_GetPinValueByPtr+0xf6>
	{
	case PORTA:
		*Copy_u8ptr = GET_BIT(PINA, Copy_u8Pin);
     5a4:	e9 e3       	ldi	r30, 0x39	; 57
     5a6:	f0 e0       	ldi	r31, 0x00	; 0
     5a8:	80 81       	ld	r24, Z
     5aa:	28 2f       	mov	r18, r24
     5ac:	30 e0       	ldi	r19, 0x00	; 0
     5ae:	8a 81       	ldd	r24, Y+2	; 0x02
     5b0:	88 2f       	mov	r24, r24
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	a9 01       	movw	r20, r18
     5b6:	02 c0       	rjmp	.+4      	; 0x5bc <DIO_GetPinValueByPtr+0x70>
     5b8:	55 95       	asr	r21
     5ba:	47 95       	ror	r20
     5bc:	8a 95       	dec	r24
     5be:	e2 f7       	brpl	.-8      	; 0x5b8 <DIO_GetPinValueByPtr+0x6c>
     5c0:	ca 01       	movw	r24, r20
     5c2:	81 70       	andi	r24, 0x01	; 1
     5c4:	eb 81       	ldd	r30, Y+3	; 0x03
     5c6:	fc 81       	ldd	r31, Y+4	; 0x04
     5c8:	80 83       	st	Z, r24
     5ca:	3b c0       	rjmp	.+118    	; 0x642 <DIO_GetPinValueByPtr+0xf6>
		break;
	case PORTB:
		*Copy_u8ptr = GET_BIT(PINB, Copy_u8Pin);
     5cc:	e6 e3       	ldi	r30, 0x36	; 54
     5ce:	f0 e0       	ldi	r31, 0x00	; 0
     5d0:	80 81       	ld	r24, Z
     5d2:	28 2f       	mov	r18, r24
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	8a 81       	ldd	r24, Y+2	; 0x02
     5d8:	88 2f       	mov	r24, r24
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	a9 01       	movw	r20, r18
     5de:	02 c0       	rjmp	.+4      	; 0x5e4 <DIO_GetPinValueByPtr+0x98>
     5e0:	55 95       	asr	r21
     5e2:	47 95       	ror	r20
     5e4:	8a 95       	dec	r24
     5e6:	e2 f7       	brpl	.-8      	; 0x5e0 <DIO_GetPinValueByPtr+0x94>
     5e8:	ca 01       	movw	r24, r20
     5ea:	81 70       	andi	r24, 0x01	; 1
     5ec:	eb 81       	ldd	r30, Y+3	; 0x03
     5ee:	fc 81       	ldd	r31, Y+4	; 0x04
     5f0:	80 83       	st	Z, r24
     5f2:	27 c0       	rjmp	.+78     	; 0x642 <DIO_GetPinValueByPtr+0xf6>
		break;
	case PORTC:
		*Copy_u8ptr = GET_BIT(PINC, Copy_u8Pin);
     5f4:	e3 e3       	ldi	r30, 0x33	; 51
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
     5f8:	80 81       	ld	r24, Z
     5fa:	28 2f       	mov	r18, r24
     5fc:	30 e0       	ldi	r19, 0x00	; 0
     5fe:	8a 81       	ldd	r24, Y+2	; 0x02
     600:	88 2f       	mov	r24, r24
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	a9 01       	movw	r20, r18
     606:	02 c0       	rjmp	.+4      	; 0x60c <DIO_GetPinValueByPtr+0xc0>
     608:	55 95       	asr	r21
     60a:	47 95       	ror	r20
     60c:	8a 95       	dec	r24
     60e:	e2 f7       	brpl	.-8      	; 0x608 <DIO_GetPinValueByPtr+0xbc>
     610:	ca 01       	movw	r24, r20
     612:	81 70       	andi	r24, 0x01	; 1
     614:	eb 81       	ldd	r30, Y+3	; 0x03
     616:	fc 81       	ldd	r31, Y+4	; 0x04
     618:	80 83       	st	Z, r24
     61a:	13 c0       	rjmp	.+38     	; 0x642 <DIO_GetPinValueByPtr+0xf6>
		break;
	case PORTD:
		*Copy_u8ptr = GET_BIT(PIND, Copy_u8Pin);
     61c:	e0 e3       	ldi	r30, 0x30	; 48
     61e:	f0 e0       	ldi	r31, 0x00	; 0
     620:	80 81       	ld	r24, Z
     622:	28 2f       	mov	r18, r24
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	8a 81       	ldd	r24, Y+2	; 0x02
     628:	88 2f       	mov	r24, r24
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	a9 01       	movw	r20, r18
     62e:	02 c0       	rjmp	.+4      	; 0x634 <DIO_GetPinValueByPtr+0xe8>
     630:	55 95       	asr	r21
     632:	47 95       	ror	r20
     634:	8a 95       	dec	r24
     636:	e2 f7       	brpl	.-8      	; 0x630 <DIO_GetPinValueByPtr+0xe4>
     638:	ca 01       	movw	r24, r20
     63a:	81 70       	andi	r24, 0x01	; 1
     63c:	eb 81       	ldd	r30, Y+3	; 0x03
     63e:	fc 81       	ldd	r31, Y+4	; 0x04
     640:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
}
     642:	26 96       	adiw	r28, 0x06	; 6
     644:	0f b6       	in	r0, 0x3f	; 63
     646:	f8 94       	cli
     648:	de bf       	out	0x3e, r29	; 62
     64a:	0f be       	out	0x3f, r0	; 63
     64c:	cd bf       	out	0x3d, r28	; 61
     64e:	cf 91       	pop	r28
     650:	df 91       	pop	r29
     652:	08 95       	ret

00000654 <DIO_SetPortDirection>:

void DIO_SetPortDirection(u8 Copy_u8Port, u8 Copy_u8Direction)
{
     654:	df 93       	push	r29
     656:	cf 93       	push	r28
     658:	00 d0       	rcall	.+0      	; 0x65a <DIO_SetPortDirection+0x6>
     65a:	00 d0       	rcall	.+0      	; 0x65c <DIO_SetPortDirection+0x8>
     65c:	cd b7       	in	r28, 0x3d	; 61
     65e:	de b7       	in	r29, 0x3e	; 62
     660:	89 83       	std	Y+1, r24	; 0x01
     662:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8Port)
     664:	89 81       	ldd	r24, Y+1	; 0x01
     666:	28 2f       	mov	r18, r24
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	3c 83       	std	Y+4, r19	; 0x04
     66c:	2b 83       	std	Y+3, r18	; 0x03
     66e:	8b 81       	ldd	r24, Y+3	; 0x03
     670:	9c 81       	ldd	r25, Y+4	; 0x04
     672:	81 30       	cpi	r24, 0x01	; 1
     674:	91 05       	cpc	r25, r1
     676:	d1 f0       	breq	.+52     	; 0x6ac <DIO_SetPortDirection+0x58>
     678:	2b 81       	ldd	r18, Y+3	; 0x03
     67a:	3c 81       	ldd	r19, Y+4	; 0x04
     67c:	22 30       	cpi	r18, 0x02	; 2
     67e:	31 05       	cpc	r19, r1
     680:	2c f4       	brge	.+10     	; 0x68c <DIO_SetPortDirection+0x38>
     682:	8b 81       	ldd	r24, Y+3	; 0x03
     684:	9c 81       	ldd	r25, Y+4	; 0x04
     686:	00 97       	sbiw	r24, 0x00	; 0
     688:	61 f0       	breq	.+24     	; 0x6a2 <DIO_SetPortDirection+0x4e>
     68a:	1e c0       	rjmp	.+60     	; 0x6c8 <DIO_SetPortDirection+0x74>
     68c:	2b 81       	ldd	r18, Y+3	; 0x03
     68e:	3c 81       	ldd	r19, Y+4	; 0x04
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 05       	cpc	r19, r1
     694:	81 f0       	breq	.+32     	; 0x6b6 <DIO_SetPortDirection+0x62>
     696:	8b 81       	ldd	r24, Y+3	; 0x03
     698:	9c 81       	ldd	r25, Y+4	; 0x04
     69a:	83 30       	cpi	r24, 0x03	; 3
     69c:	91 05       	cpc	r25, r1
     69e:	81 f0       	breq	.+32     	; 0x6c0 <DIO_SetPortDirection+0x6c>
     6a0:	13 c0       	rjmp	.+38     	; 0x6c8 <DIO_SetPortDirection+0x74>
	{
	case PORTA:
		DDRA = Copy_u8Direction;
     6a2:	ea e3       	ldi	r30, 0x3A	; 58
     6a4:	f0 e0       	ldi	r31, 0x00	; 0
     6a6:	8a 81       	ldd	r24, Y+2	; 0x02
     6a8:	80 83       	st	Z, r24
     6aa:	0e c0       	rjmp	.+28     	; 0x6c8 <DIO_SetPortDirection+0x74>
		break;
	case PORTB:
		DDRB = Copy_u8Direction;
     6ac:	e7 e3       	ldi	r30, 0x37	; 55
     6ae:	f0 e0       	ldi	r31, 0x00	; 0
     6b0:	8a 81       	ldd	r24, Y+2	; 0x02
     6b2:	80 83       	st	Z, r24
     6b4:	09 c0       	rjmp	.+18     	; 0x6c8 <DIO_SetPortDirection+0x74>
		break;
	case PORTC:
		DDRC = Copy_u8Direction;
     6b6:	e4 e3       	ldi	r30, 0x34	; 52
     6b8:	f0 e0       	ldi	r31, 0x00	; 0
     6ba:	8a 81       	ldd	r24, Y+2	; 0x02
     6bc:	80 83       	st	Z, r24
     6be:	04 c0       	rjmp	.+8      	; 0x6c8 <DIO_SetPortDirection+0x74>
		break;
	case PORTD:
		DDRD = Copy_u8Direction;
     6c0:	e1 e3       	ldi	r30, 0x31	; 49
     6c2:	f0 e0       	ldi	r31, 0x00	; 0
     6c4:	8a 81       	ldd	r24, Y+2	; 0x02
     6c6:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
}
     6c8:	0f 90       	pop	r0
     6ca:	0f 90       	pop	r0
     6cc:	0f 90       	pop	r0
     6ce:	0f 90       	pop	r0
     6d0:	cf 91       	pop	r28
     6d2:	df 91       	pop	r29
     6d4:	08 95       	ret

000006d6 <DIO_SetPortValue>:
void DIO_SetPortValue(u8 Copy_u8Port, u8 Copy_u8Value)
{
     6d6:	df 93       	push	r29
     6d8:	cf 93       	push	r28
     6da:	00 d0       	rcall	.+0      	; 0x6dc <DIO_SetPortValue+0x6>
     6dc:	00 d0       	rcall	.+0      	; 0x6de <DIO_SetPortValue+0x8>
     6de:	cd b7       	in	r28, 0x3d	; 61
     6e0:	de b7       	in	r29, 0x3e	; 62
     6e2:	89 83       	std	Y+1, r24	; 0x01
     6e4:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8Port)
     6e6:	89 81       	ldd	r24, Y+1	; 0x01
     6e8:	28 2f       	mov	r18, r24
     6ea:	30 e0       	ldi	r19, 0x00	; 0
     6ec:	3c 83       	std	Y+4, r19	; 0x04
     6ee:	2b 83       	std	Y+3, r18	; 0x03
     6f0:	8b 81       	ldd	r24, Y+3	; 0x03
     6f2:	9c 81       	ldd	r25, Y+4	; 0x04
     6f4:	81 30       	cpi	r24, 0x01	; 1
     6f6:	91 05       	cpc	r25, r1
     6f8:	d1 f0       	breq	.+52     	; 0x72e <DIO_SetPortValue+0x58>
     6fa:	2b 81       	ldd	r18, Y+3	; 0x03
     6fc:	3c 81       	ldd	r19, Y+4	; 0x04
     6fe:	22 30       	cpi	r18, 0x02	; 2
     700:	31 05       	cpc	r19, r1
     702:	2c f4       	brge	.+10     	; 0x70e <DIO_SetPortValue+0x38>
     704:	8b 81       	ldd	r24, Y+3	; 0x03
     706:	9c 81       	ldd	r25, Y+4	; 0x04
     708:	00 97       	sbiw	r24, 0x00	; 0
     70a:	61 f0       	breq	.+24     	; 0x724 <DIO_SetPortValue+0x4e>
     70c:	1e c0       	rjmp	.+60     	; 0x74a <DIO_SetPortValue+0x74>
     70e:	2b 81       	ldd	r18, Y+3	; 0x03
     710:	3c 81       	ldd	r19, Y+4	; 0x04
     712:	22 30       	cpi	r18, 0x02	; 2
     714:	31 05       	cpc	r19, r1
     716:	81 f0       	breq	.+32     	; 0x738 <DIO_SetPortValue+0x62>
     718:	8b 81       	ldd	r24, Y+3	; 0x03
     71a:	9c 81       	ldd	r25, Y+4	; 0x04
     71c:	83 30       	cpi	r24, 0x03	; 3
     71e:	91 05       	cpc	r25, r1
     720:	81 f0       	breq	.+32     	; 0x742 <DIO_SetPortValue+0x6c>
     722:	13 c0       	rjmp	.+38     	; 0x74a <DIO_SetPortValue+0x74>
	{
	case PORTA:
		PORTA_Register = Copy_u8Value;
     724:	eb e3       	ldi	r30, 0x3B	; 59
     726:	f0 e0       	ldi	r31, 0x00	; 0
     728:	8a 81       	ldd	r24, Y+2	; 0x02
     72a:	80 83       	st	Z, r24
     72c:	0e c0       	rjmp	.+28     	; 0x74a <DIO_SetPortValue+0x74>
		break;
	case PORTB:
		PORTB_Register = Copy_u8Value;
     72e:	e8 e3       	ldi	r30, 0x38	; 56
     730:	f0 e0       	ldi	r31, 0x00	; 0
     732:	8a 81       	ldd	r24, Y+2	; 0x02
     734:	80 83       	st	Z, r24
     736:	09 c0       	rjmp	.+18     	; 0x74a <DIO_SetPortValue+0x74>
		break;
	case PORTC:
		PORTC_Register = Copy_u8Value;
     738:	e5 e3       	ldi	r30, 0x35	; 53
     73a:	f0 e0       	ldi	r31, 0x00	; 0
     73c:	8a 81       	ldd	r24, Y+2	; 0x02
     73e:	80 83       	st	Z, r24
     740:	04 c0       	rjmp	.+8      	; 0x74a <DIO_SetPortValue+0x74>
		break;
	case PORTD:
		PORTD_Register = Copy_u8Value;
     742:	e2 e3       	ldi	r30, 0x32	; 50
     744:	f0 e0       	ldi	r31, 0x00	; 0
     746:	8a 81       	ldd	r24, Y+2	; 0x02
     748:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
}
     74a:	0f 90       	pop	r0
     74c:	0f 90       	pop	r0
     74e:	0f 90       	pop	r0
     750:	0f 90       	pop	r0
     752:	cf 91       	pop	r28
     754:	df 91       	pop	r29
     756:	08 95       	ret

00000758 <EXTI_SetTriggerMode>:
void(*EXTI1_GlobalPtr)(void)=0;
void(*EXTI2_GlobalPtr)(void)=0;


void EXTI_SetTriggerMode(void)
{
     758:	df 93       	push	r29
     75a:	cf 93       	push	r28
     75c:	cd b7       	in	r28, 0x3d	; 61
     75e:	de b7       	in	r29, 0x3e	; 62

#if(EXTI0_mode==FallingEdge)
	SET_BIT(MCUCR_Register,ISC01);
     760:	a5 e5       	ldi	r26, 0x55	; 85
     762:	b0 e0       	ldi	r27, 0x00	; 0
     764:	e5 e5       	ldi	r30, 0x55	; 85
     766:	f0 e0       	ldi	r31, 0x00	; 0
     768:	80 81       	ld	r24, Z
     76a:	82 60       	ori	r24, 0x02	; 2
     76c:	8c 93       	st	X, r24
	CLR_BIT(MCUCR_Register,ISC00);
     76e:	a5 e5       	ldi	r26, 0x55	; 85
     770:	b0 e0       	ldi	r27, 0x00	; 0
     772:	e5 e5       	ldi	r30, 0x55	; 85
     774:	f0 e0       	ldi	r31, 0x00	; 0
     776:	80 81       	ld	r24, Z
     778:	8e 7f       	andi	r24, 0xFE	; 254
     77a:	8c 93       	st	X, r24
#if(EXTI1_mode==FallingEdge)
	SET_BIT(MCUCR_Register,ISC11);
	CLR_BIT(MCUCR_Register,ISC10);

#elif(EXTI1_mode==RisingEdge)
	SET_BIT(MCUCR_Register,ISC11);
     77c:	a5 e5       	ldi	r26, 0x55	; 85
     77e:	b0 e0       	ldi	r27, 0x00	; 0
     780:	e5 e5       	ldi	r30, 0x55	; 85
     782:	f0 e0       	ldi	r31, 0x00	; 0
     784:	80 81       	ld	r24, Z
     786:	88 60       	ori	r24, 0x08	; 8
     788:	8c 93       	st	X, r24
	SET_BIT(MCUCR_Register,ISC10);
     78a:	a5 e5       	ldi	r26, 0x55	; 85
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	e5 e5       	ldi	r30, 0x55	; 85
     790:	f0 e0       	ldi	r31, 0x00	; 0
     792:	80 81       	ld	r24, Z
     794:	84 60       	ori	r24, 0x04	; 4
     796:	8c 93       	st	X, r24

#if(EXTI2_mode==FallingEdge)
	CLR_BIT(MCUCSR_Register,ISC2);

#elif(EXTI2_mode==RisingEdge)
	SET_BIT(MCUCSR_Register,ISC2);
     798:	a4 e5       	ldi	r26, 0x54	; 84
     79a:	b0 e0       	ldi	r27, 0x00	; 0
     79c:	e4 e5       	ldi	r30, 0x54	; 84
     79e:	f0 e0       	ldi	r31, 0x00	; 0
     7a0:	80 81       	ld	r24, Z
     7a2:	80 64       	ori	r24, 0x40	; 64
     7a4:	8c 93       	st	X, r24

#endif

}
     7a6:	cf 91       	pop	r28
     7a8:	df 91       	pop	r29
     7aa:	08 95       	ret

000007ac <EXTI0_ChangeTriggerMode>:

void EXTI0_ChangeTriggerMode(u8 Copy_u8Mode)
{
     7ac:	df 93       	push	r29
     7ae:	cf 93       	push	r28
     7b0:	00 d0       	rcall	.+0      	; 0x7b2 <EXTI0_ChangeTriggerMode+0x6>
     7b2:	0f 92       	push	r0
     7b4:	cd b7       	in	r28, 0x3d	; 61
     7b6:	de b7       	in	r29, 0x3e	; 62
     7b8:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8Mode)
     7ba:	89 81       	ldd	r24, Y+1	; 0x01
     7bc:	28 2f       	mov	r18, r24
     7be:	30 e0       	ldi	r19, 0x00	; 0
     7c0:	3b 83       	std	Y+3, r19	; 0x03
     7c2:	2a 83       	std	Y+2, r18	; 0x02
     7c4:	8a 81       	ldd	r24, Y+2	; 0x02
     7c6:	9b 81       	ldd	r25, Y+3	; 0x03
     7c8:	81 30       	cpi	r24, 0x01	; 1
     7ca:	91 05       	cpc	r25, r1
     7cc:	21 f1       	breq	.+72     	; 0x816 <EXTI0_ChangeTriggerMode+0x6a>
     7ce:	2a 81       	ldd	r18, Y+2	; 0x02
     7d0:	3b 81       	ldd	r19, Y+3	; 0x03
     7d2:	22 30       	cpi	r18, 0x02	; 2
     7d4:	31 05       	cpc	r19, r1
     7d6:	2c f4       	brge	.+10     	; 0x7e2 <EXTI0_ChangeTriggerMode+0x36>
     7d8:	8a 81       	ldd	r24, Y+2	; 0x02
     7da:	9b 81       	ldd	r25, Y+3	; 0x03
     7dc:	00 97       	sbiw	r24, 0x00	; 0
     7de:	61 f0       	breq	.+24     	; 0x7f8 <EXTI0_ChangeTriggerMode+0x4c>
     7e0:	46 c0       	rjmp	.+140    	; 0x86e <__stack+0xf>
     7e2:	2a 81       	ldd	r18, Y+2	; 0x02
     7e4:	3b 81       	ldd	r19, Y+3	; 0x03
     7e6:	22 30       	cpi	r18, 0x02	; 2
     7e8:	31 05       	cpc	r19, r1
     7ea:	21 f1       	breq	.+72     	; 0x834 <EXTI0_ChangeTriggerMode+0x88>
     7ec:	8a 81       	ldd	r24, Y+2	; 0x02
     7ee:	9b 81       	ldd	r25, Y+3	; 0x03
     7f0:	83 30       	cpi	r24, 0x03	; 3
     7f2:	91 05       	cpc	r25, r1
     7f4:	71 f1       	breq	.+92     	; 0x852 <EXTI0_ChangeTriggerMode+0xa6>
     7f6:	3b c0       	rjmp	.+118    	; 0x86e <__stack+0xf>
	{
		case FallingEdge:
			SET_BIT(MCUCR_Register,ISC01);
     7f8:	a5 e5       	ldi	r26, 0x55	; 85
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	e5 e5       	ldi	r30, 0x55	; 85
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	80 81       	ld	r24, Z
     802:	82 60       	ori	r24, 0x02	; 2
     804:	8c 93       	st	X, r24
			CLR_BIT(MCUCR_Register,ISC00);
     806:	a5 e5       	ldi	r26, 0x55	; 85
     808:	b0 e0       	ldi	r27, 0x00	; 0
     80a:	e5 e5       	ldi	r30, 0x55	; 85
     80c:	f0 e0       	ldi	r31, 0x00	; 0
     80e:	80 81       	ld	r24, Z
     810:	8e 7f       	andi	r24, 0xFE	; 254
     812:	8c 93       	st	X, r24
     814:	2c c0       	rjmp	.+88     	; 0x86e <__stack+0xf>
			break;
		case RisingEdge:
			SET_BIT(MCUCR_Register,ISC01);
     816:	a5 e5       	ldi	r26, 0x55	; 85
     818:	b0 e0       	ldi	r27, 0x00	; 0
     81a:	e5 e5       	ldi	r30, 0x55	; 85
     81c:	f0 e0       	ldi	r31, 0x00	; 0
     81e:	80 81       	ld	r24, Z
     820:	82 60       	ori	r24, 0x02	; 2
     822:	8c 93       	st	X, r24
			SET_BIT(MCUCR_Register,ISC00);
     824:	a5 e5       	ldi	r26, 0x55	; 85
     826:	b0 e0       	ldi	r27, 0x00	; 0
     828:	e5 e5       	ldi	r30, 0x55	; 85
     82a:	f0 e0       	ldi	r31, 0x00	; 0
     82c:	80 81       	ld	r24, Z
     82e:	81 60       	ori	r24, 0x01	; 1
     830:	8c 93       	st	X, r24
     832:	1d c0       	rjmp	.+58     	; 0x86e <__stack+0xf>
			break;
		case OnChange:
			SET_BIT(MCUCR_Register,ISC00);
     834:	a5 e5       	ldi	r26, 0x55	; 85
     836:	b0 e0       	ldi	r27, 0x00	; 0
     838:	e5 e5       	ldi	r30, 0x55	; 85
     83a:	f0 e0       	ldi	r31, 0x00	; 0
     83c:	80 81       	ld	r24, Z
     83e:	81 60       	ori	r24, 0x01	; 1
     840:	8c 93       	st	X, r24
			CLR_BIT(MCUCR_Register,ISC01);
     842:	a5 e5       	ldi	r26, 0x55	; 85
     844:	b0 e0       	ldi	r27, 0x00	; 0
     846:	e5 e5       	ldi	r30, 0x55	; 85
     848:	f0 e0       	ldi	r31, 0x00	; 0
     84a:	80 81       	ld	r24, Z
     84c:	8d 7f       	andi	r24, 0xFD	; 253
     84e:	8c 93       	st	X, r24
     850:	0e c0       	rjmp	.+28     	; 0x86e <__stack+0xf>
			break;
		case LowLevel:
			CLR_BIT(MCUCR_Register,ISC00);
     852:	a5 e5       	ldi	r26, 0x55	; 85
     854:	b0 e0       	ldi	r27, 0x00	; 0
     856:	e5 e5       	ldi	r30, 0x55	; 85
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	80 81       	ld	r24, Z
     85c:	8e 7f       	andi	r24, 0xFE	; 254
     85e:	8c 93       	st	X, r24
			CLR_BIT(MCUCR_Register,ISC01);
     860:	a5 e5       	ldi	r26, 0x55	; 85
     862:	b0 e0       	ldi	r27, 0x00	; 0
     864:	e5 e5       	ldi	r30, 0x55	; 85
     866:	f0 e0       	ldi	r31, 0x00	; 0
     868:	80 81       	ld	r24, Z
     86a:	8d 7f       	andi	r24, 0xFD	; 253
     86c:	8c 93       	st	X, r24
			break;
		default:
			break;
	}
}
     86e:	0f 90       	pop	r0
     870:	0f 90       	pop	r0
     872:	0f 90       	pop	r0
     874:	cf 91       	pop	r28
     876:	df 91       	pop	r29
     878:	08 95       	ret

0000087a <EXTI_Enable>:


void EXTI_Enable(u8 Copy_u8IntNumber)
{
     87a:	df 93       	push	r29
     87c:	cf 93       	push	r28
     87e:	00 d0       	rcall	.+0      	; 0x880 <EXTI_Enable+0x6>
     880:	0f 92       	push	r0
     882:	cd b7       	in	r28, 0x3d	; 61
     884:	de b7       	in	r29, 0x3e	; 62
     886:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8IntNumber) {
     888:	89 81       	ldd	r24, Y+1	; 0x01
     88a:	28 2f       	mov	r18, r24
     88c:	30 e0       	ldi	r19, 0x00	; 0
     88e:	3b 83       	std	Y+3, r19	; 0x03
     890:	2a 83       	std	Y+2, r18	; 0x02
     892:	8a 81       	ldd	r24, Y+2	; 0x02
     894:	9b 81       	ldd	r25, Y+3	; 0x03
     896:	81 30       	cpi	r24, 0x01	; 1
     898:	91 05       	cpc	r25, r1
     89a:	89 f0       	breq	.+34     	; 0x8be <EXTI_Enable+0x44>
     89c:	2a 81       	ldd	r18, Y+2	; 0x02
     89e:	3b 81       	ldd	r19, Y+3	; 0x03
     8a0:	22 30       	cpi	r18, 0x02	; 2
     8a2:	31 05       	cpc	r19, r1
     8a4:	a1 f0       	breq	.+40     	; 0x8ce <EXTI_Enable+0x54>
     8a6:	8a 81       	ldd	r24, Y+2	; 0x02
     8a8:	9b 81       	ldd	r25, Y+3	; 0x03
     8aa:	00 97       	sbiw	r24, 0x00	; 0
     8ac:	b9 f4       	brne	.+46     	; 0x8dc <EXTI_Enable+0x62>
	case EXTI0:
		SET_BIT(GICR_Register,INT0);
     8ae:	ab e5       	ldi	r26, 0x5B	; 91
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	eb e5       	ldi	r30, 0x5B	; 91
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	80 81       	ld	r24, Z
     8b8:	80 64       	ori	r24, 0x40	; 64
     8ba:	8c 93       	st	X, r24
     8bc:	0f c0       	rjmp	.+30     	; 0x8dc <EXTI_Enable+0x62>
		break;
	case EXTI1:
		SET_BIT(GICR_Register,INT1);
     8be:	ab e5       	ldi	r26, 0x5B	; 91
     8c0:	b0 e0       	ldi	r27, 0x00	; 0
     8c2:	eb e5       	ldi	r30, 0x5B	; 91
     8c4:	f0 e0       	ldi	r31, 0x00	; 0
     8c6:	80 81       	ld	r24, Z
     8c8:	80 68       	ori	r24, 0x80	; 128
     8ca:	8c 93       	st	X, r24
     8cc:	07 c0       	rjmp	.+14     	; 0x8dc <EXTI_Enable+0x62>
		break;
	case EXTI2:
		SET_BIT(GICR_Register,INT2);
     8ce:	ab e5       	ldi	r26, 0x5B	; 91
     8d0:	b0 e0       	ldi	r27, 0x00	; 0
     8d2:	eb e5       	ldi	r30, 0x5B	; 91
     8d4:	f0 e0       	ldi	r31, 0x00	; 0
     8d6:	80 81       	ld	r24, Z
     8d8:	80 62       	ori	r24, 0x20	; 32
     8da:	8c 93       	st	X, r24
		break;
	default:
		break;
	}

}
     8dc:	0f 90       	pop	r0
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	cf 91       	pop	r28
     8e4:	df 91       	pop	r29
     8e6:	08 95       	ret

000008e8 <EXTI_Disable>:
void EXTI_Disable(u8 Copy_u8IntNumber)
{
     8e8:	df 93       	push	r29
     8ea:	cf 93       	push	r28
     8ec:	00 d0       	rcall	.+0      	; 0x8ee <EXTI_Disable+0x6>
     8ee:	0f 92       	push	r0
     8f0:	cd b7       	in	r28, 0x3d	; 61
     8f2:	de b7       	in	r29, 0x3e	; 62
     8f4:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8IntNumber) {
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	28 2f       	mov	r18, r24
     8fa:	30 e0       	ldi	r19, 0x00	; 0
     8fc:	3b 83       	std	Y+3, r19	; 0x03
     8fe:	2a 83       	std	Y+2, r18	; 0x02
     900:	8a 81       	ldd	r24, Y+2	; 0x02
     902:	9b 81       	ldd	r25, Y+3	; 0x03
     904:	81 30       	cpi	r24, 0x01	; 1
     906:	91 05       	cpc	r25, r1
     908:	89 f0       	breq	.+34     	; 0x92c <EXTI_Disable+0x44>
     90a:	2a 81       	ldd	r18, Y+2	; 0x02
     90c:	3b 81       	ldd	r19, Y+3	; 0x03
     90e:	22 30       	cpi	r18, 0x02	; 2
     910:	31 05       	cpc	r19, r1
     912:	a1 f0       	breq	.+40     	; 0x93c <EXTI_Disable+0x54>
     914:	8a 81       	ldd	r24, Y+2	; 0x02
     916:	9b 81       	ldd	r25, Y+3	; 0x03
     918:	00 97       	sbiw	r24, 0x00	; 0
     91a:	b9 f4       	brne	.+46     	; 0x94a <EXTI_Disable+0x62>
	case EXTI0:
		CLR_BIT(GICR_Register,INT0);
     91c:	ab e5       	ldi	r26, 0x5B	; 91
     91e:	b0 e0       	ldi	r27, 0x00	; 0
     920:	eb e5       	ldi	r30, 0x5B	; 91
     922:	f0 e0       	ldi	r31, 0x00	; 0
     924:	80 81       	ld	r24, Z
     926:	8f 7b       	andi	r24, 0xBF	; 191
     928:	8c 93       	st	X, r24
     92a:	0f c0       	rjmp	.+30     	; 0x94a <EXTI_Disable+0x62>
		break;
	case EXTI1:
		CLR_BIT(GICR_Register,INT1);
     92c:	ab e5       	ldi	r26, 0x5B	; 91
     92e:	b0 e0       	ldi	r27, 0x00	; 0
     930:	eb e5       	ldi	r30, 0x5B	; 91
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	80 81       	ld	r24, Z
     936:	8f 77       	andi	r24, 0x7F	; 127
     938:	8c 93       	st	X, r24
     93a:	07 c0       	rjmp	.+14     	; 0x94a <EXTI_Disable+0x62>
		break;
	case EXTI2:
		CLR_BIT(GICR_Register,INT2);
     93c:	ab e5       	ldi	r26, 0x5B	; 91
     93e:	b0 e0       	ldi	r27, 0x00	; 0
     940:	eb e5       	ldi	r30, 0x5B	; 91
     942:	f0 e0       	ldi	r31, 0x00	; 0
     944:	80 81       	ld	r24, Z
     946:	8f 7d       	andi	r24, 0xDF	; 223
     948:	8c 93       	st	X, r24
		break;
	default:
		break;
	}

}
     94a:	0f 90       	pop	r0
     94c:	0f 90       	pop	r0
     94e:	0f 90       	pop	r0
     950:	cf 91       	pop	r28
     952:	df 91       	pop	r29
     954:	08 95       	ret

00000956 <EXTI0_CallBackFunc>:


void EXTI0_CallBackFunc(void(*ptr)(void))
{
     956:	df 93       	push	r29
     958:	cf 93       	push	r28
     95a:	00 d0       	rcall	.+0      	; 0x95c <EXTI0_CallBackFunc+0x6>
     95c:	cd b7       	in	r28, 0x3d	; 61
     95e:	de b7       	in	r29, 0x3e	; 62
     960:	9a 83       	std	Y+2, r25	; 0x02
     962:	89 83       	std	Y+1, r24	; 0x01
	EXTI0_GlobalPtr=ptr;
     964:	89 81       	ldd	r24, Y+1	; 0x01
     966:	9a 81       	ldd	r25, Y+2	; 0x02
     968:	90 93 69 00 	sts	0x0069, r25
     96c:	80 93 68 00 	sts	0x0068, r24
}
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	cf 91       	pop	r28
     976:	df 91       	pop	r29
     978:	08 95       	ret

0000097a <EXTI1_CallBackFunc>:
void EXTI1_CallBackFunc(void(*ptr)(void))
{
     97a:	df 93       	push	r29
     97c:	cf 93       	push	r28
     97e:	00 d0       	rcall	.+0      	; 0x980 <EXTI1_CallBackFunc+0x6>
     980:	cd b7       	in	r28, 0x3d	; 61
     982:	de b7       	in	r29, 0x3e	; 62
     984:	9a 83       	std	Y+2, r25	; 0x02
     986:	89 83       	std	Y+1, r24	; 0x01
	EXTI1_GlobalPtr=ptr;
     988:	89 81       	ldd	r24, Y+1	; 0x01
     98a:	9a 81       	ldd	r25, Y+2	; 0x02
     98c:	90 93 6b 00 	sts	0x006B, r25
     990:	80 93 6a 00 	sts	0x006A, r24

}
     994:	0f 90       	pop	r0
     996:	0f 90       	pop	r0
     998:	cf 91       	pop	r28
     99a:	df 91       	pop	r29
     99c:	08 95       	ret

0000099e <EXTI2_CallBackFunc>:
void EXTI2_CallBackFunc(void(*ptr)(void))
{
     99e:	df 93       	push	r29
     9a0:	cf 93       	push	r28
     9a2:	00 d0       	rcall	.+0      	; 0x9a4 <EXTI2_CallBackFunc+0x6>
     9a4:	cd b7       	in	r28, 0x3d	; 61
     9a6:	de b7       	in	r29, 0x3e	; 62
     9a8:	9a 83       	std	Y+2, r25	; 0x02
     9aa:	89 83       	std	Y+1, r24	; 0x01
	EXTI2_GlobalPtr=ptr;
     9ac:	89 81       	ldd	r24, Y+1	; 0x01
     9ae:	9a 81       	ldd	r25, Y+2	; 0x02
     9b0:	90 93 6d 00 	sts	0x006D, r25
     9b4:	80 93 6c 00 	sts	0x006C, r24
}
     9b8:	0f 90       	pop	r0
     9ba:	0f 90       	pop	r0
     9bc:	cf 91       	pop	r28
     9be:	df 91       	pop	r29
     9c0:	08 95       	ret

000009c2 <__vector_1>:

void __vector_1 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_1 (void)
{
     9c2:	1f 92       	push	r1
     9c4:	0f 92       	push	r0
     9c6:	0f b6       	in	r0, 0x3f	; 63
     9c8:	0f 92       	push	r0
     9ca:	11 24       	eor	r1, r1
     9cc:	2f 93       	push	r18
     9ce:	3f 93       	push	r19
     9d0:	4f 93       	push	r20
     9d2:	5f 93       	push	r21
     9d4:	6f 93       	push	r22
     9d6:	7f 93       	push	r23
     9d8:	8f 93       	push	r24
     9da:	9f 93       	push	r25
     9dc:	af 93       	push	r26
     9de:	bf 93       	push	r27
     9e0:	ef 93       	push	r30
     9e2:	ff 93       	push	r31
     9e4:	df 93       	push	r29
     9e6:	cf 93       	push	r28
     9e8:	cd b7       	in	r28, 0x3d	; 61
     9ea:	de b7       	in	r29, 0x3e	; 62
	EXTI0_GlobalPtr();
     9ec:	e0 91 68 00 	lds	r30, 0x0068
     9f0:	f0 91 69 00 	lds	r31, 0x0069
     9f4:	09 95       	icall
}
     9f6:	cf 91       	pop	r28
     9f8:	df 91       	pop	r29
     9fa:	ff 91       	pop	r31
     9fc:	ef 91       	pop	r30
     9fe:	bf 91       	pop	r27
     a00:	af 91       	pop	r26
     a02:	9f 91       	pop	r25
     a04:	8f 91       	pop	r24
     a06:	7f 91       	pop	r23
     a08:	6f 91       	pop	r22
     a0a:	5f 91       	pop	r21
     a0c:	4f 91       	pop	r20
     a0e:	3f 91       	pop	r19
     a10:	2f 91       	pop	r18
     a12:	0f 90       	pop	r0
     a14:	0f be       	out	0x3f, r0	; 63
     a16:	0f 90       	pop	r0
     a18:	1f 90       	pop	r1
     a1a:	18 95       	reti

00000a1c <__vector_2>:

void __vector_2 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_2 (void)
{
     a1c:	1f 92       	push	r1
     a1e:	0f 92       	push	r0
     a20:	0f b6       	in	r0, 0x3f	; 63
     a22:	0f 92       	push	r0
     a24:	11 24       	eor	r1, r1
     a26:	2f 93       	push	r18
     a28:	3f 93       	push	r19
     a2a:	4f 93       	push	r20
     a2c:	5f 93       	push	r21
     a2e:	6f 93       	push	r22
     a30:	7f 93       	push	r23
     a32:	8f 93       	push	r24
     a34:	9f 93       	push	r25
     a36:	af 93       	push	r26
     a38:	bf 93       	push	r27
     a3a:	ef 93       	push	r30
     a3c:	ff 93       	push	r31
     a3e:	df 93       	push	r29
     a40:	cf 93       	push	r28
     a42:	cd b7       	in	r28, 0x3d	; 61
     a44:	de b7       	in	r29, 0x3e	; 62
	EXTI1_GlobalPtr();
     a46:	e0 91 6a 00 	lds	r30, 0x006A
     a4a:	f0 91 6b 00 	lds	r31, 0x006B
     a4e:	09 95       	icall
}
     a50:	cf 91       	pop	r28
     a52:	df 91       	pop	r29
     a54:	ff 91       	pop	r31
     a56:	ef 91       	pop	r30
     a58:	bf 91       	pop	r27
     a5a:	af 91       	pop	r26
     a5c:	9f 91       	pop	r25
     a5e:	8f 91       	pop	r24
     a60:	7f 91       	pop	r23
     a62:	6f 91       	pop	r22
     a64:	5f 91       	pop	r21
     a66:	4f 91       	pop	r20
     a68:	3f 91       	pop	r19
     a6a:	2f 91       	pop	r18
     a6c:	0f 90       	pop	r0
     a6e:	0f be       	out	0x3f, r0	; 63
     a70:	0f 90       	pop	r0
     a72:	1f 90       	pop	r1
     a74:	18 95       	reti

00000a76 <__vector_3>:

void __vector_3 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_3 (void)
{
     a76:	1f 92       	push	r1
     a78:	0f 92       	push	r0
     a7a:	0f b6       	in	r0, 0x3f	; 63
     a7c:	0f 92       	push	r0
     a7e:	11 24       	eor	r1, r1
     a80:	2f 93       	push	r18
     a82:	3f 93       	push	r19
     a84:	4f 93       	push	r20
     a86:	5f 93       	push	r21
     a88:	6f 93       	push	r22
     a8a:	7f 93       	push	r23
     a8c:	8f 93       	push	r24
     a8e:	9f 93       	push	r25
     a90:	af 93       	push	r26
     a92:	bf 93       	push	r27
     a94:	ef 93       	push	r30
     a96:	ff 93       	push	r31
     a98:	df 93       	push	r29
     a9a:	cf 93       	push	r28
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
	EXTI2_GlobalPtr();
     aa0:	e0 91 6c 00 	lds	r30, 0x006C
     aa4:	f0 91 6d 00 	lds	r31, 0x006D
     aa8:	09 95       	icall
}
     aaa:	cf 91       	pop	r28
     aac:	df 91       	pop	r29
     aae:	ff 91       	pop	r31
     ab0:	ef 91       	pop	r30
     ab2:	bf 91       	pop	r27
     ab4:	af 91       	pop	r26
     ab6:	9f 91       	pop	r25
     ab8:	8f 91       	pop	r24
     aba:	7f 91       	pop	r23
     abc:	6f 91       	pop	r22
     abe:	5f 91       	pop	r21
     ac0:	4f 91       	pop	r20
     ac2:	3f 91       	pop	r19
     ac4:	2f 91       	pop	r18
     ac6:	0f 90       	pop	r0
     ac8:	0f be       	out	0x3f, r0	; 63
     aca:	0f 90       	pop	r0
     acc:	1f 90       	pop	r1
     ace:	18 95       	reti

00000ad0 <GIE_Enable>:
#include "GIE_int.h"



void GIE_Enable(void)
{
     ad0:	df 93       	push	r29
     ad2:	cf 93       	push	r28
     ad4:	cd b7       	in	r28, 0x3d	; 61
     ad6:	de b7       	in	r29, 0x3e	; 62
SET_BIT(SREG_Register,I);
     ad8:	af e5       	ldi	r26, 0x5F	; 95
     ada:	b0 e0       	ldi	r27, 0x00	; 0
     adc:	ef e5       	ldi	r30, 0x5F	; 95
     ade:	f0 e0       	ldi	r31, 0x00	; 0
     ae0:	80 81       	ld	r24, Z
     ae2:	80 68       	ori	r24, 0x80	; 128
     ae4:	8c 93       	st	X, r24
}
     ae6:	cf 91       	pop	r28
     ae8:	df 91       	pop	r29
     aea:	08 95       	ret

00000aec <GIE_Disable>:
void GIE_Disable(void)
{
     aec:	df 93       	push	r29
     aee:	cf 93       	push	r28
     af0:	cd b7       	in	r28, 0x3d	; 61
     af2:	de b7       	in	r29, 0x3e	; 62
CLR_BIT(SREG_Register,I);
     af4:	af e5       	ldi	r26, 0x5F	; 95
     af6:	b0 e0       	ldi	r27, 0x00	; 0
     af8:	ef e5       	ldi	r30, 0x5F	; 95
     afa:	f0 e0       	ldi	r31, 0x00	; 0
     afc:	80 81       	ld	r24, Z
     afe:	8f 77       	andi	r24, 0x7F	; 127
     b00:	8c 93       	st	X, r24
}
     b02:	cf 91       	pop	r28
     b04:	df 91       	pop	r29
     b06:	08 95       	ret

00000b08 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     b08:	df 93       	push	r29
     b0a:	cf 93       	push	r28
     b0c:	cd b7       	in	r28, 0x3d	; 61
     b0e:	de b7       	in	r29, 0x3e	; 62
     b10:	27 97       	sbiw	r28, 0x07	; 7
     b12:	0f b6       	in	r0, 0x3f	; 63
     b14:	f8 94       	cli
     b16:	de bf       	out	0x3e, r29	; 62
     b18:	0f be       	out	0x3f, r0	; 63
     b1a:	cd bf       	out	0x3d, r28	; 61
     b1c:	9d 83       	std	Y+5, r25	; 0x05
     b1e:	8c 83       	std	Y+4, r24	; 0x04
     b20:	6e 83       	std	Y+6, r22	; 0x06
     b22:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     b24:	8a e1       	ldi	r24, 0x1A	; 26
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
     b2c:	9a 83       	std	Y+2, r25	; 0x02
     b2e:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     b30:	89 81       	ldd	r24, Y+1	; 0x01
     b32:	9a 81       	ldd	r25, Y+2	; 0x02
     b34:	00 97       	sbiw	r24, 0x00	; 0
     b36:	09 f4       	brne	.+2      	; 0xb3a <xCoRoutineCreate+0x32>
     b38:	6f c0       	rjmp	.+222    	; 0xc18 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     b3a:	80 91 6e 00 	lds	r24, 0x006E
     b3e:	90 91 6f 00 	lds	r25, 0x006F
     b42:	00 97       	sbiw	r24, 0x00	; 0
     b44:	41 f4       	brne	.+16     	; 0xb56 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     b46:	89 81       	ldd	r24, Y+1	; 0x01
     b48:	9a 81       	ldd	r25, Y+2	; 0x02
     b4a:	90 93 6f 00 	sts	0x006F, r25
     b4e:	80 93 6e 00 	sts	0x006E, r24
			prvInitialiseCoRoutineLists();
     b52:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     b56:	8e 81       	ldd	r24, Y+6	; 0x06
     b58:	82 30       	cpi	r24, 0x02	; 2
     b5a:	10 f0       	brcs	.+4      	; 0xb60 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
     b5e:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     b60:	e9 81       	ldd	r30, Y+1	; 0x01
     b62:	fa 81       	ldd	r31, Y+2	; 0x02
     b64:	11 8e       	std	Z+25, r1	; 0x19
     b66:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     b68:	e9 81       	ldd	r30, Y+1	; 0x01
     b6a:	fa 81       	ldd	r31, Y+2	; 0x02
     b6c:	8e 81       	ldd	r24, Y+6	; 0x06
     b6e:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     b70:	e9 81       	ldd	r30, Y+1	; 0x01
     b72:	fa 81       	ldd	r31, Y+2	; 0x02
     b74:	8f 81       	ldd	r24, Y+7	; 0x07
     b76:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     b78:	e9 81       	ldd	r30, Y+1	; 0x01
     b7a:	fa 81       	ldd	r31, Y+2	; 0x02
     b7c:	8c 81       	ldd	r24, Y+4	; 0x04
     b7e:	9d 81       	ldd	r25, Y+5	; 0x05
     b80:	91 83       	std	Z+1, r25	; 0x01
     b82:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	02 96       	adiw	r24, 0x02	; 2
     b8a:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     b8e:	89 81       	ldd	r24, Y+1	; 0x01
     b90:	9a 81       	ldd	r25, Y+2	; 0x02
     b92:	0c 96       	adiw	r24, 0x0c	; 12
     b94:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     b98:	e9 81       	ldd	r30, Y+1	; 0x01
     b9a:	fa 81       	ldd	r31, Y+2	; 0x02
     b9c:	89 81       	ldd	r24, Y+1	; 0x01
     b9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ba0:	91 87       	std	Z+9, r25	; 0x09
     ba2:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     ba4:	e9 81       	ldd	r30, Y+1	; 0x01
     ba6:	fa 81       	ldd	r31, Y+2	; 0x02
     ba8:	89 81       	ldd	r24, Y+1	; 0x01
     baa:	9a 81       	ldd	r25, Y+2	; 0x02
     bac:	93 8b       	std	Z+19, r25	; 0x13
     bae:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     bb0:	8e 81       	ldd	r24, Y+6	; 0x06
     bb2:	28 2f       	mov	r18, r24
     bb4:	30 e0       	ldi	r19, 0x00	; 0
     bb6:	85 e0       	ldi	r24, 0x05	; 5
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	82 1b       	sub	r24, r18
     bbc:	93 0b       	sbc	r25, r19
     bbe:	e9 81       	ldd	r30, Y+1	; 0x01
     bc0:	fa 81       	ldd	r31, Y+2	; 0x02
     bc2:	95 87       	std	Z+13, r25	; 0x0d
     bc4:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     bc6:	e9 81       	ldd	r30, Y+1	; 0x01
     bc8:	fa 81       	ldd	r31, Y+2	; 0x02
     bca:	96 89       	ldd	r25, Z+22	; 0x16
     bcc:	80 91 70 00 	lds	r24, 0x0070
     bd0:	89 17       	cp	r24, r25
     bd2:	28 f4       	brcc	.+10     	; 0xbde <xCoRoutineCreate+0xd6>
     bd4:	e9 81       	ldd	r30, Y+1	; 0x01
     bd6:	fa 81       	ldd	r31, Y+2	; 0x02
     bd8:	86 89       	ldd	r24, Z+22	; 0x16
     bda:	80 93 70 00 	sts	0x0070, r24
     bde:	e9 81       	ldd	r30, Y+1	; 0x01
     be0:	fa 81       	ldd	r31, Y+2	; 0x02
     be2:	86 89       	ldd	r24, Z+22	; 0x16
     be4:	28 2f       	mov	r18, r24
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	c9 01       	movw	r24, r18
     bea:	88 0f       	add	r24, r24
     bec:	99 1f       	adc	r25, r25
     bee:	88 0f       	add	r24, r24
     bf0:	99 1f       	adc	r25, r25
     bf2:	88 0f       	add	r24, r24
     bf4:	99 1f       	adc	r25, r25
     bf6:	82 0f       	add	r24, r18
     bf8:	93 1f       	adc	r25, r19
     bfa:	ac 01       	movw	r20, r24
     bfc:	49 58       	subi	r20, 0x89	; 137
     bfe:	5f 4f       	sbci	r21, 0xFF	; 255
     c00:	89 81       	ldd	r24, Y+1	; 0x01
     c02:	9a 81       	ldd	r25, Y+2	; 0x02
     c04:	9c 01       	movw	r18, r24
     c06:	2e 5f       	subi	r18, 0xFE	; 254
     c08:	3f 4f       	sbci	r19, 0xFF	; 255
     c0a:	ca 01       	movw	r24, r20
     c0c:	b9 01       	movw	r22, r18
     c0e:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

		xReturn = pdPASS;
     c12:	81 e0       	ldi	r24, 0x01	; 1
     c14:	8b 83       	std	Y+3, r24	; 0x03
     c16:	02 c0       	rjmp	.+4      	; 0xc1c <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c18:	8f ef       	ldi	r24, 0xFF	; 255
     c1a:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     c1c:	8b 81       	ldd	r24, Y+3	; 0x03
}
     c1e:	27 96       	adiw	r28, 0x07	; 7
     c20:	0f b6       	in	r0, 0x3f	; 63
     c22:	f8 94       	cli
     c24:	de bf       	out	0x3e, r29	; 62
     c26:	0f be       	out	0x3f, r0	; 63
     c28:	cd bf       	out	0x3d, r28	; 61
     c2a:	cf 91       	pop	r28
     c2c:	df 91       	pop	r29
     c2e:	08 95       	ret

00000c30 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     c30:	df 93       	push	r29
     c32:	cf 93       	push	r28
     c34:	00 d0       	rcall	.+0      	; 0xc36 <vCoRoutineAddToDelayedList+0x6>
     c36:	00 d0       	rcall	.+0      	; 0xc38 <vCoRoutineAddToDelayedList+0x8>
     c38:	00 d0       	rcall	.+0      	; 0xc3a <vCoRoutineAddToDelayedList+0xa>
     c3a:	cd b7       	in	r28, 0x3d	; 61
     c3c:	de b7       	in	r29, 0x3e	; 62
     c3e:	9c 83       	std	Y+4, r25	; 0x04
     c40:	8b 83       	std	Y+3, r24	; 0x03
     c42:	7e 83       	std	Y+6, r23	; 0x06
     c44:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     c46:	20 91 71 00 	lds	r18, 0x0071
     c4a:	30 91 72 00 	lds	r19, 0x0072
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	9c 81       	ldd	r25, Y+4	; 0x04
     c52:	82 0f       	add	r24, r18
     c54:	93 1f       	adc	r25, r19
     c56:	9a 83       	std	Y+2, r25	; 0x02
     c58:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c5a:	80 91 6e 00 	lds	r24, 0x006E
     c5e:	90 91 6f 00 	lds	r25, 0x006F
     c62:	02 96       	adiw	r24, 0x02	; 2
     c64:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     c68:	e0 91 6e 00 	lds	r30, 0x006E
     c6c:	f0 91 6f 00 	lds	r31, 0x006F
     c70:	89 81       	ldd	r24, Y+1	; 0x01
     c72:	9a 81       	ldd	r25, Y+2	; 0x02
     c74:	93 83       	std	Z+3, r25	; 0x03
     c76:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     c78:	20 91 71 00 	lds	r18, 0x0071
     c7c:	30 91 72 00 	lds	r19, 0x0072
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	9a 81       	ldd	r25, Y+2	; 0x02
     c84:	82 17       	cp	r24, r18
     c86:	93 07       	cpc	r25, r19
     c88:	70 f4       	brcc	.+28     	; 0xca6 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c8a:	80 91 9d 00 	lds	r24, 0x009D
     c8e:	90 91 9e 00 	lds	r25, 0x009E
     c92:	20 91 6e 00 	lds	r18, 0x006E
     c96:	30 91 6f 00 	lds	r19, 0x006F
     c9a:	2e 5f       	subi	r18, 0xFE	; 254
     c9c:	3f 4f       	sbci	r19, 0xFF	; 255
     c9e:	b9 01       	movw	r22, r18
     ca0:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
     ca4:	0d c0       	rjmp	.+26     	; 0xcc0 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ca6:	80 91 9b 00 	lds	r24, 0x009B
     caa:	90 91 9c 00 	lds	r25, 0x009C
     cae:	20 91 6e 00 	lds	r18, 0x006E
     cb2:	30 91 6f 00 	lds	r19, 0x006F
     cb6:	2e 5f       	subi	r18, 0xFE	; 254
     cb8:	3f 4f       	sbci	r19, 0xFF	; 255
     cba:	b9 01       	movw	r22, r18
     cbc:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
	}

	if( pxEventList )
     cc0:	8d 81       	ldd	r24, Y+5	; 0x05
     cc2:	9e 81       	ldd	r25, Y+6	; 0x06
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	61 f0       	breq	.+24     	; 0xce0 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     cc8:	80 91 6e 00 	lds	r24, 0x006E
     ccc:	90 91 6f 00 	lds	r25, 0x006F
     cd0:	9c 01       	movw	r18, r24
     cd2:	24 5f       	subi	r18, 0xF4	; 244
     cd4:	3f 4f       	sbci	r19, 0xFF	; 255
     cd6:	8d 81       	ldd	r24, Y+5	; 0x05
     cd8:	9e 81       	ldd	r25, Y+6	; 0x06
     cda:	b9 01       	movw	r22, r18
     cdc:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
	}
}
     ce0:	26 96       	adiw	r28, 0x06	; 6
     ce2:	0f b6       	in	r0, 0x3f	; 63
     ce4:	f8 94       	cli
     ce6:	de bf       	out	0x3e, r29	; 62
     ce8:	0f be       	out	0x3f, r0	; 63
     cea:	cd bf       	out	0x3d, r28	; 61
     cec:	cf 91       	pop	r28
     cee:	df 91       	pop	r29
     cf0:	08 95       	ret

00000cf2 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     cf2:	df 93       	push	r29
     cf4:	cf 93       	push	r28
     cf6:	00 d0       	rcall	.+0      	; 0xcf8 <prvCheckPendingReadyList+0x6>
     cf8:	cd b7       	in	r28, 0x3d	; 61
     cfa:	de b7       	in	r29, 0x3e	; 62
     cfc:	3a c0       	rjmp	.+116    	; 0xd72 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     cfe:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     d00:	e0 91 a4 00 	lds	r30, 0x00A4
     d04:	f0 91 a5 00 	lds	r31, 0x00A5
     d08:	86 81       	ldd	r24, Z+6	; 0x06
     d0a:	97 81       	ldd	r25, Z+7	; 0x07
     d0c:	9a 83       	std	Y+2, r25	; 0x02
     d0e:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d10:	89 81       	ldd	r24, Y+1	; 0x01
     d12:	9a 81       	ldd	r25, Y+2	; 0x02
     d14:	0c 96       	adiw	r24, 0x0c	; 12
     d16:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     d1a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     d1c:	89 81       	ldd	r24, Y+1	; 0x01
     d1e:	9a 81       	ldd	r25, Y+2	; 0x02
     d20:	02 96       	adiw	r24, 0x02	; 2
     d22:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     d26:	e9 81       	ldd	r30, Y+1	; 0x01
     d28:	fa 81       	ldd	r31, Y+2	; 0x02
     d2a:	96 89       	ldd	r25, Z+22	; 0x16
     d2c:	80 91 70 00 	lds	r24, 0x0070
     d30:	89 17       	cp	r24, r25
     d32:	28 f4       	brcc	.+10     	; 0xd3e <prvCheckPendingReadyList+0x4c>
     d34:	e9 81       	ldd	r30, Y+1	; 0x01
     d36:	fa 81       	ldd	r31, Y+2	; 0x02
     d38:	86 89       	ldd	r24, Z+22	; 0x16
     d3a:	80 93 70 00 	sts	0x0070, r24
     d3e:	e9 81       	ldd	r30, Y+1	; 0x01
     d40:	fa 81       	ldd	r31, Y+2	; 0x02
     d42:	86 89       	ldd	r24, Z+22	; 0x16
     d44:	28 2f       	mov	r18, r24
     d46:	30 e0       	ldi	r19, 0x00	; 0
     d48:	c9 01       	movw	r24, r18
     d4a:	88 0f       	add	r24, r24
     d4c:	99 1f       	adc	r25, r25
     d4e:	88 0f       	add	r24, r24
     d50:	99 1f       	adc	r25, r25
     d52:	88 0f       	add	r24, r24
     d54:	99 1f       	adc	r25, r25
     d56:	82 0f       	add	r24, r18
     d58:	93 1f       	adc	r25, r19
     d5a:	ac 01       	movw	r20, r24
     d5c:	49 58       	subi	r20, 0x89	; 137
     d5e:	5f 4f       	sbci	r21, 0xFF	; 255
     d60:	89 81       	ldd	r24, Y+1	; 0x01
     d62:	9a 81       	ldd	r25, Y+2	; 0x02
     d64:	9c 01       	movw	r18, r24
     d66:	2e 5f       	subi	r18, 0xFE	; 254
     d68:	3f 4f       	sbci	r19, 0xFF	; 255
     d6a:	ca 01       	movw	r24, r20
     d6c:	b9 01       	movw	r22, r18
     d6e:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     d72:	80 91 9f 00 	lds	r24, 0x009F
     d76:	88 23       	and	r24, r24
     d78:	09 f0       	breq	.+2      	; 0xd7c <prvCheckPendingReadyList+0x8a>
     d7a:	c1 cf       	rjmp	.-126    	; 0xcfe <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	cf 91       	pop	r28
     d82:	df 91       	pop	r29
     d84:	08 95       	ret

00000d86 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     d86:	df 93       	push	r29
     d88:	cf 93       	push	r28
     d8a:	00 d0       	rcall	.+0      	; 0xd8c <prvCheckDelayedList+0x6>
     d8c:	00 d0       	rcall	.+0      	; 0xd8e <prvCheckDelayedList+0x8>
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     d92:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <xTaskGetTickCount>
     d96:	20 91 73 00 	lds	r18, 0x0073
     d9a:	30 91 74 00 	lds	r19, 0x0074
     d9e:	82 1b       	sub	r24, r18
     da0:	93 0b       	sbc	r25, r19
     da2:	90 93 76 00 	sts	0x0076, r25
     da6:	80 93 75 00 	sts	0x0075, r24
     daa:	85 c0       	rjmp	.+266    	; 0xeb6 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     dac:	80 91 71 00 	lds	r24, 0x0071
     db0:	90 91 72 00 	lds	r25, 0x0072
     db4:	01 96       	adiw	r24, 0x01	; 1
     db6:	90 93 72 00 	sts	0x0072, r25
     dba:	80 93 71 00 	sts	0x0071, r24
		xPassedTicks--;
     dbe:	80 91 75 00 	lds	r24, 0x0075
     dc2:	90 91 76 00 	lds	r25, 0x0076
     dc6:	01 97       	sbiw	r24, 0x01	; 1
     dc8:	90 93 76 00 	sts	0x0076, r25
     dcc:	80 93 75 00 	sts	0x0075, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     dd0:	80 91 71 00 	lds	r24, 0x0071
     dd4:	90 91 72 00 	lds	r25, 0x0072
     dd8:	00 97       	sbiw	r24, 0x00	; 0
     dda:	09 f0       	breq	.+2      	; 0xdde <prvCheckDelayedList+0x58>
     ddc:	64 c0       	rjmp	.+200    	; 0xea6 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     dde:	80 91 9b 00 	lds	r24, 0x009B
     de2:	90 91 9c 00 	lds	r25, 0x009C
     de6:	9a 83       	std	Y+2, r25	; 0x02
     de8:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     dea:	80 91 9d 00 	lds	r24, 0x009D
     dee:	90 91 9e 00 	lds	r25, 0x009E
     df2:	90 93 9c 00 	sts	0x009C, r25
     df6:	80 93 9b 00 	sts	0x009B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     dfa:	89 81       	ldd	r24, Y+1	; 0x01
     dfc:	9a 81       	ldd	r25, Y+2	; 0x02
     dfe:	90 93 9e 00 	sts	0x009E, r25
     e02:	80 93 9d 00 	sts	0x009D, r24
     e06:	4f c0       	rjmp	.+158    	; 0xea6 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     e08:	e0 91 9b 00 	lds	r30, 0x009B
     e0c:	f0 91 9c 00 	lds	r31, 0x009C
     e10:	05 80       	ldd	r0, Z+5	; 0x05
     e12:	f6 81       	ldd	r31, Z+6	; 0x06
     e14:	e0 2d       	mov	r30, r0
     e16:	86 81       	ldd	r24, Z+6	; 0x06
     e18:	97 81       	ldd	r25, Z+7	; 0x07
     e1a:	9c 83       	std	Y+4, r25	; 0x04
     e1c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     e1e:	eb 81       	ldd	r30, Y+3	; 0x03
     e20:	fc 81       	ldd	r31, Y+4	; 0x04
     e22:	22 81       	ldd	r18, Z+2	; 0x02
     e24:	33 81       	ldd	r19, Z+3	; 0x03
     e26:	80 91 71 00 	lds	r24, 0x0071
     e2a:	90 91 72 00 	lds	r25, 0x0072
     e2e:	82 17       	cp	r24, r18
     e30:	93 07       	cpc	r25, r19
     e32:	08 f4       	brcc	.+2      	; 0xe36 <prvCheckDelayedList+0xb0>
     e34:	40 c0       	rjmp	.+128    	; 0xeb6 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     e36:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	9c 81       	ldd	r25, Y+4	; 0x04
     e3c:	02 96       	adiw	r24, 0x02	; 2
     e3e:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     e42:	eb 81       	ldd	r30, Y+3	; 0x03
     e44:	fc 81       	ldd	r31, Y+4	; 0x04
     e46:	84 89       	ldd	r24, Z+20	; 0x14
     e48:	95 89       	ldd	r25, Z+21	; 0x15
     e4a:	00 97       	sbiw	r24, 0x00	; 0
     e4c:	29 f0       	breq	.+10     	; 0xe58 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     e4e:	8b 81       	ldd	r24, Y+3	; 0x03
     e50:	9c 81       	ldd	r25, Y+4	; 0x04
     e52:	0c 96       	adiw	r24, 0x0c	; 12
     e54:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     e58:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     e5a:	eb 81       	ldd	r30, Y+3	; 0x03
     e5c:	fc 81       	ldd	r31, Y+4	; 0x04
     e5e:	96 89       	ldd	r25, Z+22	; 0x16
     e60:	80 91 70 00 	lds	r24, 0x0070
     e64:	89 17       	cp	r24, r25
     e66:	28 f4       	brcc	.+10     	; 0xe72 <prvCheckDelayedList+0xec>
     e68:	eb 81       	ldd	r30, Y+3	; 0x03
     e6a:	fc 81       	ldd	r31, Y+4	; 0x04
     e6c:	86 89       	ldd	r24, Z+22	; 0x16
     e6e:	80 93 70 00 	sts	0x0070, r24
     e72:	eb 81       	ldd	r30, Y+3	; 0x03
     e74:	fc 81       	ldd	r31, Y+4	; 0x04
     e76:	86 89       	ldd	r24, Z+22	; 0x16
     e78:	28 2f       	mov	r18, r24
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	c9 01       	movw	r24, r18
     e7e:	88 0f       	add	r24, r24
     e80:	99 1f       	adc	r25, r25
     e82:	88 0f       	add	r24, r24
     e84:	99 1f       	adc	r25, r25
     e86:	88 0f       	add	r24, r24
     e88:	99 1f       	adc	r25, r25
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	ac 01       	movw	r20, r24
     e90:	49 58       	subi	r20, 0x89	; 137
     e92:	5f 4f       	sbci	r21, 0xFF	; 255
     e94:	8b 81       	ldd	r24, Y+3	; 0x03
     e96:	9c 81       	ldd	r25, Y+4	; 0x04
     e98:	9c 01       	movw	r18, r24
     e9a:	2e 5f       	subi	r18, 0xFE	; 254
     e9c:	3f 4f       	sbci	r19, 0xFF	; 255
     e9e:	ca 01       	movw	r24, r20
     ea0:	b9 01       	movw	r22, r18
     ea2:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     ea6:	e0 91 9b 00 	lds	r30, 0x009B
     eaa:	f0 91 9c 00 	lds	r31, 0x009C
     eae:	80 81       	ld	r24, Z
     eb0:	88 23       	and	r24, r24
     eb2:	09 f0       	breq	.+2      	; 0xeb6 <prvCheckDelayedList+0x130>
     eb4:	a9 cf       	rjmp	.-174    	; 0xe08 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     eb6:	80 91 75 00 	lds	r24, 0x0075
     eba:	90 91 76 00 	lds	r25, 0x0076
     ebe:	00 97       	sbiw	r24, 0x00	; 0
     ec0:	09 f0       	breq	.+2      	; 0xec4 <prvCheckDelayedList+0x13e>
     ec2:	74 cf       	rjmp	.-280    	; 0xdac <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     ec4:	80 91 71 00 	lds	r24, 0x0071
     ec8:	90 91 72 00 	lds	r25, 0x0072
     ecc:	90 93 74 00 	sts	0x0074, r25
     ed0:	80 93 73 00 	sts	0x0073, r24
}
     ed4:	0f 90       	pop	r0
     ed6:	0f 90       	pop	r0
     ed8:	0f 90       	pop	r0
     eda:	0f 90       	pop	r0
     edc:	cf 91       	pop	r28
     ede:	df 91       	pop	r29
     ee0:	08 95       	ret

00000ee2 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     ee2:	df 93       	push	r29
     ee4:	cf 93       	push	r28
     ee6:	00 d0       	rcall	.+0      	; 0xee8 <vCoRoutineSchedule+0x6>
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     eec:	0e 94 79 06 	call	0xcf2	; 0xcf2 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     ef0:	0e 94 c3 06 	call	0xd86	; 0xd86 <prvCheckDelayedList>
     ef4:	0a c0       	rjmp	.+20     	; 0xf0a <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     ef6:	80 91 70 00 	lds	r24, 0x0070
     efa:	88 23       	and	r24, r24
     efc:	09 f4       	brne	.+2      	; 0xf00 <vCoRoutineSchedule+0x1e>
     efe:	66 c0       	rjmp	.+204    	; 0xfcc <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     f00:	80 91 70 00 	lds	r24, 0x0070
     f04:	81 50       	subi	r24, 0x01	; 1
     f06:	80 93 70 00 	sts	0x0070, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     f0a:	80 91 70 00 	lds	r24, 0x0070
     f0e:	28 2f       	mov	r18, r24
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	c9 01       	movw	r24, r18
     f14:	88 0f       	add	r24, r24
     f16:	99 1f       	adc	r25, r25
     f18:	88 0f       	add	r24, r24
     f1a:	99 1f       	adc	r25, r25
     f1c:	88 0f       	add	r24, r24
     f1e:	99 1f       	adc	r25, r25
     f20:	82 0f       	add	r24, r18
     f22:	93 1f       	adc	r25, r19
     f24:	fc 01       	movw	r30, r24
     f26:	e9 58       	subi	r30, 0x89	; 137
     f28:	ff 4f       	sbci	r31, 0xFF	; 255
     f2a:	80 81       	ld	r24, Z
     f2c:	88 23       	and	r24, r24
     f2e:	19 f3       	breq	.-58     	; 0xef6 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     f30:	80 91 70 00 	lds	r24, 0x0070
     f34:	28 2f       	mov	r18, r24
     f36:	30 e0       	ldi	r19, 0x00	; 0
     f38:	c9 01       	movw	r24, r18
     f3a:	88 0f       	add	r24, r24
     f3c:	99 1f       	adc	r25, r25
     f3e:	88 0f       	add	r24, r24
     f40:	99 1f       	adc	r25, r25
     f42:	88 0f       	add	r24, r24
     f44:	99 1f       	adc	r25, r25
     f46:	82 0f       	add	r24, r18
     f48:	93 1f       	adc	r25, r19
     f4a:	89 58       	subi	r24, 0x89	; 137
     f4c:	9f 4f       	sbci	r25, 0xFF	; 255
     f4e:	9a 83       	std	Y+2, r25	; 0x02
     f50:	89 83       	std	Y+1, r24	; 0x01
     f52:	e9 81       	ldd	r30, Y+1	; 0x01
     f54:	fa 81       	ldd	r31, Y+2	; 0x02
     f56:	01 80       	ldd	r0, Z+1	; 0x01
     f58:	f2 81       	ldd	r31, Z+2	; 0x02
     f5a:	e0 2d       	mov	r30, r0
     f5c:	82 81       	ldd	r24, Z+2	; 0x02
     f5e:	93 81       	ldd	r25, Z+3	; 0x03
     f60:	e9 81       	ldd	r30, Y+1	; 0x01
     f62:	fa 81       	ldd	r31, Y+2	; 0x02
     f64:	92 83       	std	Z+2, r25	; 0x02
     f66:	81 83       	std	Z+1, r24	; 0x01
     f68:	e9 81       	ldd	r30, Y+1	; 0x01
     f6a:	fa 81       	ldd	r31, Y+2	; 0x02
     f6c:	21 81       	ldd	r18, Z+1	; 0x01
     f6e:	32 81       	ldd	r19, Z+2	; 0x02
     f70:	89 81       	ldd	r24, Y+1	; 0x01
     f72:	9a 81       	ldd	r25, Y+2	; 0x02
     f74:	03 96       	adiw	r24, 0x03	; 3
     f76:	28 17       	cp	r18, r24
     f78:	39 07       	cpc	r19, r25
     f7a:	59 f4       	brne	.+22     	; 0xf92 <vCoRoutineSchedule+0xb0>
     f7c:	e9 81       	ldd	r30, Y+1	; 0x01
     f7e:	fa 81       	ldd	r31, Y+2	; 0x02
     f80:	01 80       	ldd	r0, Z+1	; 0x01
     f82:	f2 81       	ldd	r31, Z+2	; 0x02
     f84:	e0 2d       	mov	r30, r0
     f86:	82 81       	ldd	r24, Z+2	; 0x02
     f88:	93 81       	ldd	r25, Z+3	; 0x03
     f8a:	e9 81       	ldd	r30, Y+1	; 0x01
     f8c:	fa 81       	ldd	r31, Y+2	; 0x02
     f8e:	92 83       	std	Z+2, r25	; 0x02
     f90:	81 83       	std	Z+1, r24	; 0x01
     f92:	e9 81       	ldd	r30, Y+1	; 0x01
     f94:	fa 81       	ldd	r31, Y+2	; 0x02
     f96:	01 80       	ldd	r0, Z+1	; 0x01
     f98:	f2 81       	ldd	r31, Z+2	; 0x02
     f9a:	e0 2d       	mov	r30, r0
     f9c:	86 81       	ldd	r24, Z+6	; 0x06
     f9e:	97 81       	ldd	r25, Z+7	; 0x07
     fa0:	90 93 6f 00 	sts	0x006F, r25
     fa4:	80 93 6e 00 	sts	0x006E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     fa8:	e0 91 6e 00 	lds	r30, 0x006E
     fac:	f0 91 6f 00 	lds	r31, 0x006F
     fb0:	40 81       	ld	r20, Z
     fb2:	51 81       	ldd	r21, Z+1	; 0x01
     fb4:	80 91 6e 00 	lds	r24, 0x006E
     fb8:	90 91 6f 00 	lds	r25, 0x006F
     fbc:	e0 91 6e 00 	lds	r30, 0x006E
     fc0:	f0 91 6f 00 	lds	r31, 0x006F
     fc4:	27 89       	ldd	r18, Z+23	; 0x17
     fc6:	62 2f       	mov	r22, r18
     fc8:	fa 01       	movw	r30, r20
     fca:	09 95       	icall

	return;
}
     fcc:	0f 90       	pop	r0
     fce:	0f 90       	pop	r0
     fd0:	cf 91       	pop	r28
     fd2:	df 91       	pop	r29
     fd4:	08 95       	ret

00000fd6 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     fd6:	df 93       	push	r29
     fd8:	cf 93       	push	r28
     fda:	0f 92       	push	r0
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     fe0:	19 82       	std	Y+1, r1	; 0x01
     fe2:	13 c0       	rjmp	.+38     	; 0x100a <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     fe4:	89 81       	ldd	r24, Y+1	; 0x01
     fe6:	28 2f       	mov	r18, r24
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	c9 01       	movw	r24, r18
     fec:	88 0f       	add	r24, r24
     fee:	99 1f       	adc	r25, r25
     ff0:	88 0f       	add	r24, r24
     ff2:	99 1f       	adc	r25, r25
     ff4:	88 0f       	add	r24, r24
     ff6:	99 1f       	adc	r25, r25
     ff8:	82 0f       	add	r24, r18
     ffa:	93 1f       	adc	r25, r19
     ffc:	89 58       	subi	r24, 0x89	; 137
     ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    1000:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1004:	89 81       	ldd	r24, Y+1	; 0x01
    1006:	8f 5f       	subi	r24, 0xFF	; 255
    1008:	89 83       	std	Y+1, r24	; 0x01
    100a:	89 81       	ldd	r24, Y+1	; 0x01
    100c:	82 30       	cpi	r24, 0x02	; 2
    100e:	50 f3       	brcs	.-44     	; 0xfe4 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1010:	89 e8       	ldi	r24, 0x89	; 137
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1018:	82 e9       	ldi	r24, 0x92	; 146
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1020:	8f e9       	ldi	r24, 0x9F	; 159
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1028:	89 e8       	ldi	r24, 0x89	; 137
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	90 93 9c 00 	sts	0x009C, r25
    1030:	80 93 9b 00 	sts	0x009B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1034:	82 e9       	ldi	r24, 0x92	; 146
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	90 93 9e 00 	sts	0x009E, r25
    103c:	80 93 9d 00 	sts	0x009D, r24
}
    1040:	0f 90       	pop	r0
    1042:	cf 91       	pop	r28
    1044:	df 91       	pop	r29
    1046:	08 95       	ret

00001048 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1048:	df 93       	push	r29
    104a:	cf 93       	push	r28
    104c:	00 d0       	rcall	.+0      	; 0x104e <xCoRoutineRemoveFromEventList+0x6>
    104e:	00 d0       	rcall	.+0      	; 0x1050 <xCoRoutineRemoveFromEventList+0x8>
    1050:	0f 92       	push	r0
    1052:	cd b7       	in	r28, 0x3d	; 61
    1054:	de b7       	in	r29, 0x3e	; 62
    1056:	9d 83       	std	Y+5, r25	; 0x05
    1058:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    105a:	ec 81       	ldd	r30, Y+4	; 0x04
    105c:	fd 81       	ldd	r31, Y+5	; 0x05
    105e:	05 80       	ldd	r0, Z+5	; 0x05
    1060:	f6 81       	ldd	r31, Z+6	; 0x06
    1062:	e0 2d       	mov	r30, r0
    1064:	86 81       	ldd	r24, Z+6	; 0x06
    1066:	97 81       	ldd	r25, Z+7	; 0x07
    1068:	9b 83       	std	Y+3, r25	; 0x03
    106a:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    106c:	8a 81       	ldd	r24, Y+2	; 0x02
    106e:	9b 81       	ldd	r25, Y+3	; 0x03
    1070:	0c 96       	adiw	r24, 0x0c	; 12
    1072:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1076:	8a 81       	ldd	r24, Y+2	; 0x02
    1078:	9b 81       	ldd	r25, Y+3	; 0x03
    107a:	9c 01       	movw	r18, r24
    107c:	24 5f       	subi	r18, 0xF4	; 244
    107e:	3f 4f       	sbci	r19, 0xFF	; 255
    1080:	8f e9       	ldi	r24, 0x9F	; 159
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	b9 01       	movw	r22, r18
    1086:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    108a:	ea 81       	ldd	r30, Y+2	; 0x02
    108c:	fb 81       	ldd	r31, Y+3	; 0x03
    108e:	96 89       	ldd	r25, Z+22	; 0x16
    1090:	e0 91 6e 00 	lds	r30, 0x006E
    1094:	f0 91 6f 00 	lds	r31, 0x006F
    1098:	86 89       	ldd	r24, Z+22	; 0x16
    109a:	98 17       	cp	r25, r24
    109c:	18 f0       	brcs	.+6      	; 0x10a4 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    109e:	81 e0       	ldi	r24, 0x01	; 1
    10a0:	89 83       	std	Y+1, r24	; 0x01
    10a2:	01 c0       	rjmp	.+2      	; 0x10a6 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    10a4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    10a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    10a8:	0f 90       	pop	r0
    10aa:	0f 90       	pop	r0
    10ac:	0f 90       	pop	r0
    10ae:	0f 90       	pop	r0
    10b0:	0f 90       	pop	r0
    10b2:	cf 91       	pop	r28
    10b4:	df 91       	pop	r29
    10b6:	08 95       	ret

000010b8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10b8:	df 93       	push	r29
    10ba:	cf 93       	push	r28
    10bc:	00 d0       	rcall	.+0      	; 0x10be <pvPortMalloc+0x6>
    10be:	00 d0       	rcall	.+0      	; 0x10c0 <pvPortMalloc+0x8>
    10c0:	cd b7       	in	r28, 0x3d	; 61
    10c2:	de b7       	in	r29, 0x3e	; 62
    10c4:	9c 83       	std	Y+4, r25	; 0x04
    10c6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    10c8:	1a 82       	std	Y+2, r1	; 0x02
    10ca:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    10cc:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    10d0:	80 91 a8 00 	lds	r24, 0x00A8
    10d4:	90 91 a9 00 	lds	r25, 0x00A9
    10d8:	2b 81       	ldd	r18, Y+3	; 0x03
    10da:	3c 81       	ldd	r19, Y+4	; 0x04
    10dc:	82 0f       	add	r24, r18
    10de:	93 1f       	adc	r25, r19
    10e0:	22 e0       	ldi	r18, 0x02	; 2
    10e2:	88 35       	cpi	r24, 0x58	; 88
    10e4:	92 07       	cpc	r25, r18
    10e6:	18 f5       	brcc	.+70     	; 0x112e <pvPortMalloc+0x76>
    10e8:	20 91 a8 00 	lds	r18, 0x00A8
    10ec:	30 91 a9 00 	lds	r19, 0x00A9
    10f0:	8b 81       	ldd	r24, Y+3	; 0x03
    10f2:	9c 81       	ldd	r25, Y+4	; 0x04
    10f4:	28 0f       	add	r18, r24
    10f6:	39 1f       	adc	r19, r25
    10f8:	80 91 a8 00 	lds	r24, 0x00A8
    10fc:	90 91 a9 00 	lds	r25, 0x00A9
    1100:	82 17       	cp	r24, r18
    1102:	93 07       	cpc	r25, r19
    1104:	a0 f4       	brcc	.+40     	; 0x112e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1106:	80 91 a8 00 	lds	r24, 0x00A8
    110a:	90 91 a9 00 	lds	r25, 0x00A9
    110e:	86 55       	subi	r24, 0x56	; 86
    1110:	9f 4f       	sbci	r25, 0xFF	; 255
    1112:	9a 83       	std	Y+2, r25	; 0x02
    1114:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    1116:	20 91 a8 00 	lds	r18, 0x00A8
    111a:	30 91 a9 00 	lds	r19, 0x00A9
    111e:	8b 81       	ldd	r24, Y+3	; 0x03
    1120:	9c 81       	ldd	r25, Y+4	; 0x04
    1122:	82 0f       	add	r24, r18
    1124:	93 1f       	adc	r25, r19
    1126:	90 93 a9 00 	sts	0x00A9, r25
    112a:	80 93 a8 00 	sts	0x00A8, r24
		}	
	}
	xTaskResumeAll();
    112e:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1132:	89 81       	ldd	r24, Y+1	; 0x01
    1134:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1136:	0f 90       	pop	r0
    1138:	0f 90       	pop	r0
    113a:	0f 90       	pop	r0
    113c:	0f 90       	pop	r0
    113e:	cf 91       	pop	r28
    1140:	df 91       	pop	r29
    1142:	08 95       	ret

00001144 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1144:	df 93       	push	r29
    1146:	cf 93       	push	r28
    1148:	00 d0       	rcall	.+0      	; 0x114a <vPortFree+0x6>
    114a:	cd b7       	in	r28, 0x3d	; 61
    114c:	de b7       	in	r29, 0x3e	; 62
    114e:	9a 83       	std	Y+2, r25	; 0x02
    1150:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1152:	0f 90       	pop	r0
    1154:	0f 90       	pop	r0
    1156:	cf 91       	pop	r28
    1158:	df 91       	pop	r29
    115a:	08 95       	ret

0000115c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    115c:	df 93       	push	r29
    115e:	cf 93       	push	r28
    1160:	cd b7       	in	r28, 0x3d	; 61
    1162:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1164:	10 92 a9 00 	sts	0x00A9, r1
    1168:	10 92 a8 00 	sts	0x00A8, r1
}
    116c:	cf 91       	pop	r28
    116e:	df 91       	pop	r29
    1170:	08 95       	ret

00001172 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1172:	df 93       	push	r29
    1174:	cf 93       	push	r28
    1176:	cd b7       	in	r28, 0x3d	; 61
    1178:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    117a:	20 91 a8 00 	lds	r18, 0x00A8
    117e:	30 91 a9 00 	lds	r19, 0x00A9
    1182:	88 e5       	ldi	r24, 0x58	; 88
    1184:	92 e0       	ldi	r25, 0x02	; 2
    1186:	82 1b       	sub	r24, r18
    1188:	93 0b       	sbc	r25, r19
}
    118a:	cf 91       	pop	r28
    118c:	df 91       	pop	r29
    118e:	08 95       	ret

00001190 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1190:	df 93       	push	r29
    1192:	cf 93       	push	r28
    1194:	00 d0       	rcall	.+0      	; 0x1196 <vListInitialise+0x6>
    1196:	cd b7       	in	r28, 0x3d	; 61
    1198:	de b7       	in	r29, 0x3e	; 62
    119a:	9a 83       	std	Y+2, r25	; 0x02
    119c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    119e:	89 81       	ldd	r24, Y+1	; 0x01
    11a0:	9a 81       	ldd	r25, Y+2	; 0x02
    11a2:	03 96       	adiw	r24, 0x03	; 3
    11a4:	e9 81       	ldd	r30, Y+1	; 0x01
    11a6:	fa 81       	ldd	r31, Y+2	; 0x02
    11a8:	92 83       	std	Z+2, r25	; 0x02
    11aa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    11ac:	e9 81       	ldd	r30, Y+1	; 0x01
    11ae:	fa 81       	ldd	r31, Y+2	; 0x02
    11b0:	8f ef       	ldi	r24, 0xFF	; 255
    11b2:	9f ef       	ldi	r25, 0xFF	; 255
    11b4:	94 83       	std	Z+4, r25	; 0x04
    11b6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    11b8:	89 81       	ldd	r24, Y+1	; 0x01
    11ba:	9a 81       	ldd	r25, Y+2	; 0x02
    11bc:	03 96       	adiw	r24, 0x03	; 3
    11be:	e9 81       	ldd	r30, Y+1	; 0x01
    11c0:	fa 81       	ldd	r31, Y+2	; 0x02
    11c2:	96 83       	std	Z+6, r25	; 0x06
    11c4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    11c6:	89 81       	ldd	r24, Y+1	; 0x01
    11c8:	9a 81       	ldd	r25, Y+2	; 0x02
    11ca:	03 96       	adiw	r24, 0x03	; 3
    11cc:	e9 81       	ldd	r30, Y+1	; 0x01
    11ce:	fa 81       	ldd	r31, Y+2	; 0x02
    11d0:	90 87       	std	Z+8, r25	; 0x08
    11d2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    11d4:	e9 81       	ldd	r30, Y+1	; 0x01
    11d6:	fa 81       	ldd	r31, Y+2	; 0x02
    11d8:	10 82       	st	Z, r1
}
    11da:	0f 90       	pop	r0
    11dc:	0f 90       	pop	r0
    11de:	cf 91       	pop	r28
    11e0:	df 91       	pop	r29
    11e2:	08 95       	ret

000011e4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    11e4:	df 93       	push	r29
    11e6:	cf 93       	push	r28
    11e8:	00 d0       	rcall	.+0      	; 0x11ea <vListInitialiseItem+0x6>
    11ea:	cd b7       	in	r28, 0x3d	; 61
    11ec:	de b7       	in	r29, 0x3e	; 62
    11ee:	9a 83       	std	Y+2, r25	; 0x02
    11f0:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    11f2:	e9 81       	ldd	r30, Y+1	; 0x01
    11f4:	fa 81       	ldd	r31, Y+2	; 0x02
    11f6:	11 86       	std	Z+9, r1	; 0x09
    11f8:	10 86       	std	Z+8, r1	; 0x08
}
    11fa:	0f 90       	pop	r0
    11fc:	0f 90       	pop	r0
    11fe:	cf 91       	pop	r28
    1200:	df 91       	pop	r29
    1202:	08 95       	ret

00001204 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1204:	df 93       	push	r29
    1206:	cf 93       	push	r28
    1208:	00 d0       	rcall	.+0      	; 0x120a <vListInsertEnd+0x6>
    120a:	00 d0       	rcall	.+0      	; 0x120c <vListInsertEnd+0x8>
    120c:	00 d0       	rcall	.+0      	; 0x120e <vListInsertEnd+0xa>
    120e:	cd b7       	in	r28, 0x3d	; 61
    1210:	de b7       	in	r29, 0x3e	; 62
    1212:	9c 83       	std	Y+4, r25	; 0x04
    1214:	8b 83       	std	Y+3, r24	; 0x03
    1216:	7e 83       	std	Y+6, r23	; 0x06
    1218:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    121a:	eb 81       	ldd	r30, Y+3	; 0x03
    121c:	fc 81       	ldd	r31, Y+4	; 0x04
    121e:	81 81       	ldd	r24, Z+1	; 0x01
    1220:	92 81       	ldd	r25, Z+2	; 0x02
    1222:	9a 83       	std	Y+2, r25	; 0x02
    1224:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    1226:	e9 81       	ldd	r30, Y+1	; 0x01
    1228:	fa 81       	ldd	r31, Y+2	; 0x02
    122a:	82 81       	ldd	r24, Z+2	; 0x02
    122c:	93 81       	ldd	r25, Z+3	; 0x03
    122e:	ed 81       	ldd	r30, Y+5	; 0x05
    1230:	fe 81       	ldd	r31, Y+6	; 0x06
    1232:	93 83       	std	Z+3, r25	; 0x03
    1234:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1236:	eb 81       	ldd	r30, Y+3	; 0x03
    1238:	fc 81       	ldd	r31, Y+4	; 0x04
    123a:	81 81       	ldd	r24, Z+1	; 0x01
    123c:	92 81       	ldd	r25, Z+2	; 0x02
    123e:	ed 81       	ldd	r30, Y+5	; 0x05
    1240:	fe 81       	ldd	r31, Y+6	; 0x06
    1242:	95 83       	std	Z+5, r25	; 0x05
    1244:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1246:	e9 81       	ldd	r30, Y+1	; 0x01
    1248:	fa 81       	ldd	r31, Y+2	; 0x02
    124a:	02 80       	ldd	r0, Z+2	; 0x02
    124c:	f3 81       	ldd	r31, Z+3	; 0x03
    124e:	e0 2d       	mov	r30, r0
    1250:	8d 81       	ldd	r24, Y+5	; 0x05
    1252:	9e 81       	ldd	r25, Y+6	; 0x06
    1254:	95 83       	std	Z+5, r25	; 0x05
    1256:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1258:	8d 81       	ldd	r24, Y+5	; 0x05
    125a:	9e 81       	ldd	r25, Y+6	; 0x06
    125c:	e9 81       	ldd	r30, Y+1	; 0x01
    125e:	fa 81       	ldd	r31, Y+2	; 0x02
    1260:	93 83       	std	Z+3, r25	; 0x03
    1262:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1264:	8d 81       	ldd	r24, Y+5	; 0x05
    1266:	9e 81       	ldd	r25, Y+6	; 0x06
    1268:	eb 81       	ldd	r30, Y+3	; 0x03
    126a:	fc 81       	ldd	r31, Y+4	; 0x04
    126c:	92 83       	std	Z+2, r25	; 0x02
    126e:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1270:	ed 81       	ldd	r30, Y+5	; 0x05
    1272:	fe 81       	ldd	r31, Y+6	; 0x06
    1274:	8b 81       	ldd	r24, Y+3	; 0x03
    1276:	9c 81       	ldd	r25, Y+4	; 0x04
    1278:	91 87       	std	Z+9, r25	; 0x09
    127a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    127c:	eb 81       	ldd	r30, Y+3	; 0x03
    127e:	fc 81       	ldd	r31, Y+4	; 0x04
    1280:	80 81       	ld	r24, Z
    1282:	8f 5f       	subi	r24, 0xFF	; 255
    1284:	eb 81       	ldd	r30, Y+3	; 0x03
    1286:	fc 81       	ldd	r31, Y+4	; 0x04
    1288:	80 83       	st	Z, r24
}
    128a:	26 96       	adiw	r28, 0x06	; 6
    128c:	0f b6       	in	r0, 0x3f	; 63
    128e:	f8 94       	cli
    1290:	de bf       	out	0x3e, r29	; 62
    1292:	0f be       	out	0x3f, r0	; 63
    1294:	cd bf       	out	0x3d, r28	; 61
    1296:	cf 91       	pop	r28
    1298:	df 91       	pop	r29
    129a:	08 95       	ret

0000129c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    129c:	df 93       	push	r29
    129e:	cf 93       	push	r28
    12a0:	cd b7       	in	r28, 0x3d	; 61
    12a2:	de b7       	in	r29, 0x3e	; 62
    12a4:	28 97       	sbiw	r28, 0x08	; 8
    12a6:	0f b6       	in	r0, 0x3f	; 63
    12a8:	f8 94       	cli
    12aa:	de bf       	out	0x3e, r29	; 62
    12ac:	0f be       	out	0x3f, r0	; 63
    12ae:	cd bf       	out	0x3d, r28	; 61
    12b0:	9e 83       	std	Y+6, r25	; 0x06
    12b2:	8d 83       	std	Y+5, r24	; 0x05
    12b4:	78 87       	std	Y+8, r23	; 0x08
    12b6:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    12b8:	ef 81       	ldd	r30, Y+7	; 0x07
    12ba:	f8 85       	ldd	r31, Y+8	; 0x08
    12bc:	80 81       	ld	r24, Z
    12be:	91 81       	ldd	r25, Z+1	; 0x01
    12c0:	9a 83       	std	Y+2, r25	; 0x02
    12c2:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    12c4:	89 81       	ldd	r24, Y+1	; 0x01
    12c6:	9a 81       	ldd	r25, Y+2	; 0x02
    12c8:	2f ef       	ldi	r18, 0xFF	; 255
    12ca:	8f 3f       	cpi	r24, 0xFF	; 255
    12cc:	92 07       	cpc	r25, r18
    12ce:	39 f4       	brne	.+14     	; 0x12de <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    12d0:	ed 81       	ldd	r30, Y+5	; 0x05
    12d2:	fe 81       	ldd	r31, Y+6	; 0x06
    12d4:	87 81       	ldd	r24, Z+7	; 0x07
    12d6:	90 85       	ldd	r25, Z+8	; 0x08
    12d8:	9c 83       	std	Y+4, r25	; 0x04
    12da:	8b 83       	std	Y+3, r24	; 0x03
    12dc:	18 c0       	rjmp	.+48     	; 0x130e <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    12de:	8d 81       	ldd	r24, Y+5	; 0x05
    12e0:	9e 81       	ldd	r25, Y+6	; 0x06
    12e2:	03 96       	adiw	r24, 0x03	; 3
    12e4:	9c 83       	std	Y+4, r25	; 0x04
    12e6:	8b 83       	std	Y+3, r24	; 0x03
    12e8:	06 c0       	rjmp	.+12     	; 0x12f6 <vListInsert+0x5a>
    12ea:	eb 81       	ldd	r30, Y+3	; 0x03
    12ec:	fc 81       	ldd	r31, Y+4	; 0x04
    12ee:	82 81       	ldd	r24, Z+2	; 0x02
    12f0:	93 81       	ldd	r25, Z+3	; 0x03
    12f2:	9c 83       	std	Y+4, r25	; 0x04
    12f4:	8b 83       	std	Y+3, r24	; 0x03
    12f6:	eb 81       	ldd	r30, Y+3	; 0x03
    12f8:	fc 81       	ldd	r31, Y+4	; 0x04
    12fa:	02 80       	ldd	r0, Z+2	; 0x02
    12fc:	f3 81       	ldd	r31, Z+3	; 0x03
    12fe:	e0 2d       	mov	r30, r0
    1300:	20 81       	ld	r18, Z
    1302:	31 81       	ldd	r19, Z+1	; 0x01
    1304:	89 81       	ldd	r24, Y+1	; 0x01
    1306:	9a 81       	ldd	r25, Y+2	; 0x02
    1308:	82 17       	cp	r24, r18
    130a:	93 07       	cpc	r25, r19
    130c:	70 f7       	brcc	.-36     	; 0x12ea <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    130e:	eb 81       	ldd	r30, Y+3	; 0x03
    1310:	fc 81       	ldd	r31, Y+4	; 0x04
    1312:	82 81       	ldd	r24, Z+2	; 0x02
    1314:	93 81       	ldd	r25, Z+3	; 0x03
    1316:	ef 81       	ldd	r30, Y+7	; 0x07
    1318:	f8 85       	ldd	r31, Y+8	; 0x08
    131a:	93 83       	std	Z+3, r25	; 0x03
    131c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    131e:	ef 81       	ldd	r30, Y+7	; 0x07
    1320:	f8 85       	ldd	r31, Y+8	; 0x08
    1322:	02 80       	ldd	r0, Z+2	; 0x02
    1324:	f3 81       	ldd	r31, Z+3	; 0x03
    1326:	e0 2d       	mov	r30, r0
    1328:	8f 81       	ldd	r24, Y+7	; 0x07
    132a:	98 85       	ldd	r25, Y+8	; 0x08
    132c:	95 83       	std	Z+5, r25	; 0x05
    132e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1330:	ef 81       	ldd	r30, Y+7	; 0x07
    1332:	f8 85       	ldd	r31, Y+8	; 0x08
    1334:	8b 81       	ldd	r24, Y+3	; 0x03
    1336:	9c 81       	ldd	r25, Y+4	; 0x04
    1338:	95 83       	std	Z+5, r25	; 0x05
    133a:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    133c:	8f 81       	ldd	r24, Y+7	; 0x07
    133e:	98 85       	ldd	r25, Y+8	; 0x08
    1340:	eb 81       	ldd	r30, Y+3	; 0x03
    1342:	fc 81       	ldd	r31, Y+4	; 0x04
    1344:	93 83       	std	Z+3, r25	; 0x03
    1346:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1348:	ef 81       	ldd	r30, Y+7	; 0x07
    134a:	f8 85       	ldd	r31, Y+8	; 0x08
    134c:	8d 81       	ldd	r24, Y+5	; 0x05
    134e:	9e 81       	ldd	r25, Y+6	; 0x06
    1350:	91 87       	std	Z+9, r25	; 0x09
    1352:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1354:	ed 81       	ldd	r30, Y+5	; 0x05
    1356:	fe 81       	ldd	r31, Y+6	; 0x06
    1358:	80 81       	ld	r24, Z
    135a:	8f 5f       	subi	r24, 0xFF	; 255
    135c:	ed 81       	ldd	r30, Y+5	; 0x05
    135e:	fe 81       	ldd	r31, Y+6	; 0x06
    1360:	80 83       	st	Z, r24
}
    1362:	28 96       	adiw	r28, 0x08	; 8
    1364:	0f b6       	in	r0, 0x3f	; 63
    1366:	f8 94       	cli
    1368:	de bf       	out	0x3e, r29	; 62
    136a:	0f be       	out	0x3f, r0	; 63
    136c:	cd bf       	out	0x3d, r28	; 61
    136e:	cf 91       	pop	r28
    1370:	df 91       	pop	r29
    1372:	08 95       	ret

00001374 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1374:	df 93       	push	r29
    1376:	cf 93       	push	r28
    1378:	00 d0       	rcall	.+0      	; 0x137a <vListRemove+0x6>
    137a:	00 d0       	rcall	.+0      	; 0x137c <vListRemove+0x8>
    137c:	cd b7       	in	r28, 0x3d	; 61
    137e:	de b7       	in	r29, 0x3e	; 62
    1380:	9c 83       	std	Y+4, r25	; 0x04
    1382:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1384:	eb 81       	ldd	r30, Y+3	; 0x03
    1386:	fc 81       	ldd	r31, Y+4	; 0x04
    1388:	a2 81       	ldd	r26, Z+2	; 0x02
    138a:	b3 81       	ldd	r27, Z+3	; 0x03
    138c:	eb 81       	ldd	r30, Y+3	; 0x03
    138e:	fc 81       	ldd	r31, Y+4	; 0x04
    1390:	84 81       	ldd	r24, Z+4	; 0x04
    1392:	95 81       	ldd	r25, Z+5	; 0x05
    1394:	15 96       	adiw	r26, 0x05	; 5
    1396:	9c 93       	st	X, r25
    1398:	8e 93       	st	-X, r24
    139a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    139c:	eb 81       	ldd	r30, Y+3	; 0x03
    139e:	fc 81       	ldd	r31, Y+4	; 0x04
    13a0:	a4 81       	ldd	r26, Z+4	; 0x04
    13a2:	b5 81       	ldd	r27, Z+5	; 0x05
    13a4:	eb 81       	ldd	r30, Y+3	; 0x03
    13a6:	fc 81       	ldd	r31, Y+4	; 0x04
    13a8:	82 81       	ldd	r24, Z+2	; 0x02
    13aa:	93 81       	ldd	r25, Z+3	; 0x03
    13ac:	13 96       	adiw	r26, 0x03	; 3
    13ae:	9c 93       	st	X, r25
    13b0:	8e 93       	st	-X, r24
    13b2:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    13b4:	eb 81       	ldd	r30, Y+3	; 0x03
    13b6:	fc 81       	ldd	r31, Y+4	; 0x04
    13b8:	80 85       	ldd	r24, Z+8	; 0x08
    13ba:	91 85       	ldd	r25, Z+9	; 0x09
    13bc:	9a 83       	std	Y+2, r25	; 0x02
    13be:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    13c0:	e9 81       	ldd	r30, Y+1	; 0x01
    13c2:	fa 81       	ldd	r31, Y+2	; 0x02
    13c4:	21 81       	ldd	r18, Z+1	; 0x01
    13c6:	32 81       	ldd	r19, Z+2	; 0x02
    13c8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ca:	9c 81       	ldd	r25, Y+4	; 0x04
    13cc:	28 17       	cp	r18, r24
    13ce:	39 07       	cpc	r19, r25
    13d0:	41 f4       	brne	.+16     	; 0x13e2 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    13d2:	eb 81       	ldd	r30, Y+3	; 0x03
    13d4:	fc 81       	ldd	r31, Y+4	; 0x04
    13d6:	84 81       	ldd	r24, Z+4	; 0x04
    13d8:	95 81       	ldd	r25, Z+5	; 0x05
    13da:	e9 81       	ldd	r30, Y+1	; 0x01
    13dc:	fa 81       	ldd	r31, Y+2	; 0x02
    13de:	92 83       	std	Z+2, r25	; 0x02
    13e0:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    13e2:	eb 81       	ldd	r30, Y+3	; 0x03
    13e4:	fc 81       	ldd	r31, Y+4	; 0x04
    13e6:	11 86       	std	Z+9, r1	; 0x09
    13e8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    13ea:	e9 81       	ldd	r30, Y+1	; 0x01
    13ec:	fa 81       	ldd	r31, Y+2	; 0x02
    13ee:	80 81       	ld	r24, Z
    13f0:	81 50       	subi	r24, 0x01	; 1
    13f2:	e9 81       	ldd	r30, Y+1	; 0x01
    13f4:	fa 81       	ldd	r31, Y+2	; 0x02
    13f6:	80 83       	st	Z, r24
}
    13f8:	0f 90       	pop	r0
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	cf 91       	pop	r28
    1402:	df 91       	pop	r29
    1404:	08 95       	ret

00001406 <led1>:
xTaskHandle led1Handle=NULL;
xTaskHandle led2Handle=NULL;
xTaskHandle led3Handle=NULL;

void led1(void *ptr)
{
    1406:	df 93       	push	r29
    1408:	cf 93       	push	r28
    140a:	00 d0       	rcall	.+0      	; 0x140c <led1+0x6>
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	9a 83       	std	Y+2, r25	; 0x02
    1412:	89 83       	std	Y+1, r24	; 0x01
	static u8 i=0;
	while(1)
	{
		if(i==0)
    1414:	80 91 08 03 	lds	r24, 0x0308
    1418:	88 23       	and	r24, r24
    141a:	49 f4       	brne	.+18     	; 0x142e <led1+0x28>
		{
			DIO_SetPinValue(0,PIN_0,HIGH);
    141c:	80 e0       	ldi	r24, 0x00	; 0
    141e:	60 e0       	ldi	r22, 0x00	; 0
    1420:	41 e0       	ldi	r20, 0x01	; 1
    1422:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=1;
    1426:	81 e0       	ldi	r24, 0x01	; 1
    1428:	80 93 08 03 	sts	0x0308, r24
    142c:	07 c0       	rjmp	.+14     	; 0x143c <led1+0x36>
		}
		else
		{
			DIO_SetPinValue(0,PIN_0,LOW);
    142e:	80 e0       	ldi	r24, 0x00	; 0
    1430:	60 e0       	ldi	r22, 0x00	; 0
    1432:	40 e0       	ldi	r20, 0x00	; 0
    1434:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=0;
    1438:	10 92 08 03 	sts	0x0308, r1
		}
		vTaskDelay(1000);
    143c:	88 ee       	ldi	r24, 0xE8	; 232
    143e:	93 e0       	ldi	r25, 0x03	; 3
    1440:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskDelay>
    1444:	e7 cf       	rjmp	.-50     	; 0x1414 <led1+0xe>

00001446 <led2>:
	}
}

void led2(void *ptr)
{
    1446:	df 93       	push	r29
    1448:	cf 93       	push	r28
    144a:	00 d0       	rcall	.+0      	; 0x144c <led2+0x6>
    144c:	cd b7       	in	r28, 0x3d	; 61
    144e:	de b7       	in	r29, 0x3e	; 62
    1450:	9a 83       	std	Y+2, r25	; 0x02
    1452:	89 83       	std	Y+1, r24	; 0x01
	static u8 i=0;
	while(1)
	{
		if(i==0)
    1454:	80 91 09 03 	lds	r24, 0x0309
    1458:	88 23       	and	r24, r24
    145a:	49 f4       	brne	.+18     	; 0x146e <led2+0x28>
		{
			DIO_SetPinValue(0,PIN_1,HIGH);
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	61 e0       	ldi	r22, 0x01	; 1
    1460:	41 e0       	ldi	r20, 0x01	; 1
    1462:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=1;
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	80 93 09 03 	sts	0x0309, r24
    146c:	07 c0       	rjmp	.+14     	; 0x147c <led2+0x36>
		}
		else
		{
			DIO_SetPinValue(0,PIN_1,LOW);
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	61 e0       	ldi	r22, 0x01	; 1
    1472:	40 e0       	ldi	r20, 0x00	; 0
    1474:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=0;
    1478:	10 92 09 03 	sts	0x0309, r1
		}
		vTaskDelay(3000);
    147c:	88 eb       	ldi	r24, 0xB8	; 184
    147e:	9b e0       	ldi	r25, 0x0B	; 11
    1480:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskDelay>
    1484:	e7 cf       	rjmp	.-50     	; 0x1454 <led2+0xe>

00001486 <led3>:
	}
}

void led3(void *ptr)
{
    1486:	df 93       	push	r29
    1488:	cf 93       	push	r28
    148a:	00 d0       	rcall	.+0      	; 0x148c <led3+0x6>
    148c:	cd b7       	in	r28, 0x3d	; 61
    148e:	de b7       	in	r29, 0x3e	; 62
    1490:	9a 83       	std	Y+2, r25	; 0x02
    1492:	89 83       	std	Y+1, r24	; 0x01
	static u8 i=0;
	while(1)
	{
		if(i==0)
    1494:	80 91 0a 03 	lds	r24, 0x030A
    1498:	88 23       	and	r24, r24
    149a:	49 f4       	brne	.+18     	; 0x14ae <led3+0x28>
		{
			DIO_SetPinValue(0,PIN_2,HIGH);
    149c:	80 e0       	ldi	r24, 0x00	; 0
    149e:	62 e0       	ldi	r22, 0x02	; 2
    14a0:	41 e0       	ldi	r20, 0x01	; 1
    14a2:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=1;
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	80 93 0a 03 	sts	0x030A, r24
    14ac:	07 c0       	rjmp	.+14     	; 0x14bc <led3+0x36>
		}
		else
		{
			DIO_SetPinValue(0,PIN_2,LOW);
    14ae:	80 e0       	ldi	r24, 0x00	; 0
    14b0:	62 e0       	ldi	r22, 0x02	; 2
    14b2:	40 e0       	ldi	r20, 0x00	; 0
    14b4:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=0;
    14b8:	10 92 0a 03 	sts	0x030A, r1
		}
		vTaskDelay(5000);
    14bc:	88 e8       	ldi	r24, 0x88	; 136
    14be:	93 e1       	ldi	r25, 0x13	; 19
    14c0:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskDelay>
    14c4:	e7 cf       	rjmp	.-50     	; 0x1494 <led3+0xe>

000014c6 <main>:
}

void func(void);

void main(void)
{
    14c6:	af 92       	push	r10
    14c8:	bf 92       	push	r11
    14ca:	cf 92       	push	r12
    14cc:	df 92       	push	r13
    14ce:	ef 92       	push	r14
    14d0:	ff 92       	push	r15
    14d2:	0f 93       	push	r16
    14d4:	df 93       	push	r29
    14d6:	cf 93       	push	r28
    14d8:	cd b7       	in	r28, 0x3d	; 61
    14da:	de b7       	in	r29, 0x3e	; 62
	//PORTA for LEDs
	DIO_SetPortDirection(0,PortOut);
    14dc:	80 e0       	ldi	r24, 0x00	; 0
    14de:	6f ef       	ldi	r22, 0xFF	; 255
    14e0:	0e 94 2a 03 	call	0x654	; 0x654 <DIO_SetPortDirection>

	//Set Button -> Pullup
	DIO_SetPinDirection(3,PIN_2,Input);
    14e4:	83 e0       	ldi	r24, 0x03	; 3
    14e6:	62 e0       	ldi	r22, 0x02	; 2
    14e8:	40 e0       	ldi	r20, 0x00	; 0
    14ea:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SetPinDirection>
	DIO_SetPinValue(3,PIN_2,HIGH);
    14ee:	83 e0       	ldi	r24, 0x03	; 3
    14f0:	62 e0       	ldi	r22, 0x02	; 2
    14f2:	41 e0       	ldi	r20, 0x01	; 1
    14f4:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>

	//Interrupt
	EXTI_SetTriggerMode();
    14f8:	0e 94 ac 03 	call	0x758	; 0x758 <EXTI_SetTriggerMode>
	EXTI0_CallBackFunc(func);
    14fc:	80 ec       	ldi	r24, 0xC0	; 192
    14fe:	9a e0       	ldi	r25, 0x0A	; 10
    1500:	0e 94 ab 04 	call	0x956	; 0x956 <EXTI0_CallBackFunc>
	EXTI_Enable(EXTI0);
    1504:	80 e0       	ldi	r24, 0x00	; 0
    1506:	0e 94 3d 04 	call	0x87a	; 0x87a <EXTI_Enable>
	GIE_Enable();
    150a:	0e 94 68 05 	call	0xad0	; 0xad0 <GIE_Enable>

	//Tasks
	xTaskCreate(led1,NULL,configMINIMAL_STACK_SIZE,NULL,0,&led1Handle);
    150e:	83 e0       	ldi	r24, 0x03	; 3
    1510:	9a e0       	ldi	r25, 0x0A	; 10
    1512:	e2 e0       	ldi	r30, 0x02	; 2
    1514:	f3 e0       	ldi	r31, 0x03	; 3
    1516:	60 e0       	ldi	r22, 0x00	; 0
    1518:	70 e0       	ldi	r23, 0x00	; 0
    151a:	44 e6       	ldi	r20, 0x64	; 100
    151c:	50 e0       	ldi	r21, 0x00	; 0
    151e:	20 e0       	ldi	r18, 0x00	; 0
    1520:	30 e0       	ldi	r19, 0x00	; 0
    1522:	00 e0       	ldi	r16, 0x00	; 0
    1524:	7f 01       	movw	r14, r30
    1526:	cc 24       	eor	r12, r12
    1528:	dd 24       	eor	r13, r13
    152a:	aa 24       	eor	r10, r10
    152c:	bb 24       	eor	r11, r11
    152e:	0e 94 48 12 	call	0x2490	; 0x2490 <xTaskGenericCreate>
	xTaskCreate(led2,NULL,configMINIMAL_STACK_SIZE,NULL,1,&led2Handle);
    1532:	83 e2       	ldi	r24, 0x23	; 35
    1534:	9a e0       	ldi	r25, 0x0A	; 10
    1536:	e4 e0       	ldi	r30, 0x04	; 4
    1538:	f3 e0       	ldi	r31, 0x03	; 3
    153a:	60 e0       	ldi	r22, 0x00	; 0
    153c:	70 e0       	ldi	r23, 0x00	; 0
    153e:	44 e6       	ldi	r20, 0x64	; 100
    1540:	50 e0       	ldi	r21, 0x00	; 0
    1542:	20 e0       	ldi	r18, 0x00	; 0
    1544:	30 e0       	ldi	r19, 0x00	; 0
    1546:	01 e0       	ldi	r16, 0x01	; 1
    1548:	7f 01       	movw	r14, r30
    154a:	cc 24       	eor	r12, r12
    154c:	dd 24       	eor	r13, r13
    154e:	aa 24       	eor	r10, r10
    1550:	bb 24       	eor	r11, r11
    1552:	0e 94 48 12 	call	0x2490	; 0x2490 <xTaskGenericCreate>
	xTaskCreate(led3,NULL,configMINIMAL_STACK_SIZE,NULL,2,&led3Handle);
    1556:	83 e4       	ldi	r24, 0x43	; 67
    1558:	9a e0       	ldi	r25, 0x0A	; 10
    155a:	e6 e0       	ldi	r30, 0x06	; 6
    155c:	f3 e0       	ldi	r31, 0x03	; 3
    155e:	60 e0       	ldi	r22, 0x00	; 0
    1560:	70 e0       	ldi	r23, 0x00	; 0
    1562:	44 e6       	ldi	r20, 0x64	; 100
    1564:	50 e0       	ldi	r21, 0x00	; 0
    1566:	20 e0       	ldi	r18, 0x00	; 0
    1568:	30 e0       	ldi	r19, 0x00	; 0
    156a:	02 e0       	ldi	r16, 0x02	; 2
    156c:	7f 01       	movw	r14, r30
    156e:	cc 24       	eor	r12, r12
    1570:	dd 24       	eor	r13, r13
    1572:	aa 24       	eor	r10, r10
    1574:	bb 24       	eor	r11, r11
    1576:	0e 94 48 12 	call	0x2490	; 0x2490 <xTaskGenericCreate>

	vTaskStartScheduler();
    157a:	0e 94 a0 15 	call	0x2b40	; 0x2b40 <vTaskStartScheduler>
    157e:	ff cf       	rjmp	.-2      	; 0x157e <main+0xb8>

00001580 <func>:

	}
}

void func(void)
{
    1580:	df 93       	push	r29
    1582:	cf 93       	push	r28
    1584:	cd b7       	in	r28, 0x3d	; 61
    1586:	de b7       	in	r29, 0x3e	; 62
	static u8 flag = 0;
	if (flag ==0)
    1588:	80 91 0b 03 	lds	r24, 0x030B
    158c:	88 23       	and	r24, r24
    158e:	b1 f4       	brne	.+44     	; 0x15bc <func+0x3c>
	{
		vTaskSuspend(led1Handle);
    1590:	80 91 02 03 	lds	r24, 0x0302
    1594:	90 91 03 03 	lds	r25, 0x0303
    1598:	0e 94 41 14 	call	0x2882	; 0x2882 <vTaskSuspend>
		vTaskSuspend(led2Handle);
    159c:	80 91 04 03 	lds	r24, 0x0304
    15a0:	90 91 05 03 	lds	r25, 0x0305
    15a4:	0e 94 41 14 	call	0x2882	; 0x2882 <vTaskSuspend>
		vTaskSuspend(led3Handle);
    15a8:	80 91 06 03 	lds	r24, 0x0306
    15ac:	90 91 07 03 	lds	r25, 0x0307
    15b0:	0e 94 41 14 	call	0x2882	; 0x2882 <vTaskSuspend>
		flag=1;
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	80 93 0b 03 	sts	0x030B, r24
    15ba:	14 c0       	rjmp	.+40     	; 0x15e4 <func+0x64>
	}
	else
	{
		vTaskResume(led1Handle);
    15bc:	80 91 02 03 	lds	r24, 0x0302
    15c0:	90 91 03 03 	lds	r25, 0x0303
    15c4:	0e 94 d7 14 	call	0x29ae	; 0x29ae <vTaskResume>
		vTaskResume(led2Handle);
    15c8:	80 91 04 03 	lds	r24, 0x0304
    15cc:	90 91 05 03 	lds	r25, 0x0305
    15d0:	0e 94 d7 14 	call	0x29ae	; 0x29ae <vTaskResume>
		vTaskResume(led3Handle);
    15d4:	80 91 06 03 	lds	r24, 0x0306
    15d8:	90 91 07 03 	lds	r25, 0x0307
    15dc:	0e 94 d7 14 	call	0x29ae	; 0x29ae <vTaskResume>
		flag=0;
    15e0:	10 92 0b 03 	sts	0x030B, r1
	}
}
    15e4:	cf 91       	pop	r28
    15e6:	df 91       	pop	r29
    15e8:	08 95       	ret

000015ea <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    15ea:	df 93       	push	r29
    15ec:	cf 93       	push	r28
    15ee:	cd b7       	in	r28, 0x3d	; 61
    15f0:	de b7       	in	r29, 0x3e	; 62
    15f2:	28 97       	sbiw	r28, 0x08	; 8
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	f8 94       	cli
    15f8:	de bf       	out	0x3e, r29	; 62
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	cd bf       	out	0x3d, r28	; 61
    15fe:	9c 83       	std	Y+4, r25	; 0x04
    1600:	8b 83       	std	Y+3, r24	; 0x03
    1602:	7e 83       	std	Y+6, r23	; 0x06
    1604:	6d 83       	std	Y+5, r22	; 0x05
    1606:	58 87       	std	Y+8, r21	; 0x08
    1608:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    160a:	eb 81       	ldd	r30, Y+3	; 0x03
    160c:	fc 81       	ldd	r31, Y+4	; 0x04
    160e:	81 e1       	ldi	r24, 0x11	; 17
    1610:	80 83       	st	Z, r24
	pxTopOfStack--;
    1612:	8b 81       	ldd	r24, Y+3	; 0x03
    1614:	9c 81       	ldd	r25, Y+4	; 0x04
    1616:	01 97       	sbiw	r24, 0x01	; 1
    1618:	9c 83       	std	Y+4, r25	; 0x04
    161a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    161c:	eb 81       	ldd	r30, Y+3	; 0x03
    161e:	fc 81       	ldd	r31, Y+4	; 0x04
    1620:	82 e2       	ldi	r24, 0x22	; 34
    1622:	80 83       	st	Z, r24
	pxTopOfStack--;
    1624:	8b 81       	ldd	r24, Y+3	; 0x03
    1626:	9c 81       	ldd	r25, Y+4	; 0x04
    1628:	01 97       	sbiw	r24, 0x01	; 1
    162a:	9c 83       	std	Y+4, r25	; 0x04
    162c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    162e:	eb 81       	ldd	r30, Y+3	; 0x03
    1630:	fc 81       	ldd	r31, Y+4	; 0x04
    1632:	83 e3       	ldi	r24, 0x33	; 51
    1634:	80 83       	st	Z, r24
	pxTopOfStack--;
    1636:	8b 81       	ldd	r24, Y+3	; 0x03
    1638:	9c 81       	ldd	r25, Y+4	; 0x04
    163a:	01 97       	sbiw	r24, 0x01	; 1
    163c:	9c 83       	std	Y+4, r25	; 0x04
    163e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1640:	8d 81       	ldd	r24, Y+5	; 0x05
    1642:	9e 81       	ldd	r25, Y+6	; 0x06
    1644:	9a 83       	std	Y+2, r25	; 0x02
    1646:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1648:	89 81       	ldd	r24, Y+1	; 0x01
    164a:	eb 81       	ldd	r30, Y+3	; 0x03
    164c:	fc 81       	ldd	r31, Y+4	; 0x04
    164e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1650:	8b 81       	ldd	r24, Y+3	; 0x03
    1652:	9c 81       	ldd	r25, Y+4	; 0x04
    1654:	01 97       	sbiw	r24, 0x01	; 1
    1656:	9c 83       	std	Y+4, r25	; 0x04
    1658:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    165a:	89 81       	ldd	r24, Y+1	; 0x01
    165c:	9a 81       	ldd	r25, Y+2	; 0x02
    165e:	89 2f       	mov	r24, r25
    1660:	99 27       	eor	r25, r25
    1662:	9a 83       	std	Y+2, r25	; 0x02
    1664:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1666:	89 81       	ldd	r24, Y+1	; 0x01
    1668:	eb 81       	ldd	r30, Y+3	; 0x03
    166a:	fc 81       	ldd	r31, Y+4	; 0x04
    166c:	80 83       	st	Z, r24
	pxTopOfStack--;
    166e:	8b 81       	ldd	r24, Y+3	; 0x03
    1670:	9c 81       	ldd	r25, Y+4	; 0x04
    1672:	01 97       	sbiw	r24, 0x01	; 1
    1674:	9c 83       	std	Y+4, r25	; 0x04
    1676:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1678:	eb 81       	ldd	r30, Y+3	; 0x03
    167a:	fc 81       	ldd	r31, Y+4	; 0x04
    167c:	10 82       	st	Z, r1
	pxTopOfStack--;
    167e:	8b 81       	ldd	r24, Y+3	; 0x03
    1680:	9c 81       	ldd	r25, Y+4	; 0x04
    1682:	01 97       	sbiw	r24, 0x01	; 1
    1684:	9c 83       	std	Y+4, r25	; 0x04
    1686:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1688:	eb 81       	ldd	r30, Y+3	; 0x03
    168a:	fc 81       	ldd	r31, Y+4	; 0x04
    168c:	80 e8       	ldi	r24, 0x80	; 128
    168e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1690:	8b 81       	ldd	r24, Y+3	; 0x03
    1692:	9c 81       	ldd	r25, Y+4	; 0x04
    1694:	01 97       	sbiw	r24, 0x01	; 1
    1696:	9c 83       	std	Y+4, r25	; 0x04
    1698:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    169a:	eb 81       	ldd	r30, Y+3	; 0x03
    169c:	fc 81       	ldd	r31, Y+4	; 0x04
    169e:	10 82       	st	Z, r1
	pxTopOfStack--;
    16a0:	8b 81       	ldd	r24, Y+3	; 0x03
    16a2:	9c 81       	ldd	r25, Y+4	; 0x04
    16a4:	01 97       	sbiw	r24, 0x01	; 1
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    16aa:	eb 81       	ldd	r30, Y+3	; 0x03
    16ac:	fc 81       	ldd	r31, Y+4	; 0x04
    16ae:	82 e0       	ldi	r24, 0x02	; 2
    16b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    16b2:	8b 81       	ldd	r24, Y+3	; 0x03
    16b4:	9c 81       	ldd	r25, Y+4	; 0x04
    16b6:	01 97       	sbiw	r24, 0x01	; 1
    16b8:	9c 83       	std	Y+4, r25	; 0x04
    16ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    16bc:	eb 81       	ldd	r30, Y+3	; 0x03
    16be:	fc 81       	ldd	r31, Y+4	; 0x04
    16c0:	83 e0       	ldi	r24, 0x03	; 3
    16c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16c4:	8b 81       	ldd	r24, Y+3	; 0x03
    16c6:	9c 81       	ldd	r25, Y+4	; 0x04
    16c8:	01 97       	sbiw	r24, 0x01	; 1
    16ca:	9c 83       	std	Y+4, r25	; 0x04
    16cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    16ce:	eb 81       	ldd	r30, Y+3	; 0x03
    16d0:	fc 81       	ldd	r31, Y+4	; 0x04
    16d2:	84 e0       	ldi	r24, 0x04	; 4
    16d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d6:	8b 81       	ldd	r24, Y+3	; 0x03
    16d8:	9c 81       	ldd	r25, Y+4	; 0x04
    16da:	01 97       	sbiw	r24, 0x01	; 1
    16dc:	9c 83       	std	Y+4, r25	; 0x04
    16de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    16e0:	eb 81       	ldd	r30, Y+3	; 0x03
    16e2:	fc 81       	ldd	r31, Y+4	; 0x04
    16e4:	85 e0       	ldi	r24, 0x05	; 5
    16e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    16e8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ea:	9c 81       	ldd	r25, Y+4	; 0x04
    16ec:	01 97       	sbiw	r24, 0x01	; 1
    16ee:	9c 83       	std	Y+4, r25	; 0x04
    16f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    16f2:	eb 81       	ldd	r30, Y+3	; 0x03
    16f4:	fc 81       	ldd	r31, Y+4	; 0x04
    16f6:	86 e0       	ldi	r24, 0x06	; 6
    16f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    16fa:	8b 81       	ldd	r24, Y+3	; 0x03
    16fc:	9c 81       	ldd	r25, Y+4	; 0x04
    16fe:	01 97       	sbiw	r24, 0x01	; 1
    1700:	9c 83       	std	Y+4, r25	; 0x04
    1702:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1704:	eb 81       	ldd	r30, Y+3	; 0x03
    1706:	fc 81       	ldd	r31, Y+4	; 0x04
    1708:	87 e0       	ldi	r24, 0x07	; 7
    170a:	80 83       	st	Z, r24
	pxTopOfStack--;
    170c:	8b 81       	ldd	r24, Y+3	; 0x03
    170e:	9c 81       	ldd	r25, Y+4	; 0x04
    1710:	01 97       	sbiw	r24, 0x01	; 1
    1712:	9c 83       	std	Y+4, r25	; 0x04
    1714:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1716:	eb 81       	ldd	r30, Y+3	; 0x03
    1718:	fc 81       	ldd	r31, Y+4	; 0x04
    171a:	88 e0       	ldi	r24, 0x08	; 8
    171c:	80 83       	st	Z, r24
	pxTopOfStack--;
    171e:	8b 81       	ldd	r24, Y+3	; 0x03
    1720:	9c 81       	ldd	r25, Y+4	; 0x04
    1722:	01 97       	sbiw	r24, 0x01	; 1
    1724:	9c 83       	std	Y+4, r25	; 0x04
    1726:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1728:	eb 81       	ldd	r30, Y+3	; 0x03
    172a:	fc 81       	ldd	r31, Y+4	; 0x04
    172c:	89 e0       	ldi	r24, 0x09	; 9
    172e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1730:	8b 81       	ldd	r24, Y+3	; 0x03
    1732:	9c 81       	ldd	r25, Y+4	; 0x04
    1734:	01 97       	sbiw	r24, 0x01	; 1
    1736:	9c 83       	std	Y+4, r25	; 0x04
    1738:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    173a:	eb 81       	ldd	r30, Y+3	; 0x03
    173c:	fc 81       	ldd	r31, Y+4	; 0x04
    173e:	80 e1       	ldi	r24, 0x10	; 16
    1740:	80 83       	st	Z, r24
	pxTopOfStack--;
    1742:	8b 81       	ldd	r24, Y+3	; 0x03
    1744:	9c 81       	ldd	r25, Y+4	; 0x04
    1746:	01 97       	sbiw	r24, 0x01	; 1
    1748:	9c 83       	std	Y+4, r25	; 0x04
    174a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    174c:	eb 81       	ldd	r30, Y+3	; 0x03
    174e:	fc 81       	ldd	r31, Y+4	; 0x04
    1750:	81 e1       	ldi	r24, 0x11	; 17
    1752:	80 83       	st	Z, r24
	pxTopOfStack--;
    1754:	8b 81       	ldd	r24, Y+3	; 0x03
    1756:	9c 81       	ldd	r25, Y+4	; 0x04
    1758:	01 97       	sbiw	r24, 0x01	; 1
    175a:	9c 83       	std	Y+4, r25	; 0x04
    175c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    175e:	eb 81       	ldd	r30, Y+3	; 0x03
    1760:	fc 81       	ldd	r31, Y+4	; 0x04
    1762:	82 e1       	ldi	r24, 0x12	; 18
    1764:	80 83       	st	Z, r24
	pxTopOfStack--;
    1766:	8b 81       	ldd	r24, Y+3	; 0x03
    1768:	9c 81       	ldd	r25, Y+4	; 0x04
    176a:	01 97       	sbiw	r24, 0x01	; 1
    176c:	9c 83       	std	Y+4, r25	; 0x04
    176e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1770:	eb 81       	ldd	r30, Y+3	; 0x03
    1772:	fc 81       	ldd	r31, Y+4	; 0x04
    1774:	83 e1       	ldi	r24, 0x13	; 19
    1776:	80 83       	st	Z, r24
	pxTopOfStack--;
    1778:	8b 81       	ldd	r24, Y+3	; 0x03
    177a:	9c 81       	ldd	r25, Y+4	; 0x04
    177c:	01 97       	sbiw	r24, 0x01	; 1
    177e:	9c 83       	std	Y+4, r25	; 0x04
    1780:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1782:	eb 81       	ldd	r30, Y+3	; 0x03
    1784:	fc 81       	ldd	r31, Y+4	; 0x04
    1786:	84 e1       	ldi	r24, 0x14	; 20
    1788:	80 83       	st	Z, r24
	pxTopOfStack--;
    178a:	8b 81       	ldd	r24, Y+3	; 0x03
    178c:	9c 81       	ldd	r25, Y+4	; 0x04
    178e:	01 97       	sbiw	r24, 0x01	; 1
    1790:	9c 83       	std	Y+4, r25	; 0x04
    1792:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1794:	eb 81       	ldd	r30, Y+3	; 0x03
    1796:	fc 81       	ldd	r31, Y+4	; 0x04
    1798:	85 e1       	ldi	r24, 0x15	; 21
    179a:	80 83       	st	Z, r24
	pxTopOfStack--;
    179c:	8b 81       	ldd	r24, Y+3	; 0x03
    179e:	9c 81       	ldd	r25, Y+4	; 0x04
    17a0:	01 97       	sbiw	r24, 0x01	; 1
    17a2:	9c 83       	std	Y+4, r25	; 0x04
    17a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    17a6:	eb 81       	ldd	r30, Y+3	; 0x03
    17a8:	fc 81       	ldd	r31, Y+4	; 0x04
    17aa:	86 e1       	ldi	r24, 0x16	; 22
    17ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ae:	8b 81       	ldd	r24, Y+3	; 0x03
    17b0:	9c 81       	ldd	r25, Y+4	; 0x04
    17b2:	01 97       	sbiw	r24, 0x01	; 1
    17b4:	9c 83       	std	Y+4, r25	; 0x04
    17b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    17b8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ba:	fc 81       	ldd	r31, Y+4	; 0x04
    17bc:	87 e1       	ldi	r24, 0x17	; 23
    17be:	80 83       	st	Z, r24
	pxTopOfStack--;
    17c0:	8b 81       	ldd	r24, Y+3	; 0x03
    17c2:	9c 81       	ldd	r25, Y+4	; 0x04
    17c4:	01 97       	sbiw	r24, 0x01	; 1
    17c6:	9c 83       	std	Y+4, r25	; 0x04
    17c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    17ca:	eb 81       	ldd	r30, Y+3	; 0x03
    17cc:	fc 81       	ldd	r31, Y+4	; 0x04
    17ce:	88 e1       	ldi	r24, 0x18	; 24
    17d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17d2:	8b 81       	ldd	r24, Y+3	; 0x03
    17d4:	9c 81       	ldd	r25, Y+4	; 0x04
    17d6:	01 97       	sbiw	r24, 0x01	; 1
    17d8:	9c 83       	std	Y+4, r25	; 0x04
    17da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    17dc:	eb 81       	ldd	r30, Y+3	; 0x03
    17de:	fc 81       	ldd	r31, Y+4	; 0x04
    17e0:	89 e1       	ldi	r24, 0x19	; 25
    17e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17e4:	8b 81       	ldd	r24, Y+3	; 0x03
    17e6:	9c 81       	ldd	r25, Y+4	; 0x04
    17e8:	01 97       	sbiw	r24, 0x01	; 1
    17ea:	9c 83       	std	Y+4, r25	; 0x04
    17ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    17ee:	eb 81       	ldd	r30, Y+3	; 0x03
    17f0:	fc 81       	ldd	r31, Y+4	; 0x04
    17f2:	80 e2       	ldi	r24, 0x20	; 32
    17f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f6:	8b 81       	ldd	r24, Y+3	; 0x03
    17f8:	9c 81       	ldd	r25, Y+4	; 0x04
    17fa:	01 97       	sbiw	r24, 0x01	; 1
    17fc:	9c 83       	std	Y+4, r25	; 0x04
    17fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1800:	eb 81       	ldd	r30, Y+3	; 0x03
    1802:	fc 81       	ldd	r31, Y+4	; 0x04
    1804:	81 e2       	ldi	r24, 0x21	; 33
    1806:	80 83       	st	Z, r24
	pxTopOfStack--;
    1808:	8b 81       	ldd	r24, Y+3	; 0x03
    180a:	9c 81       	ldd	r25, Y+4	; 0x04
    180c:	01 97       	sbiw	r24, 0x01	; 1
    180e:	9c 83       	std	Y+4, r25	; 0x04
    1810:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1812:	eb 81       	ldd	r30, Y+3	; 0x03
    1814:	fc 81       	ldd	r31, Y+4	; 0x04
    1816:	82 e2       	ldi	r24, 0x22	; 34
    1818:	80 83       	st	Z, r24
	pxTopOfStack--;
    181a:	8b 81       	ldd	r24, Y+3	; 0x03
    181c:	9c 81       	ldd	r25, Y+4	; 0x04
    181e:	01 97       	sbiw	r24, 0x01	; 1
    1820:	9c 83       	std	Y+4, r25	; 0x04
    1822:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1824:	eb 81       	ldd	r30, Y+3	; 0x03
    1826:	fc 81       	ldd	r31, Y+4	; 0x04
    1828:	83 e2       	ldi	r24, 0x23	; 35
    182a:	80 83       	st	Z, r24
	pxTopOfStack--;
    182c:	8b 81       	ldd	r24, Y+3	; 0x03
    182e:	9c 81       	ldd	r25, Y+4	; 0x04
    1830:	01 97       	sbiw	r24, 0x01	; 1
    1832:	9c 83       	std	Y+4, r25	; 0x04
    1834:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1836:	8f 81       	ldd	r24, Y+7	; 0x07
    1838:	98 85       	ldd	r25, Y+8	; 0x08
    183a:	9a 83       	std	Y+2, r25	; 0x02
    183c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    183e:	89 81       	ldd	r24, Y+1	; 0x01
    1840:	eb 81       	ldd	r30, Y+3	; 0x03
    1842:	fc 81       	ldd	r31, Y+4	; 0x04
    1844:	80 83       	st	Z, r24
	pxTopOfStack--;
    1846:	8b 81       	ldd	r24, Y+3	; 0x03
    1848:	9c 81       	ldd	r25, Y+4	; 0x04
    184a:	01 97       	sbiw	r24, 0x01	; 1
    184c:	9c 83       	std	Y+4, r25	; 0x04
    184e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1850:	89 81       	ldd	r24, Y+1	; 0x01
    1852:	9a 81       	ldd	r25, Y+2	; 0x02
    1854:	89 2f       	mov	r24, r25
    1856:	99 27       	eor	r25, r25
    1858:	9a 83       	std	Y+2, r25	; 0x02
    185a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    185c:	89 81       	ldd	r24, Y+1	; 0x01
    185e:	eb 81       	ldd	r30, Y+3	; 0x03
    1860:	fc 81       	ldd	r31, Y+4	; 0x04
    1862:	80 83       	st	Z, r24
	pxTopOfStack--;
    1864:	8b 81       	ldd	r24, Y+3	; 0x03
    1866:	9c 81       	ldd	r25, Y+4	; 0x04
    1868:	01 97       	sbiw	r24, 0x01	; 1
    186a:	9c 83       	std	Y+4, r25	; 0x04
    186c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    186e:	eb 81       	ldd	r30, Y+3	; 0x03
    1870:	fc 81       	ldd	r31, Y+4	; 0x04
    1872:	86 e2       	ldi	r24, 0x26	; 38
    1874:	80 83       	st	Z, r24
	pxTopOfStack--;
    1876:	8b 81       	ldd	r24, Y+3	; 0x03
    1878:	9c 81       	ldd	r25, Y+4	; 0x04
    187a:	01 97       	sbiw	r24, 0x01	; 1
    187c:	9c 83       	std	Y+4, r25	; 0x04
    187e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1880:	eb 81       	ldd	r30, Y+3	; 0x03
    1882:	fc 81       	ldd	r31, Y+4	; 0x04
    1884:	87 e2       	ldi	r24, 0x27	; 39
    1886:	80 83       	st	Z, r24
	pxTopOfStack--;
    1888:	8b 81       	ldd	r24, Y+3	; 0x03
    188a:	9c 81       	ldd	r25, Y+4	; 0x04
    188c:	01 97       	sbiw	r24, 0x01	; 1
    188e:	9c 83       	std	Y+4, r25	; 0x04
    1890:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1892:	eb 81       	ldd	r30, Y+3	; 0x03
    1894:	fc 81       	ldd	r31, Y+4	; 0x04
    1896:	88 e2       	ldi	r24, 0x28	; 40
    1898:	80 83       	st	Z, r24
	pxTopOfStack--;
    189a:	8b 81       	ldd	r24, Y+3	; 0x03
    189c:	9c 81       	ldd	r25, Y+4	; 0x04
    189e:	01 97       	sbiw	r24, 0x01	; 1
    18a0:	9c 83       	std	Y+4, r25	; 0x04
    18a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    18a4:	eb 81       	ldd	r30, Y+3	; 0x03
    18a6:	fc 81       	ldd	r31, Y+4	; 0x04
    18a8:	89 e2       	ldi	r24, 0x29	; 41
    18aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ac:	8b 81       	ldd	r24, Y+3	; 0x03
    18ae:	9c 81       	ldd	r25, Y+4	; 0x04
    18b0:	01 97       	sbiw	r24, 0x01	; 1
    18b2:	9c 83       	std	Y+4, r25	; 0x04
    18b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    18b6:	eb 81       	ldd	r30, Y+3	; 0x03
    18b8:	fc 81       	ldd	r31, Y+4	; 0x04
    18ba:	80 e3       	ldi	r24, 0x30	; 48
    18bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    18be:	8b 81       	ldd	r24, Y+3	; 0x03
    18c0:	9c 81       	ldd	r25, Y+4	; 0x04
    18c2:	01 97       	sbiw	r24, 0x01	; 1
    18c4:	9c 83       	std	Y+4, r25	; 0x04
    18c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    18c8:	eb 81       	ldd	r30, Y+3	; 0x03
    18ca:	fc 81       	ldd	r31, Y+4	; 0x04
    18cc:	81 e3       	ldi	r24, 0x31	; 49
    18ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    18d0:	8b 81       	ldd	r24, Y+3	; 0x03
    18d2:	9c 81       	ldd	r25, Y+4	; 0x04
    18d4:	01 97       	sbiw	r24, 0x01	; 1
    18d6:	9c 83       	std	Y+4, r25	; 0x04
    18d8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    18da:	8b 81       	ldd	r24, Y+3	; 0x03
    18dc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    18de:	28 96       	adiw	r28, 0x08	; 8
    18e0:	0f b6       	in	r0, 0x3f	; 63
    18e2:	f8 94       	cli
    18e4:	de bf       	out	0x3e, r29	; 62
    18e6:	0f be       	out	0x3f, r0	; 63
    18e8:	cd bf       	out	0x3d, r28	; 61
    18ea:	cf 91       	pop	r28
    18ec:	df 91       	pop	r29
    18ee:	08 95       	ret

000018f0 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    18f0:	df 93       	push	r29
    18f2:	cf 93       	push	r28
    18f4:	cd b7       	in	r28, 0x3d	; 61
    18f6:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    18f8:	0e 94 68 0d 	call	0x1ad0	; 0x1ad0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    18fc:	a0 91 0c 03 	lds	r26, 0x030C
    1900:	b0 91 0d 03 	lds	r27, 0x030D
    1904:	cd 91       	ld	r28, X+
    1906:	cd bf       	out	0x3d, r28	; 61
    1908:	dd 91       	ld	r29, X+
    190a:	de bf       	out	0x3e, r29	; 62
    190c:	ff 91       	pop	r31
    190e:	ef 91       	pop	r30
    1910:	df 91       	pop	r29
    1912:	cf 91       	pop	r28
    1914:	bf 91       	pop	r27
    1916:	af 91       	pop	r26
    1918:	9f 91       	pop	r25
    191a:	8f 91       	pop	r24
    191c:	7f 91       	pop	r23
    191e:	6f 91       	pop	r22
    1920:	5f 91       	pop	r21
    1922:	4f 91       	pop	r20
    1924:	3f 91       	pop	r19
    1926:	2f 91       	pop	r18
    1928:	1f 91       	pop	r17
    192a:	0f 91       	pop	r16
    192c:	ff 90       	pop	r15
    192e:	ef 90       	pop	r14
    1930:	df 90       	pop	r13
    1932:	cf 90       	pop	r12
    1934:	bf 90       	pop	r11
    1936:	af 90       	pop	r10
    1938:	9f 90       	pop	r9
    193a:	8f 90       	pop	r8
    193c:	7f 90       	pop	r7
    193e:	6f 90       	pop	r6
    1940:	5f 90       	pop	r5
    1942:	4f 90       	pop	r4
    1944:	3f 90       	pop	r3
    1946:	2f 90       	pop	r2
    1948:	1f 90       	pop	r1
    194a:	0f 90       	pop	r0
    194c:	0f be       	out	0x3f, r0	; 63
    194e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1950:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1952:	81 e0       	ldi	r24, 0x01	; 1
}
    1954:	cf 91       	pop	r28
    1956:	df 91       	pop	r29
    1958:	08 95       	ret

0000195a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    195a:	df 93       	push	r29
    195c:	cf 93       	push	r28
    195e:	cd b7       	in	r28, 0x3d	; 61
    1960:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1962:	cf 91       	pop	r28
    1964:	df 91       	pop	r29
    1966:	08 95       	ret

00001968 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1968:	0f 92       	push	r0
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	f8 94       	cli
    196e:	0f 92       	push	r0
    1970:	1f 92       	push	r1
    1972:	11 24       	eor	r1, r1
    1974:	2f 92       	push	r2
    1976:	3f 92       	push	r3
    1978:	4f 92       	push	r4
    197a:	5f 92       	push	r5
    197c:	6f 92       	push	r6
    197e:	7f 92       	push	r7
    1980:	8f 92       	push	r8
    1982:	9f 92       	push	r9
    1984:	af 92       	push	r10
    1986:	bf 92       	push	r11
    1988:	cf 92       	push	r12
    198a:	df 92       	push	r13
    198c:	ef 92       	push	r14
    198e:	ff 92       	push	r15
    1990:	0f 93       	push	r16
    1992:	1f 93       	push	r17
    1994:	2f 93       	push	r18
    1996:	3f 93       	push	r19
    1998:	4f 93       	push	r20
    199a:	5f 93       	push	r21
    199c:	6f 93       	push	r22
    199e:	7f 93       	push	r23
    19a0:	8f 93       	push	r24
    19a2:	9f 93       	push	r25
    19a4:	af 93       	push	r26
    19a6:	bf 93       	push	r27
    19a8:	cf 93       	push	r28
    19aa:	df 93       	push	r29
    19ac:	ef 93       	push	r30
    19ae:	ff 93       	push	r31
    19b0:	a0 91 0c 03 	lds	r26, 0x030C
    19b4:	b0 91 0d 03 	lds	r27, 0x030D
    19b8:	0d b6       	in	r0, 0x3d	; 61
    19ba:	0d 92       	st	X+, r0
    19bc:	0e b6       	in	r0, 0x3e	; 62
    19be:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    19c0:	0e 94 83 17 	call	0x2f06	; 0x2f06 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    19c4:	a0 91 0c 03 	lds	r26, 0x030C
    19c8:	b0 91 0d 03 	lds	r27, 0x030D
    19cc:	cd 91       	ld	r28, X+
    19ce:	cd bf       	out	0x3d, r28	; 61
    19d0:	dd 91       	ld	r29, X+
    19d2:	de bf       	out	0x3e, r29	; 62
    19d4:	ff 91       	pop	r31
    19d6:	ef 91       	pop	r30
    19d8:	df 91       	pop	r29
    19da:	cf 91       	pop	r28
    19dc:	bf 91       	pop	r27
    19de:	af 91       	pop	r26
    19e0:	9f 91       	pop	r25
    19e2:	8f 91       	pop	r24
    19e4:	7f 91       	pop	r23
    19e6:	6f 91       	pop	r22
    19e8:	5f 91       	pop	r21
    19ea:	4f 91       	pop	r20
    19ec:	3f 91       	pop	r19
    19ee:	2f 91       	pop	r18
    19f0:	1f 91       	pop	r17
    19f2:	0f 91       	pop	r16
    19f4:	ff 90       	pop	r15
    19f6:	ef 90       	pop	r14
    19f8:	df 90       	pop	r13
    19fa:	cf 90       	pop	r12
    19fc:	bf 90       	pop	r11
    19fe:	af 90       	pop	r10
    1a00:	9f 90       	pop	r9
    1a02:	8f 90       	pop	r8
    1a04:	7f 90       	pop	r7
    1a06:	6f 90       	pop	r6
    1a08:	5f 90       	pop	r5
    1a0a:	4f 90       	pop	r4
    1a0c:	3f 90       	pop	r3
    1a0e:	2f 90       	pop	r2
    1a10:	1f 90       	pop	r1
    1a12:	0f 90       	pop	r0
    1a14:	0f be       	out	0x3f, r0	; 63
    1a16:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a18:	08 95       	ret

00001a1a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1a1a:	0f 92       	push	r0
    1a1c:	0f b6       	in	r0, 0x3f	; 63
    1a1e:	f8 94       	cli
    1a20:	0f 92       	push	r0
    1a22:	1f 92       	push	r1
    1a24:	11 24       	eor	r1, r1
    1a26:	2f 92       	push	r2
    1a28:	3f 92       	push	r3
    1a2a:	4f 92       	push	r4
    1a2c:	5f 92       	push	r5
    1a2e:	6f 92       	push	r6
    1a30:	7f 92       	push	r7
    1a32:	8f 92       	push	r8
    1a34:	9f 92       	push	r9
    1a36:	af 92       	push	r10
    1a38:	bf 92       	push	r11
    1a3a:	cf 92       	push	r12
    1a3c:	df 92       	push	r13
    1a3e:	ef 92       	push	r14
    1a40:	ff 92       	push	r15
    1a42:	0f 93       	push	r16
    1a44:	1f 93       	push	r17
    1a46:	2f 93       	push	r18
    1a48:	3f 93       	push	r19
    1a4a:	4f 93       	push	r20
    1a4c:	5f 93       	push	r21
    1a4e:	6f 93       	push	r22
    1a50:	7f 93       	push	r23
    1a52:	8f 93       	push	r24
    1a54:	9f 93       	push	r25
    1a56:	af 93       	push	r26
    1a58:	bf 93       	push	r27
    1a5a:	cf 93       	push	r28
    1a5c:	df 93       	push	r29
    1a5e:	ef 93       	push	r30
    1a60:	ff 93       	push	r31
    1a62:	a0 91 0c 03 	lds	r26, 0x030C
    1a66:	b0 91 0d 03 	lds	r27, 0x030D
    1a6a:	0d b6       	in	r0, 0x3d	; 61
    1a6c:	0d 92       	st	X+, r0
    1a6e:	0e b6       	in	r0, 0x3e	; 62
    1a70:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a72:	0e 94 ae 16 	call	0x2d5c	; 0x2d5c <vTaskIncrementTick>
	vTaskSwitchContext();
    1a76:	0e 94 83 17 	call	0x2f06	; 0x2f06 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a7a:	a0 91 0c 03 	lds	r26, 0x030C
    1a7e:	b0 91 0d 03 	lds	r27, 0x030D
    1a82:	cd 91       	ld	r28, X+
    1a84:	cd bf       	out	0x3d, r28	; 61
    1a86:	dd 91       	ld	r29, X+
    1a88:	de bf       	out	0x3e, r29	; 62
    1a8a:	ff 91       	pop	r31
    1a8c:	ef 91       	pop	r30
    1a8e:	df 91       	pop	r29
    1a90:	cf 91       	pop	r28
    1a92:	bf 91       	pop	r27
    1a94:	af 91       	pop	r26
    1a96:	9f 91       	pop	r25
    1a98:	8f 91       	pop	r24
    1a9a:	7f 91       	pop	r23
    1a9c:	6f 91       	pop	r22
    1a9e:	5f 91       	pop	r21
    1aa0:	4f 91       	pop	r20
    1aa2:	3f 91       	pop	r19
    1aa4:	2f 91       	pop	r18
    1aa6:	1f 91       	pop	r17
    1aa8:	0f 91       	pop	r16
    1aaa:	ff 90       	pop	r15
    1aac:	ef 90       	pop	r14
    1aae:	df 90       	pop	r13
    1ab0:	cf 90       	pop	r12
    1ab2:	bf 90       	pop	r11
    1ab4:	af 90       	pop	r10
    1ab6:	9f 90       	pop	r9
    1ab8:	8f 90       	pop	r8
    1aba:	7f 90       	pop	r7
    1abc:	6f 90       	pop	r6
    1abe:	5f 90       	pop	r5
    1ac0:	4f 90       	pop	r4
    1ac2:	3f 90       	pop	r3
    1ac4:	2f 90       	pop	r2
    1ac6:	1f 90       	pop	r1
    1ac8:	0f 90       	pop	r0
    1aca:	0f be       	out	0x3f, r0	; 63
    1acc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ace:	08 95       	ret

00001ad0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1ad0:	df 93       	push	r29
    1ad2:	cf 93       	push	r28
    1ad4:	00 d0       	rcall	.+0      	; 0x1ad6 <prvSetupTimerInterrupt+0x6>
    1ad6:	00 d0       	rcall	.+0      	; 0x1ad8 <prvSetupTimerInterrupt+0x8>
    1ad8:	00 d0       	rcall	.+0      	; 0x1ada <prvSetupTimerInterrupt+0xa>
    1ada:	cd b7       	in	r28, 0x3d	; 61
    1adc:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1ade:	80 e4       	ldi	r24, 0x40	; 64
    1ae0:	9f e1       	ldi	r25, 0x1F	; 31
    1ae2:	a0 e0       	ldi	r26, 0x00	; 0
    1ae4:	b0 e0       	ldi	r27, 0x00	; 0
    1ae6:	8b 83       	std	Y+3, r24	; 0x03
    1ae8:	9c 83       	std	Y+4, r25	; 0x04
    1aea:	ad 83       	std	Y+5, r26	; 0x05
    1aec:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1aee:	8b 81       	ldd	r24, Y+3	; 0x03
    1af0:	9c 81       	ldd	r25, Y+4	; 0x04
    1af2:	ad 81       	ldd	r26, Y+5	; 0x05
    1af4:	be 81       	ldd	r27, Y+6	; 0x06
    1af6:	68 94       	set
    1af8:	15 f8       	bld	r1, 5
    1afa:	b6 95       	lsr	r27
    1afc:	a7 95       	ror	r26
    1afe:	97 95       	ror	r25
    1b00:	87 95       	ror	r24
    1b02:	16 94       	lsr	r1
    1b04:	d1 f7       	brne	.-12     	; 0x1afa <prvSetupTimerInterrupt+0x2a>
    1b06:	8b 83       	std	Y+3, r24	; 0x03
    1b08:	9c 83       	std	Y+4, r25	; 0x04
    1b0a:	ad 83       	std	Y+5, r26	; 0x05
    1b0c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b10:	9c 81       	ldd	r25, Y+4	; 0x04
    1b12:	ad 81       	ldd	r26, Y+5	; 0x05
    1b14:	be 81       	ldd	r27, Y+6	; 0x06
    1b16:	01 97       	sbiw	r24, 0x01	; 1
    1b18:	a1 09       	sbc	r26, r1
    1b1a:	b1 09       	sbc	r27, r1
    1b1c:	8b 83       	std	Y+3, r24	; 0x03
    1b1e:	9c 83       	std	Y+4, r25	; 0x04
    1b20:	ad 83       	std	Y+5, r26	; 0x05
    1b22:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1b24:	8b 81       	ldd	r24, Y+3	; 0x03
    1b26:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1b28:	8b 81       	ldd	r24, Y+3	; 0x03
    1b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b2c:	ad 81       	ldd	r26, Y+5	; 0x05
    1b2e:	be 81       	ldd	r27, Y+6	; 0x06
    1b30:	89 2f       	mov	r24, r25
    1b32:	9a 2f       	mov	r25, r26
    1b34:	ab 2f       	mov	r26, r27
    1b36:	bb 27       	eor	r27, r27
    1b38:	8b 83       	std	Y+3, r24	; 0x03
    1b3a:	9c 83       	std	Y+4, r25	; 0x04
    1b3c:	ad 83       	std	Y+5, r26	; 0x05
    1b3e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1b40:	8b 81       	ldd	r24, Y+3	; 0x03
    1b42:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1b44:	eb e4       	ldi	r30, 0x4B	; 75
    1b46:	f0 e0       	ldi	r31, 0x00	; 0
    1b48:	8a 81       	ldd	r24, Y+2	; 0x02
    1b4a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1b4c:	ea e4       	ldi	r30, 0x4A	; 74
    1b4e:	f0 e0       	ldi	r31, 0x00	; 0
    1b50:	89 81       	ldd	r24, Y+1	; 0x01
    1b52:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1b54:	8b e0       	ldi	r24, 0x0B	; 11
    1b56:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1b58:	ee e4       	ldi	r30, 0x4E	; 78
    1b5a:	f0 e0       	ldi	r31, 0x00	; 0
    1b5c:	89 81       	ldd	r24, Y+1	; 0x01
    1b5e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1b60:	e9 e5       	ldi	r30, 0x59	; 89
    1b62:	f0 e0       	ldi	r31, 0x00	; 0
    1b64:	80 81       	ld	r24, Z
    1b66:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1b68:	89 81       	ldd	r24, Y+1	; 0x01
    1b6a:	80 61       	ori	r24, 0x10	; 16
    1b6c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1b6e:	e9 e5       	ldi	r30, 0x59	; 89
    1b70:	f0 e0       	ldi	r31, 0x00	; 0
    1b72:	89 81       	ldd	r24, Y+1	; 0x01
    1b74:	80 83       	st	Z, r24
}
    1b76:	26 96       	adiw	r28, 0x06	; 6
    1b78:	0f b6       	in	r0, 0x3f	; 63
    1b7a:	f8 94       	cli
    1b7c:	de bf       	out	0x3e, r29	; 62
    1b7e:	0f be       	out	0x3f, r0	; 63
    1b80:	cd bf       	out	0x3d, r28	; 61
    1b82:	cf 91       	pop	r28
    1b84:	df 91       	pop	r29
    1b86:	08 95       	ret

00001b88 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1b88:	0e 94 0d 0d 	call	0x1a1a	; 0x1a1a <vPortYieldFromTick>
		asm volatile ( "reti" );
    1b8c:	18 95       	reti

00001b8e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1b8e:	df 93       	push	r29
    1b90:	cf 93       	push	r28
    1b92:	cd b7       	in	r28, 0x3d	; 61
    1b94:	de b7       	in	r29, 0x3e	; 62
    1b96:	28 97       	sbiw	r28, 0x08	; 8
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	f8 94       	cli
    1b9c:	de bf       	out	0x3e, r29	; 62
    1b9e:	0f be       	out	0x3f, r0	; 63
    1ba0:	cd bf       	out	0x3d, r28	; 61
    1ba2:	8f 83       	std	Y+7, r24	; 0x07
    1ba4:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1ba6:	1a 82       	std	Y+2, r1	; 0x02
    1ba8:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1baa:	8f 81       	ldd	r24, Y+7	; 0x07
    1bac:	88 23       	and	r24, r24
    1bae:	09 f4       	brne	.+2      	; 0x1bb2 <xQueueCreate+0x24>
    1bb0:	8c c0       	rjmp	.+280    	; 0x1cca <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1bb2:	8f e1       	ldi	r24, 0x1F	; 31
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    1bba:	9e 83       	std	Y+6, r25	; 0x06
    1bbc:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1bbe:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc0:	9e 81       	ldd	r25, Y+6	; 0x06
    1bc2:	00 97       	sbiw	r24, 0x00	; 0
    1bc4:	09 f4       	brne	.+2      	; 0x1bc8 <xQueueCreate+0x3a>
    1bc6:	81 c0       	rjmp	.+258    	; 0x1cca <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1bc8:	8f 81       	ldd	r24, Y+7	; 0x07
    1bca:	28 2f       	mov	r18, r24
    1bcc:	30 e0       	ldi	r19, 0x00	; 0
    1bce:	88 85       	ldd	r24, Y+8	; 0x08
    1bd0:	88 2f       	mov	r24, r24
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	ac 01       	movw	r20, r24
    1bd6:	24 9f       	mul	r18, r20
    1bd8:	c0 01       	movw	r24, r0
    1bda:	25 9f       	mul	r18, r21
    1bdc:	90 0d       	add	r25, r0
    1bde:	34 9f       	mul	r19, r20
    1be0:	90 0d       	add	r25, r0
    1be2:	11 24       	eor	r1, r1
    1be4:	01 96       	adiw	r24, 0x01	; 1
    1be6:	9c 83       	std	Y+4, r25	; 0x04
    1be8:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1bea:	8b 81       	ldd	r24, Y+3	; 0x03
    1bec:	9c 81       	ldd	r25, Y+4	; 0x04
    1bee:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    1bf2:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf4:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf6:	91 83       	std	Z+1, r25	; 0x01
    1bf8:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1bfa:	ed 81       	ldd	r30, Y+5	; 0x05
    1bfc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bfe:	80 81       	ld	r24, Z
    1c00:	91 81       	ldd	r25, Z+1	; 0x01
    1c02:	00 97       	sbiw	r24, 0x00	; 0
    1c04:	09 f4       	brne	.+2      	; 0x1c08 <xQueueCreate+0x7a>
    1c06:	5d c0       	rjmp	.+186    	; 0x1cc2 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1c08:	ed 81       	ldd	r30, Y+5	; 0x05
    1c0a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c0c:	40 81       	ld	r20, Z
    1c0e:	51 81       	ldd	r21, Z+1	; 0x01
    1c10:	8f 81       	ldd	r24, Y+7	; 0x07
    1c12:	28 2f       	mov	r18, r24
    1c14:	30 e0       	ldi	r19, 0x00	; 0
    1c16:	88 85       	ldd	r24, Y+8	; 0x08
    1c18:	88 2f       	mov	r24, r24
    1c1a:	90 e0       	ldi	r25, 0x00	; 0
    1c1c:	bc 01       	movw	r22, r24
    1c1e:	26 9f       	mul	r18, r22
    1c20:	c0 01       	movw	r24, r0
    1c22:	27 9f       	mul	r18, r23
    1c24:	90 0d       	add	r25, r0
    1c26:	36 9f       	mul	r19, r22
    1c28:	90 0d       	add	r25, r0
    1c2a:	11 24       	eor	r1, r1
    1c2c:	84 0f       	add	r24, r20
    1c2e:	95 1f       	adc	r25, r21
    1c30:	ed 81       	ldd	r30, Y+5	; 0x05
    1c32:	fe 81       	ldd	r31, Y+6	; 0x06
    1c34:	93 83       	std	Z+3, r25	; 0x03
    1c36:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1c38:	ed 81       	ldd	r30, Y+5	; 0x05
    1c3a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c3c:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1c3e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c40:	fe 81       	ldd	r31, Y+6	; 0x06
    1c42:	80 81       	ld	r24, Z
    1c44:	91 81       	ldd	r25, Z+1	; 0x01
    1c46:	ed 81       	ldd	r30, Y+5	; 0x05
    1c48:	fe 81       	ldd	r31, Y+6	; 0x06
    1c4a:	95 83       	std	Z+5, r25	; 0x05
    1c4c:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1c4e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c50:	fe 81       	ldd	r31, Y+6	; 0x06
    1c52:	40 81       	ld	r20, Z
    1c54:	51 81       	ldd	r21, Z+1	; 0x01
    1c56:	8f 81       	ldd	r24, Y+7	; 0x07
    1c58:	88 2f       	mov	r24, r24
    1c5a:	90 e0       	ldi	r25, 0x00	; 0
    1c5c:	9c 01       	movw	r18, r24
    1c5e:	21 50       	subi	r18, 0x01	; 1
    1c60:	30 40       	sbci	r19, 0x00	; 0
    1c62:	88 85       	ldd	r24, Y+8	; 0x08
    1c64:	88 2f       	mov	r24, r24
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	bc 01       	movw	r22, r24
    1c6a:	26 9f       	mul	r18, r22
    1c6c:	c0 01       	movw	r24, r0
    1c6e:	27 9f       	mul	r18, r23
    1c70:	90 0d       	add	r25, r0
    1c72:	36 9f       	mul	r19, r22
    1c74:	90 0d       	add	r25, r0
    1c76:	11 24       	eor	r1, r1
    1c78:	84 0f       	add	r24, r20
    1c7a:	95 1f       	adc	r25, r21
    1c7c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c7e:	fe 81       	ldd	r31, Y+6	; 0x06
    1c80:	97 83       	std	Z+7, r25	; 0x07
    1c82:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1c84:	ed 81       	ldd	r30, Y+5	; 0x05
    1c86:	fe 81       	ldd	r31, Y+6	; 0x06
    1c88:	8f 81       	ldd	r24, Y+7	; 0x07
    1c8a:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1c8c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c8e:	fe 81       	ldd	r31, Y+6	; 0x06
    1c90:	88 85       	ldd	r24, Y+8	; 0x08
    1c92:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1c94:	ed 81       	ldd	r30, Y+5	; 0x05
    1c96:	fe 81       	ldd	r31, Y+6	; 0x06
    1c98:	8f ef       	ldi	r24, 0xFF	; 255
    1c9a:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1c9c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c9e:	fe 81       	ldd	r31, Y+6	; 0x06
    1ca0:	8f ef       	ldi	r24, 0xFF	; 255
    1ca2:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1ca4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ca8:	08 96       	adiw	r24, 0x08	; 8
    1caa:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1cae:	8d 81       	ldd	r24, Y+5	; 0x05
    1cb0:	9e 81       	ldd	r25, Y+6	; 0x06
    1cb2:	41 96       	adiw	r24, 0x11	; 17
    1cb4:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    1cba:	9e 81       	ldd	r25, Y+6	; 0x06
    1cbc:	9a 83       	std	Y+2, r25	; 0x02
    1cbe:	89 83       	std	Y+1, r24	; 0x01
    1cc0:	04 c0       	rjmp	.+8      	; 0x1cca <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1cc2:	8d 81       	ldd	r24, Y+5	; 0x05
    1cc4:	9e 81       	ldd	r25, Y+6	; 0x06
    1cc6:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1cca:	89 81       	ldd	r24, Y+1	; 0x01
    1ccc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1cce:	28 96       	adiw	r28, 0x08	; 8
    1cd0:	0f b6       	in	r0, 0x3f	; 63
    1cd2:	f8 94       	cli
    1cd4:	de bf       	out	0x3e, r29	; 62
    1cd6:	0f be       	out	0x3f, r0	; 63
    1cd8:	cd bf       	out	0x3d, r28	; 61
    1cda:	cf 91       	pop	r28
    1cdc:	df 91       	pop	r29
    1cde:	08 95       	ret

00001ce0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1ce0:	df 93       	push	r29
    1ce2:	cf 93       	push	r28
    1ce4:	cd b7       	in	r28, 0x3d	; 61
    1ce6:	de b7       	in	r29, 0x3e	; 62
    1ce8:	2c 97       	sbiw	r28, 0x0c	; 12
    1cea:	0f b6       	in	r0, 0x3f	; 63
    1cec:	f8 94       	cli
    1cee:	de bf       	out	0x3e, r29	; 62
    1cf0:	0f be       	out	0x3f, r0	; 63
    1cf2:	cd bf       	out	0x3d, r28	; 61
    1cf4:	9e 83       	std	Y+6, r25	; 0x06
    1cf6:	8d 83       	std	Y+5, r24	; 0x05
    1cf8:	78 87       	std	Y+8, r23	; 0x08
    1cfa:	6f 83       	std	Y+7, r22	; 0x07
    1cfc:	5a 87       	std	Y+10, r21	; 0x0a
    1cfe:	49 87       	std	Y+9, r20	; 0x09
    1d00:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1d02:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d0a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d0c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d0e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d10:	ed 81       	ldd	r30, Y+5	; 0x05
    1d12:	fe 81       	ldd	r31, Y+6	; 0x06
    1d14:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d16:	98 17       	cp	r25, r24
    1d18:	d8 f4       	brcc	.+54     	; 0x1d50 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d1a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d1c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d1e:	2f 81       	ldd	r18, Y+7	; 0x07
    1d20:	38 85       	ldd	r19, Y+8	; 0x08
    1d22:	b9 01       	movw	r22, r18
    1d24:	4b 85       	ldd	r20, Y+11	; 0x0b
    1d26:	0e 94 ab 10 	call	0x2156	; 0x2156 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d2a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d2c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d2e:	81 89       	ldd	r24, Z+17	; 0x11
    1d30:	88 23       	and	r24, r24
    1d32:	49 f0       	breq	.+18     	; 0x1d46 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1d34:	8d 81       	ldd	r24, Y+5	; 0x05
    1d36:	9e 81       	ldd	r25, Y+6	; 0x06
    1d38:	41 96       	adiw	r24, 0x11	; 17
    1d3a:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskRemoveFromEventList>
    1d3e:	81 30       	cpi	r24, 0x01	; 1
    1d40:	11 f4       	brne	.+4      	; 0x1d46 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1d42:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1d46:	0f 90       	pop	r0
    1d48:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1d4a:	81 e0       	ldi	r24, 0x01	; 1
    1d4c:	8c 87       	std	Y+12, r24	; 0x0c
    1d4e:	5c c0       	rjmp	.+184    	; 0x1e08 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1d50:	89 85       	ldd	r24, Y+9	; 0x09
    1d52:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d54:	00 97       	sbiw	r24, 0x00	; 0
    1d56:	21 f4       	brne	.+8      	; 0x1d60 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d58:	0f 90       	pop	r0
    1d5a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1d5c:	1c 86       	std	Y+12, r1	; 0x0c
    1d5e:	54 c0       	rjmp	.+168    	; 0x1e08 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1d60:	89 81       	ldd	r24, Y+1	; 0x01
    1d62:	88 23       	and	r24, r24
    1d64:	31 f4       	brne	.+12     	; 0x1d72 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d66:	ce 01       	movw	r24, r28
    1d68:	02 96       	adiw	r24, 0x02	; 2
    1d6a:	0e 94 9a 18 	call	0x3134	; 0x3134 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1d72:	0f 90       	pop	r0
    1d74:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d76:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d7a:	0f b6       	in	r0, 0x3f	; 63
    1d7c:	f8 94       	cli
    1d7e:	0f 92       	push	r0
    1d80:	ed 81       	ldd	r30, Y+5	; 0x05
    1d82:	fe 81       	ldd	r31, Y+6	; 0x06
    1d84:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d86:	8f 3f       	cpi	r24, 0xFF	; 255
    1d88:	19 f4       	brne	.+6      	; 0x1d90 <xQueueGenericSend+0xb0>
    1d8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d8e:	15 8e       	std	Z+29, r1	; 0x1d
    1d90:	ed 81       	ldd	r30, Y+5	; 0x05
    1d92:	fe 81       	ldd	r31, Y+6	; 0x06
    1d94:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d96:	8f 3f       	cpi	r24, 0xFF	; 255
    1d98:	19 f4       	brne	.+6      	; 0x1da0 <xQueueGenericSend+0xc0>
    1d9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d9e:	16 8e       	std	Z+30, r1	; 0x1e
    1da0:	0f 90       	pop	r0
    1da2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1da4:	ce 01       	movw	r24, r28
    1da6:	02 96       	adiw	r24, 0x02	; 2
    1da8:	9e 01       	movw	r18, r28
    1daa:	27 5f       	subi	r18, 0xF7	; 247
    1dac:	3f 4f       	sbci	r19, 0xFF	; 255
    1dae:	b9 01       	movw	r22, r18
    1db0:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskCheckForTimeOut>
    1db4:	88 23       	and	r24, r24
    1db6:	09 f5       	brne	.+66     	; 0x1dfa <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1db8:	8d 81       	ldd	r24, Y+5	; 0x05
    1dba:	9e 81       	ldd	r25, Y+6	; 0x06
    1dbc:	0e 94 0f 12 	call	0x241e	; 0x241e <prvIsQueueFull>
    1dc0:	88 23       	and	r24, r24
    1dc2:	a1 f0       	breq	.+40     	; 0x1dec <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1dc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc6:	9e 81       	ldd	r25, Y+6	; 0x06
    1dc8:	08 96       	adiw	r24, 0x08	; 8
    1dca:	29 85       	ldd	r18, Y+9	; 0x09
    1dcc:	3a 85       	ldd	r19, Y+10	; 0x0a
    1dce:	b9 01       	movw	r22, r18
    1dd0:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1dd4:	8d 81       	ldd	r24, Y+5	; 0x05
    1dd6:	9e 81       	ldd	r25, Y+6	; 0x06
    1dd8:	0e 94 88 11 	call	0x2310	; 0x2310 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1ddc:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
    1de0:	88 23       	and	r24, r24
    1de2:	09 f0       	breq	.+2      	; 0x1de6 <xQueueGenericSend+0x106>
    1de4:	8f cf       	rjmp	.-226    	; 0x1d04 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1de6:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
    1dea:	8c cf       	rjmp	.-232    	; 0x1d04 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1dec:	8d 81       	ldd	r24, Y+5	; 0x05
    1dee:	9e 81       	ldd	r25, Y+6	; 0x06
    1df0:	0e 94 88 11 	call	0x2310	; 0x2310 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1df4:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
    1df8:	85 cf       	rjmp	.-246    	; 0x1d04 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    1dfc:	9e 81       	ldd	r25, Y+6	; 0x06
    1dfe:	0e 94 88 11 	call	0x2310	; 0x2310 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e02:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1e06:	1c 86       	std	Y+12, r1	; 0x0c
    1e08:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1e0a:	2c 96       	adiw	r28, 0x0c	; 12
    1e0c:	0f b6       	in	r0, 0x3f	; 63
    1e0e:	f8 94       	cli
    1e10:	de bf       	out	0x3e, r29	; 62
    1e12:	0f be       	out	0x3f, r0	; 63
    1e14:	cd bf       	out	0x3d, r28	; 61
    1e16:	cf 91       	pop	r28
    1e18:	df 91       	pop	r29
    1e1a:	08 95       	ret

00001e1c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1e1c:	df 93       	push	r29
    1e1e:	cf 93       	push	r28
    1e20:	cd b7       	in	r28, 0x3d	; 61
    1e22:	de b7       	in	r29, 0x3e	; 62
    1e24:	29 97       	sbiw	r28, 0x09	; 9
    1e26:	0f b6       	in	r0, 0x3f	; 63
    1e28:	f8 94       	cli
    1e2a:	de bf       	out	0x3e, r29	; 62
    1e2c:	0f be       	out	0x3f, r0	; 63
    1e2e:	cd bf       	out	0x3d, r28	; 61
    1e30:	9c 83       	std	Y+4, r25	; 0x04
    1e32:	8b 83       	std	Y+3, r24	; 0x03
    1e34:	7e 83       	std	Y+6, r23	; 0x06
    1e36:	6d 83       	std	Y+5, r22	; 0x05
    1e38:	58 87       	std	Y+8, r21	; 0x08
    1e3a:	4f 83       	std	Y+7, r20	; 0x07
    1e3c:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e3e:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e40:	eb 81       	ldd	r30, Y+3	; 0x03
    1e42:	fc 81       	ldd	r31, Y+4	; 0x04
    1e44:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e46:	eb 81       	ldd	r30, Y+3	; 0x03
    1e48:	fc 81       	ldd	r31, Y+4	; 0x04
    1e4a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e4c:	98 17       	cp	r25, r24
    1e4e:	40 f5       	brcc	.+80     	; 0x1ea0 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e50:	8b 81       	ldd	r24, Y+3	; 0x03
    1e52:	9c 81       	ldd	r25, Y+4	; 0x04
    1e54:	2d 81       	ldd	r18, Y+5	; 0x05
    1e56:	3e 81       	ldd	r19, Y+6	; 0x06
    1e58:	b9 01       	movw	r22, r18
    1e5a:	49 85       	ldd	r20, Y+9	; 0x09
    1e5c:	0e 94 ab 10 	call	0x2156	; 0x2156 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e60:	eb 81       	ldd	r30, Y+3	; 0x03
    1e62:	fc 81       	ldd	r31, Y+4	; 0x04
    1e64:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e66:	8f 3f       	cpi	r24, 0xFF	; 255
    1e68:	89 f4       	brne	.+34     	; 0x1e8c <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e6e:	81 89       	ldd	r24, Z+17	; 0x11
    1e70:	88 23       	and	r24, r24
    1e72:	99 f0       	breq	.+38     	; 0x1e9a <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e74:	8b 81       	ldd	r24, Y+3	; 0x03
    1e76:	9c 81       	ldd	r25, Y+4	; 0x04
    1e78:	41 96       	adiw	r24, 0x11	; 17
    1e7a:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskRemoveFromEventList>
    1e7e:	88 23       	and	r24, r24
    1e80:	61 f0       	breq	.+24     	; 0x1e9a <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1e82:	ef 81       	ldd	r30, Y+7	; 0x07
    1e84:	f8 85       	ldd	r31, Y+8	; 0x08
    1e86:	81 e0       	ldi	r24, 0x01	; 1
    1e88:	80 83       	st	Z, r24
    1e8a:	07 c0       	rjmp	.+14     	; 0x1e9a <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e90:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e92:	8f 5f       	subi	r24, 0xFF	; 255
    1e94:	eb 81       	ldd	r30, Y+3	; 0x03
    1e96:	fc 81       	ldd	r31, Y+4	; 0x04
    1e98:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e9a:	81 e0       	ldi	r24, 0x01	; 1
    1e9c:	8a 83       	std	Y+2, r24	; 0x02
    1e9e:	01 c0       	rjmp	.+2      	; 0x1ea2 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ea0:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ea2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1ea4:	29 96       	adiw	r28, 0x09	; 9
    1ea6:	0f b6       	in	r0, 0x3f	; 63
    1ea8:	f8 94       	cli
    1eaa:	de bf       	out	0x3e, r29	; 62
    1eac:	0f be       	out	0x3f, r0	; 63
    1eae:	cd bf       	out	0x3d, r28	; 61
    1eb0:	cf 91       	pop	r28
    1eb2:	df 91       	pop	r29
    1eb4:	08 95       	ret

00001eb6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1eb6:	df 93       	push	r29
    1eb8:	cf 93       	push	r28
    1eba:	cd b7       	in	r28, 0x3d	; 61
    1ebc:	de b7       	in	r29, 0x3e	; 62
    1ebe:	2e 97       	sbiw	r28, 0x0e	; 14
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	de bf       	out	0x3e, r29	; 62
    1ec6:	0f be       	out	0x3f, r0	; 63
    1ec8:	cd bf       	out	0x3d, r28	; 61
    1eca:	98 87       	std	Y+8, r25	; 0x08
    1ecc:	8f 83       	std	Y+7, r24	; 0x07
    1ece:	7a 87       	std	Y+10, r23	; 0x0a
    1ed0:	69 87       	std	Y+9, r22	; 0x09
    1ed2:	5c 87       	std	Y+12, r21	; 0x0c
    1ed4:	4b 87       	std	Y+11, r20	; 0x0b
    1ed6:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1ed8:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1eda:	0f b6       	in	r0, 0x3f	; 63
    1edc:	f8 94       	cli
    1ede:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1ee0:	ef 81       	ldd	r30, Y+7	; 0x07
    1ee2:	f8 85       	ldd	r31, Y+8	; 0x08
    1ee4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ee6:	88 23       	and	r24, r24
    1ee8:	09 f4       	brne	.+2      	; 0x1eec <xQueueGenericReceive+0x36>
    1eea:	3f c0       	rjmp	.+126    	; 0x1f6a <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1eec:	ef 81       	ldd	r30, Y+7	; 0x07
    1eee:	f8 85       	ldd	r31, Y+8	; 0x08
    1ef0:	86 81       	ldd	r24, Z+6	; 0x06
    1ef2:	97 81       	ldd	r25, Z+7	; 0x07
    1ef4:	9a 83       	std	Y+2, r25	; 0x02
    1ef6:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ef8:	8f 81       	ldd	r24, Y+7	; 0x07
    1efa:	98 85       	ldd	r25, Y+8	; 0x08
    1efc:	29 85       	ldd	r18, Y+9	; 0x09
    1efe:	3a 85       	ldd	r19, Y+10	; 0x0a
    1f00:	b9 01       	movw	r22, r18
    1f02:	0e 94 40 11 	call	0x2280	; 0x2280 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1f06:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f08:	88 23       	and	r24, r24
    1f0a:	b1 f4       	brne	.+44     	; 0x1f38 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1f0c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f0e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f10:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f12:	81 50       	subi	r24, 0x01	; 1
    1f14:	ef 81       	ldd	r30, Y+7	; 0x07
    1f16:	f8 85       	ldd	r31, Y+8	; 0x08
    1f18:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f1a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f1c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f1e:	80 85       	ldd	r24, Z+8	; 0x08
    1f20:	88 23       	and	r24, r24
    1f22:	f1 f0       	breq	.+60     	; 0x1f60 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1f24:	8f 81       	ldd	r24, Y+7	; 0x07
    1f26:	98 85       	ldd	r25, Y+8	; 0x08
    1f28:	08 96       	adiw	r24, 0x08	; 8
    1f2a:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskRemoveFromEventList>
    1f2e:	81 30       	cpi	r24, 0x01	; 1
    1f30:	b9 f4       	brne	.+46     	; 0x1f60 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1f32:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
    1f36:	14 c0       	rjmp	.+40     	; 0x1f60 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1f38:	ef 81       	ldd	r30, Y+7	; 0x07
    1f3a:	f8 85       	ldd	r31, Y+8	; 0x08
    1f3c:	89 81       	ldd	r24, Y+1	; 0x01
    1f3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f40:	97 83       	std	Z+7, r25	; 0x07
    1f42:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f44:	ef 81       	ldd	r30, Y+7	; 0x07
    1f46:	f8 85       	ldd	r31, Y+8	; 0x08
    1f48:	81 89       	ldd	r24, Z+17	; 0x11
    1f4a:	88 23       	and	r24, r24
    1f4c:	49 f0       	breq	.+18     	; 0x1f60 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f4e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f50:	98 85       	ldd	r25, Y+8	; 0x08
    1f52:	41 96       	adiw	r24, 0x11	; 17
    1f54:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskRemoveFromEventList>
    1f58:	88 23       	and	r24, r24
    1f5a:	11 f0       	breq	.+4      	; 0x1f60 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1f5c:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1f60:	0f 90       	pop	r0
    1f62:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	8e 87       	std	Y+14, r24	; 0x0e
    1f68:	5c c0       	rjmp	.+184    	; 0x2022 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1f6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f6c:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f6e:	00 97       	sbiw	r24, 0x00	; 0
    1f70:	21 f4       	brne	.+8      	; 0x1f7a <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f72:	0f 90       	pop	r0
    1f74:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f76:	1e 86       	std	Y+14, r1	; 0x0e
    1f78:	54 c0       	rjmp	.+168    	; 0x2022 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7c:	88 23       	and	r24, r24
    1f7e:	31 f4       	brne	.+12     	; 0x1f8c <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f80:	ce 01       	movw	r24, r28
    1f82:	04 96       	adiw	r24, 0x04	; 4
    1f84:	0e 94 9a 18 	call	0x3134	; 0x3134 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f88:	81 e0       	ldi	r24, 0x01	; 1
    1f8a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1f8c:	0f 90       	pop	r0
    1f8e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f90:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f94:	0f b6       	in	r0, 0x3f	; 63
    1f96:	f8 94       	cli
    1f98:	0f 92       	push	r0
    1f9a:	ef 81       	ldd	r30, Y+7	; 0x07
    1f9c:	f8 85       	ldd	r31, Y+8	; 0x08
    1f9e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fa0:	8f 3f       	cpi	r24, 0xFF	; 255
    1fa2:	19 f4       	brne	.+6      	; 0x1faa <xQueueGenericReceive+0xf4>
    1fa4:	ef 81       	ldd	r30, Y+7	; 0x07
    1fa6:	f8 85       	ldd	r31, Y+8	; 0x08
    1fa8:	15 8e       	std	Z+29, r1	; 0x1d
    1faa:	ef 81       	ldd	r30, Y+7	; 0x07
    1fac:	f8 85       	ldd	r31, Y+8	; 0x08
    1fae:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fb0:	8f 3f       	cpi	r24, 0xFF	; 255
    1fb2:	19 f4       	brne	.+6      	; 0x1fba <xQueueGenericReceive+0x104>
    1fb4:	ef 81       	ldd	r30, Y+7	; 0x07
    1fb6:	f8 85       	ldd	r31, Y+8	; 0x08
    1fb8:	16 8e       	std	Z+30, r1	; 0x1e
    1fba:	0f 90       	pop	r0
    1fbc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fbe:	ce 01       	movw	r24, r28
    1fc0:	04 96       	adiw	r24, 0x04	; 4
    1fc2:	9e 01       	movw	r18, r28
    1fc4:	25 5f       	subi	r18, 0xF5	; 245
    1fc6:	3f 4f       	sbci	r19, 0xFF	; 255
    1fc8:	b9 01       	movw	r22, r18
    1fca:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskCheckForTimeOut>
    1fce:	88 23       	and	r24, r24
    1fd0:	09 f5       	brne	.+66     	; 0x2014 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fd2:	8f 81       	ldd	r24, Y+7	; 0x07
    1fd4:	98 85       	ldd	r25, Y+8	; 0x08
    1fd6:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <prvIsQueueEmpty>
    1fda:	88 23       	and	r24, r24
    1fdc:	a1 f0       	breq	.+40     	; 0x2006 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fde:	8f 81       	ldd	r24, Y+7	; 0x07
    1fe0:	98 85       	ldd	r25, Y+8	; 0x08
    1fe2:	41 96       	adiw	r24, 0x11	; 17
    1fe4:	2b 85       	ldd	r18, Y+11	; 0x0b
    1fe6:	3c 85       	ldd	r19, Y+12	; 0x0c
    1fe8:	b9 01       	movw	r22, r18
    1fea:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1fee:	8f 81       	ldd	r24, Y+7	; 0x07
    1ff0:	98 85       	ldd	r25, Y+8	; 0x08
    1ff2:	0e 94 88 11 	call	0x2310	; 0x2310 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ff6:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
    1ffa:	88 23       	and	r24, r24
    1ffc:	09 f0       	breq	.+2      	; 0x2000 <xQueueGenericReceive+0x14a>
    1ffe:	6d cf       	rjmp	.-294    	; 0x1eda <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    2000:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
    2004:	6a cf       	rjmp	.-300    	; 0x1eda <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2006:	8f 81       	ldd	r24, Y+7	; 0x07
    2008:	98 85       	ldd	r25, Y+8	; 0x08
    200a:	0e 94 88 11 	call	0x2310	; 0x2310 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    200e:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
    2012:	63 cf       	rjmp	.-314    	; 0x1eda <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2014:	8f 81       	ldd	r24, Y+7	; 0x07
    2016:	98 85       	ldd	r25, Y+8	; 0x08
    2018:	0e 94 88 11 	call	0x2310	; 0x2310 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    201c:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2020:	1e 86       	std	Y+14, r1	; 0x0e
    2022:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    2024:	2e 96       	adiw	r28, 0x0e	; 14
    2026:	0f b6       	in	r0, 0x3f	; 63
    2028:	f8 94       	cli
    202a:	de bf       	out	0x3e, r29	; 62
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	cd bf       	out	0x3d, r28	; 61
    2030:	cf 91       	pop	r28
    2032:	df 91       	pop	r29
    2034:	08 95       	ret

00002036 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2036:	df 93       	push	r29
    2038:	cf 93       	push	r28
    203a:	cd b7       	in	r28, 0x3d	; 61
    203c:	de b7       	in	r29, 0x3e	; 62
    203e:	28 97       	sbiw	r28, 0x08	; 8
    2040:	0f b6       	in	r0, 0x3f	; 63
    2042:	f8 94       	cli
    2044:	de bf       	out	0x3e, r29	; 62
    2046:	0f be       	out	0x3f, r0	; 63
    2048:	cd bf       	out	0x3d, r28	; 61
    204a:	9c 83       	std	Y+4, r25	; 0x04
    204c:	8b 83       	std	Y+3, r24	; 0x03
    204e:	7e 83       	std	Y+6, r23	; 0x06
    2050:	6d 83       	std	Y+5, r22	; 0x05
    2052:	58 87       	std	Y+8, r21	; 0x08
    2054:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2056:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2058:	eb 81       	ldd	r30, Y+3	; 0x03
    205a:	fc 81       	ldd	r31, Y+4	; 0x04
    205c:	82 8d       	ldd	r24, Z+26	; 0x1a
    205e:	88 23       	and	r24, r24
    2060:	71 f1       	breq	.+92     	; 0x20be <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2062:	8b 81       	ldd	r24, Y+3	; 0x03
    2064:	9c 81       	ldd	r25, Y+4	; 0x04
    2066:	2d 81       	ldd	r18, Y+5	; 0x05
    2068:	3e 81       	ldd	r19, Y+6	; 0x06
    206a:	b9 01       	movw	r22, r18
    206c:	0e 94 40 11 	call	0x2280	; 0x2280 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2070:	eb 81       	ldd	r30, Y+3	; 0x03
    2072:	fc 81       	ldd	r31, Y+4	; 0x04
    2074:	82 8d       	ldd	r24, Z+26	; 0x1a
    2076:	81 50       	subi	r24, 0x01	; 1
    2078:	eb 81       	ldd	r30, Y+3	; 0x03
    207a:	fc 81       	ldd	r31, Y+4	; 0x04
    207c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    207e:	eb 81       	ldd	r30, Y+3	; 0x03
    2080:	fc 81       	ldd	r31, Y+4	; 0x04
    2082:	85 8d       	ldd	r24, Z+29	; 0x1d
    2084:	8f 3f       	cpi	r24, 0xFF	; 255
    2086:	89 f4       	brne	.+34     	; 0x20aa <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2088:	eb 81       	ldd	r30, Y+3	; 0x03
    208a:	fc 81       	ldd	r31, Y+4	; 0x04
    208c:	80 85       	ldd	r24, Z+8	; 0x08
    208e:	88 23       	and	r24, r24
    2090:	99 f0       	breq	.+38     	; 0x20b8 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2092:	8b 81       	ldd	r24, Y+3	; 0x03
    2094:	9c 81       	ldd	r25, Y+4	; 0x04
    2096:	08 96       	adiw	r24, 0x08	; 8
    2098:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskRemoveFromEventList>
    209c:	88 23       	and	r24, r24
    209e:	61 f0       	breq	.+24     	; 0x20b8 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    20a0:	ef 81       	ldd	r30, Y+7	; 0x07
    20a2:	f8 85       	ldd	r31, Y+8	; 0x08
    20a4:	81 e0       	ldi	r24, 0x01	; 1
    20a6:	80 83       	st	Z, r24
    20a8:	07 c0       	rjmp	.+14     	; 0x20b8 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    20aa:	eb 81       	ldd	r30, Y+3	; 0x03
    20ac:	fc 81       	ldd	r31, Y+4	; 0x04
    20ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    20b0:	8f 5f       	subi	r24, 0xFF	; 255
    20b2:	eb 81       	ldd	r30, Y+3	; 0x03
    20b4:	fc 81       	ldd	r31, Y+4	; 0x04
    20b6:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	8a 83       	std	Y+2, r24	; 0x02
    20bc:	01 c0       	rjmp	.+2      	; 0x20c0 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    20be:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    20c0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    20c2:	28 96       	adiw	r28, 0x08	; 8
    20c4:	0f b6       	in	r0, 0x3f	; 63
    20c6:	f8 94       	cli
    20c8:	de bf       	out	0x3e, r29	; 62
    20ca:	0f be       	out	0x3f, r0	; 63
    20cc:	cd bf       	out	0x3d, r28	; 61
    20ce:	cf 91       	pop	r28
    20d0:	df 91       	pop	r29
    20d2:	08 95       	ret

000020d4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    20d4:	df 93       	push	r29
    20d6:	cf 93       	push	r28
    20d8:	00 d0       	rcall	.+0      	; 0x20da <uxQueueMessagesWaiting+0x6>
    20da:	0f 92       	push	r0
    20dc:	cd b7       	in	r28, 0x3d	; 61
    20de:	de b7       	in	r29, 0x3e	; 62
    20e0:	9b 83       	std	Y+3, r25	; 0x03
    20e2:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    20e4:	0f b6       	in	r0, 0x3f	; 63
    20e6:	f8 94       	cli
    20e8:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    20ea:	ea 81       	ldd	r30, Y+2	; 0x02
    20ec:	fb 81       	ldd	r31, Y+3	; 0x03
    20ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    20f0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    20f2:	0f 90       	pop	r0
    20f4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    20f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    20f8:	0f 90       	pop	r0
    20fa:	0f 90       	pop	r0
    20fc:	0f 90       	pop	r0
    20fe:	cf 91       	pop	r28
    2100:	df 91       	pop	r29
    2102:	08 95       	ret

00002104 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2104:	df 93       	push	r29
    2106:	cf 93       	push	r28
    2108:	00 d0       	rcall	.+0      	; 0x210a <uxQueueMessagesWaitingFromISR+0x6>
    210a:	0f 92       	push	r0
    210c:	cd b7       	in	r28, 0x3d	; 61
    210e:	de b7       	in	r29, 0x3e	; 62
    2110:	9b 83       	std	Y+3, r25	; 0x03
    2112:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2114:	ea 81       	ldd	r30, Y+2	; 0x02
    2116:	fb 81       	ldd	r31, Y+3	; 0x03
    2118:	82 8d       	ldd	r24, Z+26	; 0x1a
    211a:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    211c:	89 81       	ldd	r24, Y+1	; 0x01
}
    211e:	0f 90       	pop	r0
    2120:	0f 90       	pop	r0
    2122:	0f 90       	pop	r0
    2124:	cf 91       	pop	r28
    2126:	df 91       	pop	r29
    2128:	08 95       	ret

0000212a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    212a:	df 93       	push	r29
    212c:	cf 93       	push	r28
    212e:	00 d0       	rcall	.+0      	; 0x2130 <vQueueDelete+0x6>
    2130:	cd b7       	in	r28, 0x3d	; 61
    2132:	de b7       	in	r29, 0x3e	; 62
    2134:	9a 83       	std	Y+2, r25	; 0x02
    2136:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2138:	e9 81       	ldd	r30, Y+1	; 0x01
    213a:	fa 81       	ldd	r31, Y+2	; 0x02
    213c:	80 81       	ld	r24, Z
    213e:	91 81       	ldd	r25, Z+1	; 0x01
    2140:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
	vPortFree( pxQueue );
    2144:	89 81       	ldd	r24, Y+1	; 0x01
    2146:	9a 81       	ldd	r25, Y+2	; 0x02
    2148:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
}
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	cf 91       	pop	r28
    2152:	df 91       	pop	r29
    2154:	08 95       	ret

00002156 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2156:	df 93       	push	r29
    2158:	cf 93       	push	r28
    215a:	00 d0       	rcall	.+0      	; 0x215c <prvCopyDataToQueue+0x6>
    215c:	00 d0       	rcall	.+0      	; 0x215e <prvCopyDataToQueue+0x8>
    215e:	0f 92       	push	r0
    2160:	cd b7       	in	r28, 0x3d	; 61
    2162:	de b7       	in	r29, 0x3e	; 62
    2164:	9a 83       	std	Y+2, r25	; 0x02
    2166:	89 83       	std	Y+1, r24	; 0x01
    2168:	7c 83       	std	Y+4, r23	; 0x04
    216a:	6b 83       	std	Y+3, r22	; 0x03
    216c:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    216e:	e9 81       	ldd	r30, Y+1	; 0x01
    2170:	fa 81       	ldd	r31, Y+2	; 0x02
    2172:	84 8d       	ldd	r24, Z+28	; 0x1c
    2174:	88 23       	and	r24, r24
    2176:	09 f4       	brne	.+2      	; 0x217a <prvCopyDataToQueue+0x24>
    2178:	74 c0       	rjmp	.+232    	; 0x2262 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    217a:	8d 81       	ldd	r24, Y+5	; 0x05
    217c:	88 23       	and	r24, r24
    217e:	99 f5       	brne	.+102    	; 0x21e6 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2180:	e9 81       	ldd	r30, Y+1	; 0x01
    2182:	fa 81       	ldd	r31, Y+2	; 0x02
    2184:	64 81       	ldd	r22, Z+4	; 0x04
    2186:	75 81       	ldd	r23, Z+5	; 0x05
    2188:	e9 81       	ldd	r30, Y+1	; 0x01
    218a:	fa 81       	ldd	r31, Y+2	; 0x02
    218c:	84 8d       	ldd	r24, Z+28	; 0x1c
    218e:	48 2f       	mov	r20, r24
    2190:	50 e0       	ldi	r21, 0x00	; 0
    2192:	2b 81       	ldd	r18, Y+3	; 0x03
    2194:	3c 81       	ldd	r19, Y+4	; 0x04
    2196:	cb 01       	movw	r24, r22
    2198:	b9 01       	movw	r22, r18
    219a:	0e 94 b3 1a 	call	0x3566	; 0x3566 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    219e:	e9 81       	ldd	r30, Y+1	; 0x01
    21a0:	fa 81       	ldd	r31, Y+2	; 0x02
    21a2:	24 81       	ldd	r18, Z+4	; 0x04
    21a4:	35 81       	ldd	r19, Z+5	; 0x05
    21a6:	e9 81       	ldd	r30, Y+1	; 0x01
    21a8:	fa 81       	ldd	r31, Y+2	; 0x02
    21aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    21ac:	88 2f       	mov	r24, r24
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	82 0f       	add	r24, r18
    21b2:	93 1f       	adc	r25, r19
    21b4:	e9 81       	ldd	r30, Y+1	; 0x01
    21b6:	fa 81       	ldd	r31, Y+2	; 0x02
    21b8:	95 83       	std	Z+5, r25	; 0x05
    21ba:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    21bc:	e9 81       	ldd	r30, Y+1	; 0x01
    21be:	fa 81       	ldd	r31, Y+2	; 0x02
    21c0:	24 81       	ldd	r18, Z+4	; 0x04
    21c2:	35 81       	ldd	r19, Z+5	; 0x05
    21c4:	e9 81       	ldd	r30, Y+1	; 0x01
    21c6:	fa 81       	ldd	r31, Y+2	; 0x02
    21c8:	82 81       	ldd	r24, Z+2	; 0x02
    21ca:	93 81       	ldd	r25, Z+3	; 0x03
    21cc:	28 17       	cp	r18, r24
    21ce:	39 07       	cpc	r19, r25
    21d0:	08 f4       	brcc	.+2      	; 0x21d4 <prvCopyDataToQueue+0x7e>
    21d2:	47 c0       	rjmp	.+142    	; 0x2262 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    21d4:	e9 81       	ldd	r30, Y+1	; 0x01
    21d6:	fa 81       	ldd	r31, Y+2	; 0x02
    21d8:	80 81       	ld	r24, Z
    21da:	91 81       	ldd	r25, Z+1	; 0x01
    21dc:	e9 81       	ldd	r30, Y+1	; 0x01
    21de:	fa 81       	ldd	r31, Y+2	; 0x02
    21e0:	95 83       	std	Z+5, r25	; 0x05
    21e2:	84 83       	std	Z+4, r24	; 0x04
    21e4:	3e c0       	rjmp	.+124    	; 0x2262 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    21e6:	e9 81       	ldd	r30, Y+1	; 0x01
    21e8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ea:	66 81       	ldd	r22, Z+6	; 0x06
    21ec:	77 81       	ldd	r23, Z+7	; 0x07
    21ee:	e9 81       	ldd	r30, Y+1	; 0x01
    21f0:	fa 81       	ldd	r31, Y+2	; 0x02
    21f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    21f4:	48 2f       	mov	r20, r24
    21f6:	50 e0       	ldi	r21, 0x00	; 0
    21f8:	2b 81       	ldd	r18, Y+3	; 0x03
    21fa:	3c 81       	ldd	r19, Y+4	; 0x04
    21fc:	cb 01       	movw	r24, r22
    21fe:	b9 01       	movw	r22, r18
    2200:	0e 94 b3 1a 	call	0x3566	; 0x3566 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2204:	e9 81       	ldd	r30, Y+1	; 0x01
    2206:	fa 81       	ldd	r31, Y+2	; 0x02
    2208:	26 81       	ldd	r18, Z+6	; 0x06
    220a:	37 81       	ldd	r19, Z+7	; 0x07
    220c:	e9 81       	ldd	r30, Y+1	; 0x01
    220e:	fa 81       	ldd	r31, Y+2	; 0x02
    2210:	84 8d       	ldd	r24, Z+28	; 0x1c
    2212:	88 2f       	mov	r24, r24
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	90 95       	com	r25
    2218:	81 95       	neg	r24
    221a:	9f 4f       	sbci	r25, 0xFF	; 255
    221c:	82 0f       	add	r24, r18
    221e:	93 1f       	adc	r25, r19
    2220:	e9 81       	ldd	r30, Y+1	; 0x01
    2222:	fa 81       	ldd	r31, Y+2	; 0x02
    2224:	97 83       	std	Z+7, r25	; 0x07
    2226:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2228:	e9 81       	ldd	r30, Y+1	; 0x01
    222a:	fa 81       	ldd	r31, Y+2	; 0x02
    222c:	26 81       	ldd	r18, Z+6	; 0x06
    222e:	37 81       	ldd	r19, Z+7	; 0x07
    2230:	e9 81       	ldd	r30, Y+1	; 0x01
    2232:	fa 81       	ldd	r31, Y+2	; 0x02
    2234:	80 81       	ld	r24, Z
    2236:	91 81       	ldd	r25, Z+1	; 0x01
    2238:	28 17       	cp	r18, r24
    223a:	39 07       	cpc	r19, r25
    223c:	90 f4       	brcc	.+36     	; 0x2262 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    223e:	e9 81       	ldd	r30, Y+1	; 0x01
    2240:	fa 81       	ldd	r31, Y+2	; 0x02
    2242:	22 81       	ldd	r18, Z+2	; 0x02
    2244:	33 81       	ldd	r19, Z+3	; 0x03
    2246:	e9 81       	ldd	r30, Y+1	; 0x01
    2248:	fa 81       	ldd	r31, Y+2	; 0x02
    224a:	84 8d       	ldd	r24, Z+28	; 0x1c
    224c:	88 2f       	mov	r24, r24
    224e:	90 e0       	ldi	r25, 0x00	; 0
    2250:	90 95       	com	r25
    2252:	81 95       	neg	r24
    2254:	9f 4f       	sbci	r25, 0xFF	; 255
    2256:	82 0f       	add	r24, r18
    2258:	93 1f       	adc	r25, r19
    225a:	e9 81       	ldd	r30, Y+1	; 0x01
    225c:	fa 81       	ldd	r31, Y+2	; 0x02
    225e:	97 83       	std	Z+7, r25	; 0x07
    2260:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2262:	e9 81       	ldd	r30, Y+1	; 0x01
    2264:	fa 81       	ldd	r31, Y+2	; 0x02
    2266:	82 8d       	ldd	r24, Z+26	; 0x1a
    2268:	8f 5f       	subi	r24, 0xFF	; 255
    226a:	e9 81       	ldd	r30, Y+1	; 0x01
    226c:	fa 81       	ldd	r31, Y+2	; 0x02
    226e:	82 8f       	std	Z+26, r24	; 0x1a
}
    2270:	0f 90       	pop	r0
    2272:	0f 90       	pop	r0
    2274:	0f 90       	pop	r0
    2276:	0f 90       	pop	r0
    2278:	0f 90       	pop	r0
    227a:	cf 91       	pop	r28
    227c:	df 91       	pop	r29
    227e:	08 95       	ret

00002280 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2280:	df 93       	push	r29
    2282:	cf 93       	push	r28
    2284:	00 d0       	rcall	.+0      	; 0x2286 <prvCopyDataFromQueue+0x6>
    2286:	00 d0       	rcall	.+0      	; 0x2288 <prvCopyDataFromQueue+0x8>
    2288:	cd b7       	in	r28, 0x3d	; 61
    228a:	de b7       	in	r29, 0x3e	; 62
    228c:	9a 83       	std	Y+2, r25	; 0x02
    228e:	89 83       	std	Y+1, r24	; 0x01
    2290:	7c 83       	std	Y+4, r23	; 0x04
    2292:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2294:	e9 81       	ldd	r30, Y+1	; 0x01
    2296:	fa 81       	ldd	r31, Y+2	; 0x02
    2298:	80 81       	ld	r24, Z
    229a:	91 81       	ldd	r25, Z+1	; 0x01
    229c:	00 97       	sbiw	r24, 0x00	; 0
    229e:	89 f1       	breq	.+98     	; 0x2302 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    22a0:	e9 81       	ldd	r30, Y+1	; 0x01
    22a2:	fa 81       	ldd	r31, Y+2	; 0x02
    22a4:	26 81       	ldd	r18, Z+6	; 0x06
    22a6:	37 81       	ldd	r19, Z+7	; 0x07
    22a8:	e9 81       	ldd	r30, Y+1	; 0x01
    22aa:	fa 81       	ldd	r31, Y+2	; 0x02
    22ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    22ae:	88 2f       	mov	r24, r24
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	82 0f       	add	r24, r18
    22b4:	93 1f       	adc	r25, r19
    22b6:	e9 81       	ldd	r30, Y+1	; 0x01
    22b8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ba:	97 83       	std	Z+7, r25	; 0x07
    22bc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    22be:	e9 81       	ldd	r30, Y+1	; 0x01
    22c0:	fa 81       	ldd	r31, Y+2	; 0x02
    22c2:	26 81       	ldd	r18, Z+6	; 0x06
    22c4:	37 81       	ldd	r19, Z+7	; 0x07
    22c6:	e9 81       	ldd	r30, Y+1	; 0x01
    22c8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ca:	82 81       	ldd	r24, Z+2	; 0x02
    22cc:	93 81       	ldd	r25, Z+3	; 0x03
    22ce:	28 17       	cp	r18, r24
    22d0:	39 07       	cpc	r19, r25
    22d2:	40 f0       	brcs	.+16     	; 0x22e4 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    22d4:	e9 81       	ldd	r30, Y+1	; 0x01
    22d6:	fa 81       	ldd	r31, Y+2	; 0x02
    22d8:	80 81       	ld	r24, Z
    22da:	91 81       	ldd	r25, Z+1	; 0x01
    22dc:	e9 81       	ldd	r30, Y+1	; 0x01
    22de:	fa 81       	ldd	r31, Y+2	; 0x02
    22e0:	97 83       	std	Z+7, r25	; 0x07
    22e2:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    22e4:	e9 81       	ldd	r30, Y+1	; 0x01
    22e6:	fa 81       	ldd	r31, Y+2	; 0x02
    22e8:	46 81       	ldd	r20, Z+6	; 0x06
    22ea:	57 81       	ldd	r21, Z+7	; 0x07
    22ec:	e9 81       	ldd	r30, Y+1	; 0x01
    22ee:	fa 81       	ldd	r31, Y+2	; 0x02
    22f0:	84 8d       	ldd	r24, Z+28	; 0x1c
    22f2:	28 2f       	mov	r18, r24
    22f4:	30 e0       	ldi	r19, 0x00	; 0
    22f6:	8b 81       	ldd	r24, Y+3	; 0x03
    22f8:	9c 81       	ldd	r25, Y+4	; 0x04
    22fa:	ba 01       	movw	r22, r20
    22fc:	a9 01       	movw	r20, r18
    22fe:	0e 94 b3 1a 	call	0x3566	; 0x3566 <memcpy>
	}
}
    2302:	0f 90       	pop	r0
    2304:	0f 90       	pop	r0
    2306:	0f 90       	pop	r0
    2308:	0f 90       	pop	r0
    230a:	cf 91       	pop	r28
    230c:	df 91       	pop	r29
    230e:	08 95       	ret

00002310 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    2310:	df 93       	push	r29
    2312:	cf 93       	push	r28
    2314:	00 d0       	rcall	.+0      	; 0x2316 <prvUnlockQueue+0x6>
    2316:	cd b7       	in	r28, 0x3d	; 61
    2318:	de b7       	in	r29, 0x3e	; 62
    231a:	9a 83       	std	Y+2, r25	; 0x02
    231c:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	f8 94       	cli
    2322:	0f 92       	push	r0
    2324:	15 c0       	rjmp	.+42     	; 0x2350 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2326:	e9 81       	ldd	r30, Y+1	; 0x01
    2328:	fa 81       	ldd	r31, Y+2	; 0x02
    232a:	81 89       	ldd	r24, Z+17	; 0x11
    232c:	88 23       	and	r24, r24
    232e:	a9 f0       	breq	.+42     	; 0x235a <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2330:	89 81       	ldd	r24, Y+1	; 0x01
    2332:	9a 81       	ldd	r25, Y+2	; 0x02
    2334:	41 96       	adiw	r24, 0x11	; 17
    2336:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskRemoveFromEventList>
    233a:	88 23       	and	r24, r24
    233c:	11 f0       	breq	.+4      	; 0x2342 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    233e:	0e 94 1a 19 	call	0x3234	; 0x3234 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    2342:	e9 81       	ldd	r30, Y+1	; 0x01
    2344:	fa 81       	ldd	r31, Y+2	; 0x02
    2346:	86 8d       	ldd	r24, Z+30	; 0x1e
    2348:	81 50       	subi	r24, 0x01	; 1
    234a:	e9 81       	ldd	r30, Y+1	; 0x01
    234c:	fa 81       	ldd	r31, Y+2	; 0x02
    234e:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2350:	e9 81       	ldd	r30, Y+1	; 0x01
    2352:	fa 81       	ldd	r31, Y+2	; 0x02
    2354:	86 8d       	ldd	r24, Z+30	; 0x1e
    2356:	18 16       	cp	r1, r24
    2358:	34 f3       	brlt	.-52     	; 0x2326 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    235a:	e9 81       	ldd	r30, Y+1	; 0x01
    235c:	fa 81       	ldd	r31, Y+2	; 0x02
    235e:	8f ef       	ldi	r24, 0xFF	; 255
    2360:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2362:	0f 90       	pop	r0
    2364:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2366:	0f b6       	in	r0, 0x3f	; 63
    2368:	f8 94       	cli
    236a:	0f 92       	push	r0
    236c:	15 c0       	rjmp	.+42     	; 0x2398 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    236e:	e9 81       	ldd	r30, Y+1	; 0x01
    2370:	fa 81       	ldd	r31, Y+2	; 0x02
    2372:	80 85       	ldd	r24, Z+8	; 0x08
    2374:	88 23       	and	r24, r24
    2376:	a9 f0       	breq	.+42     	; 0x23a2 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	9a 81       	ldd	r25, Y+2	; 0x02
    237c:	08 96       	adiw	r24, 0x08	; 8
    237e:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskRemoveFromEventList>
    2382:	88 23       	and	r24, r24
    2384:	11 f0       	breq	.+4      	; 0x238a <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2386:	0e 94 1a 19 	call	0x3234	; 0x3234 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    238a:	e9 81       	ldd	r30, Y+1	; 0x01
    238c:	fa 81       	ldd	r31, Y+2	; 0x02
    238e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2390:	81 50       	subi	r24, 0x01	; 1
    2392:	e9 81       	ldd	r30, Y+1	; 0x01
    2394:	fa 81       	ldd	r31, Y+2	; 0x02
    2396:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2398:	e9 81       	ldd	r30, Y+1	; 0x01
    239a:	fa 81       	ldd	r31, Y+2	; 0x02
    239c:	85 8d       	ldd	r24, Z+29	; 0x1d
    239e:	18 16       	cp	r1, r24
    23a0:	34 f3       	brlt	.-52     	; 0x236e <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    23a2:	e9 81       	ldd	r30, Y+1	; 0x01
    23a4:	fa 81       	ldd	r31, Y+2	; 0x02
    23a6:	8f ef       	ldi	r24, 0xFF	; 255
    23a8:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    23aa:	0f 90       	pop	r0
    23ac:	0f be       	out	0x3f, r0	; 63
}
    23ae:	0f 90       	pop	r0
    23b0:	0f 90       	pop	r0
    23b2:	cf 91       	pop	r28
    23b4:	df 91       	pop	r29
    23b6:	08 95       	ret

000023b8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    23b8:	df 93       	push	r29
    23ba:	cf 93       	push	r28
    23bc:	00 d0       	rcall	.+0      	; 0x23be <prvIsQueueEmpty+0x6>
    23be:	0f 92       	push	r0
    23c0:	cd b7       	in	r28, 0x3d	; 61
    23c2:	de b7       	in	r29, 0x3e	; 62
    23c4:	9b 83       	std	Y+3, r25	; 0x03
    23c6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23c8:	0f b6       	in	r0, 0x3f	; 63
    23ca:	f8 94       	cli
    23cc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    23ce:	ea 81       	ldd	r30, Y+2	; 0x02
    23d0:	fb 81       	ldd	r31, Y+3	; 0x03
    23d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    23d4:	19 82       	std	Y+1, r1	; 0x01
    23d6:	88 23       	and	r24, r24
    23d8:	11 f4       	brne	.+4      	; 0x23de <prvIsQueueEmpty+0x26>
    23da:	81 e0       	ldi	r24, 0x01	; 1
    23dc:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23de:	0f 90       	pop	r0
    23e0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23e2:	89 81       	ldd	r24, Y+1	; 0x01
}
    23e4:	0f 90       	pop	r0
    23e6:	0f 90       	pop	r0
    23e8:	0f 90       	pop	r0
    23ea:	cf 91       	pop	r28
    23ec:	df 91       	pop	r29
    23ee:	08 95       	ret

000023f0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    23f0:	df 93       	push	r29
    23f2:	cf 93       	push	r28
    23f4:	00 d0       	rcall	.+0      	; 0x23f6 <xQueueIsQueueEmptyFromISR+0x6>
    23f6:	0f 92       	push	r0
    23f8:	cd b7       	in	r28, 0x3d	; 61
    23fa:	de b7       	in	r29, 0x3e	; 62
    23fc:	9b 83       	std	Y+3, r25	; 0x03
    23fe:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2400:	ea 81       	ldd	r30, Y+2	; 0x02
    2402:	fb 81       	ldd	r31, Y+3	; 0x03
    2404:	82 8d       	ldd	r24, Z+26	; 0x1a
    2406:	19 82       	std	Y+1, r1	; 0x01
    2408:	88 23       	and	r24, r24
    240a:	11 f4       	brne	.+4      	; 0x2410 <xQueueIsQueueEmptyFromISR+0x20>
    240c:	81 e0       	ldi	r24, 0x01	; 1
    240e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2410:	89 81       	ldd	r24, Y+1	; 0x01
}
    2412:	0f 90       	pop	r0
    2414:	0f 90       	pop	r0
    2416:	0f 90       	pop	r0
    2418:	cf 91       	pop	r28
    241a:	df 91       	pop	r29
    241c:	08 95       	ret

0000241e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    241e:	df 93       	push	r29
    2420:	cf 93       	push	r28
    2422:	00 d0       	rcall	.+0      	; 0x2424 <prvIsQueueFull+0x6>
    2424:	0f 92       	push	r0
    2426:	cd b7       	in	r28, 0x3d	; 61
    2428:	de b7       	in	r29, 0x3e	; 62
    242a:	9b 83       	std	Y+3, r25	; 0x03
    242c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    242e:	0f b6       	in	r0, 0x3f	; 63
    2430:	f8 94       	cli
    2432:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2434:	ea 81       	ldd	r30, Y+2	; 0x02
    2436:	fb 81       	ldd	r31, Y+3	; 0x03
    2438:	92 8d       	ldd	r25, Z+26	; 0x1a
    243a:	ea 81       	ldd	r30, Y+2	; 0x02
    243c:	fb 81       	ldd	r31, Y+3	; 0x03
    243e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2440:	19 82       	std	Y+1, r1	; 0x01
    2442:	98 17       	cp	r25, r24
    2444:	11 f4       	brne	.+4      	; 0x244a <prvIsQueueFull+0x2c>
    2446:	81 e0       	ldi	r24, 0x01	; 1
    2448:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    244a:	0f 90       	pop	r0
    244c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    244e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2450:	0f 90       	pop	r0
    2452:	0f 90       	pop	r0
    2454:	0f 90       	pop	r0
    2456:	cf 91       	pop	r28
    2458:	df 91       	pop	r29
    245a:	08 95       	ret

0000245c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    245c:	df 93       	push	r29
    245e:	cf 93       	push	r28
    2460:	00 d0       	rcall	.+0      	; 0x2462 <xQueueIsQueueFullFromISR+0x6>
    2462:	0f 92       	push	r0
    2464:	cd b7       	in	r28, 0x3d	; 61
    2466:	de b7       	in	r29, 0x3e	; 62
    2468:	9b 83       	std	Y+3, r25	; 0x03
    246a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    246c:	ea 81       	ldd	r30, Y+2	; 0x02
    246e:	fb 81       	ldd	r31, Y+3	; 0x03
    2470:	92 8d       	ldd	r25, Z+26	; 0x1a
    2472:	ea 81       	ldd	r30, Y+2	; 0x02
    2474:	fb 81       	ldd	r31, Y+3	; 0x03
    2476:	83 8d       	ldd	r24, Z+27	; 0x1b
    2478:	19 82       	std	Y+1, r1	; 0x01
    247a:	98 17       	cp	r25, r24
    247c:	11 f4       	brne	.+4      	; 0x2482 <xQueueIsQueueFullFromISR+0x26>
    247e:	81 e0       	ldi	r24, 0x01	; 1
    2480:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2482:	89 81       	ldd	r24, Y+1	; 0x01
}
    2484:	0f 90       	pop	r0
    2486:	0f 90       	pop	r0
    2488:	0f 90       	pop	r0
    248a:	cf 91       	pop	r28
    248c:	df 91       	pop	r29
    248e:	08 95       	ret

00002490 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2490:	af 92       	push	r10
    2492:	bf 92       	push	r11
    2494:	cf 92       	push	r12
    2496:	df 92       	push	r13
    2498:	ef 92       	push	r14
    249a:	ff 92       	push	r15
    249c:	0f 93       	push	r16
    249e:	1f 93       	push	r17
    24a0:	df 93       	push	r29
    24a2:	cf 93       	push	r28
    24a4:	cd b7       	in	r28, 0x3d	; 61
    24a6:	de b7       	in	r29, 0x3e	; 62
    24a8:	64 97       	sbiw	r28, 0x14	; 20
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	f8 94       	cli
    24ae:	de bf       	out	0x3e, r29	; 62
    24b0:	0f be       	out	0x3f, r0	; 63
    24b2:	cd bf       	out	0x3d, r28	; 61
    24b4:	9f 83       	std	Y+7, r25	; 0x07
    24b6:	8e 83       	std	Y+6, r24	; 0x06
    24b8:	79 87       	std	Y+9, r23	; 0x09
    24ba:	68 87       	std	Y+8, r22	; 0x08
    24bc:	5b 87       	std	Y+11, r21	; 0x0b
    24be:	4a 87       	std	Y+10, r20	; 0x0a
    24c0:	3d 87       	std	Y+13, r19	; 0x0d
    24c2:	2c 87       	std	Y+12, r18	; 0x0c
    24c4:	0e 87       	std	Y+14, r16	; 0x0e
    24c6:	f8 8a       	std	Y+16, r15	; 0x10
    24c8:	ef 86       	std	Y+15, r14	; 0x0f
    24ca:	da 8a       	std	Y+18, r13	; 0x12
    24cc:	c9 8a       	std	Y+17, r12	; 0x11
    24ce:	bc 8a       	std	Y+20, r11	; 0x14
    24d0:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    24d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    24d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    24d6:	29 89       	ldd	r18, Y+17	; 0x11
    24d8:	3a 89       	ldd	r19, Y+18	; 0x12
    24da:	b9 01       	movw	r22, r18
    24dc:	0e 94 4d 1a 	call	0x349a	; 0x349a <prvAllocateTCBAndStack>
    24e0:	9c 83       	std	Y+4, r25	; 0x04
    24e2:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    24e4:	8b 81       	ldd	r24, Y+3	; 0x03
    24e6:	9c 81       	ldd	r25, Y+4	; 0x04
    24e8:	00 97       	sbiw	r24, 0x00	; 0
    24ea:	09 f4       	brne	.+2      	; 0x24ee <xTaskGenericCreate+0x5e>
    24ec:	99 c0       	rjmp	.+306    	; 0x2620 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    24ee:	eb 81       	ldd	r30, Y+3	; 0x03
    24f0:	fc 81       	ldd	r31, Y+4	; 0x04
    24f2:	27 89       	ldd	r18, Z+23	; 0x17
    24f4:	30 8d       	ldd	r19, Z+24	; 0x18
    24f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    24f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    24fa:	01 97       	sbiw	r24, 0x01	; 1
    24fc:	82 0f       	add	r24, r18
    24fe:	93 1f       	adc	r25, r19
    2500:	9a 83       	std	Y+2, r25	; 0x02
    2502:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2504:	8b 81       	ldd	r24, Y+3	; 0x03
    2506:	9c 81       	ldd	r25, Y+4	; 0x04
    2508:	28 85       	ldd	r18, Y+8	; 0x08
    250a:	39 85       	ldd	r19, Y+9	; 0x09
    250c:	eb 89       	ldd	r30, Y+19	; 0x13
    250e:	fc 89       	ldd	r31, Y+20	; 0x14
    2510:	aa 85       	ldd	r26, Y+10	; 0x0a
    2512:	bb 85       	ldd	r27, Y+11	; 0x0b
    2514:	b9 01       	movw	r22, r18
    2516:	4e 85       	ldd	r20, Y+14	; 0x0e
    2518:	9f 01       	movw	r18, r30
    251a:	8d 01       	movw	r16, r26
    251c:	0e 94 2e 19 	call	0x325c	; 0x325c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2520:	89 81       	ldd	r24, Y+1	; 0x01
    2522:	9a 81       	ldd	r25, Y+2	; 0x02
    2524:	2e 81       	ldd	r18, Y+6	; 0x06
    2526:	3f 81       	ldd	r19, Y+7	; 0x07
    2528:	4c 85       	ldd	r20, Y+12	; 0x0c
    252a:	5d 85       	ldd	r21, Y+13	; 0x0d
    252c:	b9 01       	movw	r22, r18
    252e:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <pxPortInitialiseStack>
    2532:	eb 81       	ldd	r30, Y+3	; 0x03
    2534:	fc 81       	ldd	r31, Y+4	; 0x04
    2536:	91 83       	std	Z+1, r25	; 0x01
    2538:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    253a:	8f 85       	ldd	r24, Y+15	; 0x0f
    253c:	98 89       	ldd	r25, Y+16	; 0x10
    253e:	00 97       	sbiw	r24, 0x00	; 0
    2540:	31 f0       	breq	.+12     	; 0x254e <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2542:	ef 85       	ldd	r30, Y+15	; 0x0f
    2544:	f8 89       	ldd	r31, Y+16	; 0x10
    2546:	8b 81       	ldd	r24, Y+3	; 0x03
    2548:	9c 81       	ldd	r25, Y+4	; 0x04
    254a:	91 83       	std	Z+1, r25	; 0x01
    254c:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2554:	80 91 0f 03 	lds	r24, 0x030F
    2558:	8f 5f       	subi	r24, 0xFF	; 255
    255a:	80 93 0f 03 	sts	0x030F, r24
			if( pxCurrentTCB == NULL )
    255e:	80 91 0c 03 	lds	r24, 0x030C
    2562:	90 91 0d 03 	lds	r25, 0x030D
    2566:	00 97       	sbiw	r24, 0x00	; 0
    2568:	69 f4       	brne	.+26     	; 0x2584 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    256a:	8b 81       	ldd	r24, Y+3	; 0x03
    256c:	9c 81       	ldd	r25, Y+4	; 0x04
    256e:	90 93 0d 03 	sts	0x030D, r25
    2572:	80 93 0c 03 	sts	0x030C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2576:	80 91 0f 03 	lds	r24, 0x030F
    257a:	81 30       	cpi	r24, 0x01	; 1
    257c:	a9 f4       	brne	.+42     	; 0x25a8 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    257e:	0e 94 85 19 	call	0x330a	; 0x330a <prvInitialiseTaskLists>
    2582:	12 c0       	rjmp	.+36     	; 0x25a8 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2584:	80 91 14 03 	lds	r24, 0x0314
    2588:	88 23       	and	r24, r24
    258a:	71 f4       	brne	.+28     	; 0x25a8 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    258c:	e0 91 0c 03 	lds	r30, 0x030C
    2590:	f0 91 0d 03 	lds	r31, 0x030D
    2594:	96 89       	ldd	r25, Z+22	; 0x16
    2596:	8e 85       	ldd	r24, Y+14	; 0x0e
    2598:	89 17       	cp	r24, r25
    259a:	30 f0       	brcs	.+12     	; 0x25a8 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    259c:	8b 81       	ldd	r24, Y+3	; 0x03
    259e:	9c 81       	ldd	r25, Y+4	; 0x04
    25a0:	90 93 0d 03 	sts	0x030D, r25
    25a4:	80 93 0c 03 	sts	0x030C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    25a8:	eb 81       	ldd	r30, Y+3	; 0x03
    25aa:	fc 81       	ldd	r31, Y+4	; 0x04
    25ac:	96 89       	ldd	r25, Z+22	; 0x16
    25ae:	80 91 12 03 	lds	r24, 0x0312
    25b2:	89 17       	cp	r24, r25
    25b4:	28 f4       	brcc	.+10     	; 0x25c0 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    25b6:	eb 81       	ldd	r30, Y+3	; 0x03
    25b8:	fc 81       	ldd	r31, Y+4	; 0x04
    25ba:	86 89       	ldd	r24, Z+22	; 0x16
    25bc:	80 93 12 03 	sts	0x0312, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    25c0:	80 91 19 03 	lds	r24, 0x0319
    25c4:	8f 5f       	subi	r24, 0xFF	; 255
    25c6:	80 93 19 03 	sts	0x0319, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    25ca:	eb 81       	ldd	r30, Y+3	; 0x03
    25cc:	fc 81       	ldd	r31, Y+4	; 0x04
    25ce:	96 89       	ldd	r25, Z+22	; 0x16
    25d0:	80 91 13 03 	lds	r24, 0x0313
    25d4:	89 17       	cp	r24, r25
    25d6:	28 f4       	brcc	.+10     	; 0x25e2 <xTaskGenericCreate+0x152>
    25d8:	eb 81       	ldd	r30, Y+3	; 0x03
    25da:	fc 81       	ldd	r31, Y+4	; 0x04
    25dc:	86 89       	ldd	r24, Z+22	; 0x16
    25de:	80 93 13 03 	sts	0x0313, r24
    25e2:	eb 81       	ldd	r30, Y+3	; 0x03
    25e4:	fc 81       	ldd	r31, Y+4	; 0x04
    25e6:	86 89       	ldd	r24, Z+22	; 0x16
    25e8:	28 2f       	mov	r18, r24
    25ea:	30 e0       	ldi	r19, 0x00	; 0
    25ec:	c9 01       	movw	r24, r18
    25ee:	88 0f       	add	r24, r24
    25f0:	99 1f       	adc	r25, r25
    25f2:	88 0f       	add	r24, r24
    25f4:	99 1f       	adc	r25, r25
    25f6:	88 0f       	add	r24, r24
    25f8:	99 1f       	adc	r25, r25
    25fa:	82 0f       	add	r24, r18
    25fc:	93 1f       	adc	r25, r19
    25fe:	ac 01       	movw	r20, r24
    2600:	46 5e       	subi	r20, 0xE6	; 230
    2602:	5c 4f       	sbci	r21, 0xFC	; 252
    2604:	8b 81       	ldd	r24, Y+3	; 0x03
    2606:	9c 81       	ldd	r25, Y+4	; 0x04
    2608:	9c 01       	movw	r18, r24
    260a:	2e 5f       	subi	r18, 0xFE	; 254
    260c:	3f 4f       	sbci	r19, 0xFF	; 255
    260e:	ca 01       	movw	r24, r20
    2610:	b9 01       	movw	r22, r18
    2612:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

			xReturn = pdPASS;
    2616:	81 e0       	ldi	r24, 0x01	; 1
    2618:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    261a:	0f 90       	pop	r0
    261c:	0f be       	out	0x3f, r0	; 63
    261e:	02 c0       	rjmp	.+4      	; 0x2624 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2620:	8f ef       	ldi	r24, 0xFF	; 255
    2622:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2624:	8d 81       	ldd	r24, Y+5	; 0x05
    2626:	81 30       	cpi	r24, 0x01	; 1
    2628:	71 f4       	brne	.+28     	; 0x2646 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    262a:	80 91 14 03 	lds	r24, 0x0314
    262e:	88 23       	and	r24, r24
    2630:	51 f0       	breq	.+20     	; 0x2646 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2632:	e0 91 0c 03 	lds	r30, 0x030C
    2636:	f0 91 0d 03 	lds	r31, 0x030D
    263a:	96 89       	ldd	r25, Z+22	; 0x16
    263c:	8e 85       	ldd	r24, Y+14	; 0x0e
    263e:	98 17       	cp	r25, r24
    2640:	10 f4       	brcc	.+4      	; 0x2646 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    2642:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
			}
		}
	}

	return xReturn;
    2646:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2648:	64 96       	adiw	r28, 0x14	; 20
    264a:	0f b6       	in	r0, 0x3f	; 63
    264c:	f8 94       	cli
    264e:	de bf       	out	0x3e, r29	; 62
    2650:	0f be       	out	0x3f, r0	; 63
    2652:	cd bf       	out	0x3d, r28	; 61
    2654:	cf 91       	pop	r28
    2656:	df 91       	pop	r29
    2658:	1f 91       	pop	r17
    265a:	0f 91       	pop	r16
    265c:	ff 90       	pop	r15
    265e:	ef 90       	pop	r14
    2660:	df 90       	pop	r13
    2662:	cf 90       	pop	r12
    2664:	bf 90       	pop	r11
    2666:	af 90       	pop	r10
    2668:	08 95       	ret

0000266a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    266a:	df 93       	push	r29
    266c:	cf 93       	push	r28
    266e:	00 d0       	rcall	.+0      	; 0x2670 <vTaskDelete+0x6>
    2670:	00 d0       	rcall	.+0      	; 0x2672 <vTaskDelete+0x8>
    2672:	00 d0       	rcall	.+0      	; 0x2674 <vTaskDelete+0xa>
    2674:	cd b7       	in	r28, 0x3d	; 61
    2676:	de b7       	in	r29, 0x3e	; 62
    2678:	9c 83       	std	Y+4, r25	; 0x04
    267a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    267c:	0f b6       	in	r0, 0x3f	; 63
    267e:	f8 94       	cli
    2680:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2682:	20 91 0c 03 	lds	r18, 0x030C
    2686:	30 91 0d 03 	lds	r19, 0x030D
    268a:	8b 81       	ldd	r24, Y+3	; 0x03
    268c:	9c 81       	ldd	r25, Y+4	; 0x04
    268e:	82 17       	cp	r24, r18
    2690:	93 07       	cpc	r25, r19
    2692:	11 f4       	brne	.+4      	; 0x2698 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    2694:	1c 82       	std	Y+4, r1	; 0x04
    2696:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2698:	8b 81       	ldd	r24, Y+3	; 0x03
    269a:	9c 81       	ldd	r25, Y+4	; 0x04
    269c:	00 97       	sbiw	r24, 0x00	; 0
    269e:	39 f4       	brne	.+14     	; 0x26ae <vTaskDelete+0x44>
    26a0:	80 91 0c 03 	lds	r24, 0x030C
    26a4:	90 91 0d 03 	lds	r25, 0x030D
    26a8:	9e 83       	std	Y+6, r25	; 0x06
    26aa:	8d 83       	std	Y+5, r24	; 0x05
    26ac:	04 c0       	rjmp	.+8      	; 0x26b6 <vTaskDelete+0x4c>
    26ae:	8b 81       	ldd	r24, Y+3	; 0x03
    26b0:	9c 81       	ldd	r25, Y+4	; 0x04
    26b2:	9e 83       	std	Y+6, r25	; 0x06
    26b4:	8d 83       	std	Y+5, r24	; 0x05
    26b6:	8d 81       	ldd	r24, Y+5	; 0x05
    26b8:	9e 81       	ldd	r25, Y+6	; 0x06
    26ba:	9a 83       	std	Y+2, r25	; 0x02
    26bc:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	9a 81       	ldd	r25, Y+2	; 0x02
    26c2:	02 96       	adiw	r24, 0x02	; 2
    26c4:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    26c8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ca:	fa 81       	ldd	r31, Y+2	; 0x02
    26cc:	84 89       	ldd	r24, Z+20	; 0x14
    26ce:	95 89       	ldd	r25, Z+21	; 0x15
    26d0:	00 97       	sbiw	r24, 0x00	; 0
    26d2:	29 f0       	breq	.+10     	; 0x26de <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    26d4:	89 81       	ldd	r24, Y+1	; 0x01
    26d6:	9a 81       	ldd	r25, Y+2	; 0x02
    26d8:	0c 96       	adiw	r24, 0x0c	; 12
    26da:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    26de:	89 81       	ldd	r24, Y+1	; 0x01
    26e0:	9a 81       	ldd	r25, Y+2	; 0x02
    26e2:	9c 01       	movw	r18, r24
    26e4:	2e 5f       	subi	r18, 0xFE	; 254
    26e6:	3f 4f       	sbci	r19, 0xFF	; 255
    26e8:	86 e6       	ldi	r24, 0x66	; 102
    26ea:	93 e0       	ldi	r25, 0x03	; 3
    26ec:	b9 01       	movw	r22, r18
    26ee:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    26f2:	80 91 0e 03 	lds	r24, 0x030E
    26f6:	8f 5f       	subi	r24, 0xFF	; 255
    26f8:	80 93 0e 03 	sts	0x030E, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    26fc:	80 91 19 03 	lds	r24, 0x0319
    2700:	8f 5f       	subi	r24, 0xFF	; 255
    2702:	80 93 19 03 	sts	0x0319, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2706:	0f 90       	pop	r0
    2708:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    270a:	80 91 14 03 	lds	r24, 0x0314
    270e:	88 23       	and	r24, r24
    2710:	31 f0       	breq	.+12     	; 0x271e <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2712:	8b 81       	ldd	r24, Y+3	; 0x03
    2714:	9c 81       	ldd	r25, Y+4	; 0x04
    2716:	00 97       	sbiw	r24, 0x00	; 0
    2718:	11 f4       	brne	.+4      	; 0x271e <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    271a:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
			}
		}
	}
    271e:	26 96       	adiw	r28, 0x06	; 6
    2720:	0f b6       	in	r0, 0x3f	; 63
    2722:	f8 94       	cli
    2724:	de bf       	out	0x3e, r29	; 62
    2726:	0f be       	out	0x3f, r0	; 63
    2728:	cd bf       	out	0x3d, r28	; 61
    272a:	cf 91       	pop	r28
    272c:	df 91       	pop	r29
    272e:	08 95       	ret

00002730 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2730:	df 93       	push	r29
    2732:	cf 93       	push	r28
    2734:	cd b7       	in	r28, 0x3d	; 61
    2736:	de b7       	in	r29, 0x3e	; 62
    2738:	28 97       	sbiw	r28, 0x08	; 8
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	de bf       	out	0x3e, r29	; 62
    2740:	0f be       	out	0x3f, r0	; 63
    2742:	cd bf       	out	0x3d, r28	; 61
    2744:	9e 83       	std	Y+6, r25	; 0x06
    2746:	8d 83       	std	Y+5, r24	; 0x05
    2748:	78 87       	std	Y+8, r23	; 0x08
    274a:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    274c:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    274e:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2752:	ed 81       	ldd	r30, Y+5	; 0x05
    2754:	fe 81       	ldd	r31, Y+6	; 0x06
    2756:	20 81       	ld	r18, Z
    2758:	31 81       	ldd	r19, Z+1	; 0x01
    275a:	8f 81       	ldd	r24, Y+7	; 0x07
    275c:	98 85       	ldd	r25, Y+8	; 0x08
    275e:	82 0f       	add	r24, r18
    2760:	93 1f       	adc	r25, r19
    2762:	9c 83       	std	Y+4, r25	; 0x04
    2764:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2766:	ed 81       	ldd	r30, Y+5	; 0x05
    2768:	fe 81       	ldd	r31, Y+6	; 0x06
    276a:	20 81       	ld	r18, Z
    276c:	31 81       	ldd	r19, Z+1	; 0x01
    276e:	80 91 10 03 	lds	r24, 0x0310
    2772:	90 91 11 03 	lds	r25, 0x0311
    2776:	82 17       	cp	r24, r18
    2778:	93 07       	cpc	r25, r19
    277a:	a8 f4       	brcc	.+42     	; 0x27a6 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    277c:	ed 81       	ldd	r30, Y+5	; 0x05
    277e:	fe 81       	ldd	r31, Y+6	; 0x06
    2780:	20 81       	ld	r18, Z
    2782:	31 81       	ldd	r19, Z+1	; 0x01
    2784:	8b 81       	ldd	r24, Y+3	; 0x03
    2786:	9c 81       	ldd	r25, Y+4	; 0x04
    2788:	82 17       	cp	r24, r18
    278a:	93 07       	cpc	r25, r19
    278c:	00 f5       	brcc	.+64     	; 0x27ce <vTaskDelayUntil+0x9e>
    278e:	20 91 10 03 	lds	r18, 0x0310
    2792:	30 91 11 03 	lds	r19, 0x0311
    2796:	8b 81       	ldd	r24, Y+3	; 0x03
    2798:	9c 81       	ldd	r25, Y+4	; 0x04
    279a:	28 17       	cp	r18, r24
    279c:	39 07       	cpc	r19, r25
    279e:	b8 f4       	brcc	.+46     	; 0x27ce <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    27a0:	81 e0       	ldi	r24, 0x01	; 1
    27a2:	89 83       	std	Y+1, r24	; 0x01
    27a4:	14 c0       	rjmp	.+40     	; 0x27ce <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    27a6:	ed 81       	ldd	r30, Y+5	; 0x05
    27a8:	fe 81       	ldd	r31, Y+6	; 0x06
    27aa:	20 81       	ld	r18, Z
    27ac:	31 81       	ldd	r19, Z+1	; 0x01
    27ae:	8b 81       	ldd	r24, Y+3	; 0x03
    27b0:	9c 81       	ldd	r25, Y+4	; 0x04
    27b2:	82 17       	cp	r24, r18
    27b4:	93 07       	cpc	r25, r19
    27b6:	48 f0       	brcs	.+18     	; 0x27ca <vTaskDelayUntil+0x9a>
    27b8:	20 91 10 03 	lds	r18, 0x0310
    27bc:	30 91 11 03 	lds	r19, 0x0311
    27c0:	8b 81       	ldd	r24, Y+3	; 0x03
    27c2:	9c 81       	ldd	r25, Y+4	; 0x04
    27c4:	28 17       	cp	r18, r24
    27c6:	39 07       	cpc	r19, r25
    27c8:	10 f4       	brcc	.+4      	; 0x27ce <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    27ca:	81 e0       	ldi	r24, 0x01	; 1
    27cc:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    27ce:	ed 81       	ldd	r30, Y+5	; 0x05
    27d0:	fe 81       	ldd	r31, Y+6	; 0x06
    27d2:	8b 81       	ldd	r24, Y+3	; 0x03
    27d4:	9c 81       	ldd	r25, Y+4	; 0x04
    27d6:	91 83       	std	Z+1, r25	; 0x01
    27d8:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    27da:	89 81       	ldd	r24, Y+1	; 0x01
    27dc:	88 23       	and	r24, r24
    27de:	59 f0       	breq	.+22     	; 0x27f6 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27e0:	80 91 0c 03 	lds	r24, 0x030C
    27e4:	90 91 0d 03 	lds	r25, 0x030D
    27e8:	02 96       	adiw	r24, 0x02	; 2
    27ea:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    27ee:	8b 81       	ldd	r24, Y+3	; 0x03
    27f0:	9c 81       	ldd	r25, Y+4	; 0x04
    27f2:	0e 94 04 1a 	call	0x3408	; 0x3408 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    27f6:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
    27fa:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    27fc:	8a 81       	ldd	r24, Y+2	; 0x02
    27fe:	88 23       	and	r24, r24
    2800:	11 f4       	brne	.+4      	; 0x2806 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2802:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
		}
	}
    2806:	28 96       	adiw	r28, 0x08	; 8
    2808:	0f b6       	in	r0, 0x3f	; 63
    280a:	f8 94       	cli
    280c:	de bf       	out	0x3e, r29	; 62
    280e:	0f be       	out	0x3f, r0	; 63
    2810:	cd bf       	out	0x3d, r28	; 61
    2812:	cf 91       	pop	r28
    2814:	df 91       	pop	r29
    2816:	08 95       	ret

00002818 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2818:	df 93       	push	r29
    281a:	cf 93       	push	r28
    281c:	00 d0       	rcall	.+0      	; 0x281e <vTaskDelay+0x6>
    281e:	00 d0       	rcall	.+0      	; 0x2820 <vTaskDelay+0x8>
    2820:	0f 92       	push	r0
    2822:	cd b7       	in	r28, 0x3d	; 61
    2824:	de b7       	in	r29, 0x3e	; 62
    2826:	9d 83       	std	Y+5, r25	; 0x05
    2828:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    282a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    282c:	8c 81       	ldd	r24, Y+4	; 0x04
    282e:	9d 81       	ldd	r25, Y+5	; 0x05
    2830:	00 97       	sbiw	r24, 0x00	; 0
    2832:	d1 f0       	breq	.+52     	; 0x2868 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2834:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2838:	20 91 10 03 	lds	r18, 0x0310
    283c:	30 91 11 03 	lds	r19, 0x0311
    2840:	8c 81       	ldd	r24, Y+4	; 0x04
    2842:	9d 81       	ldd	r25, Y+5	; 0x05
    2844:	82 0f       	add	r24, r18
    2846:	93 1f       	adc	r25, r19
    2848:	9b 83       	std	Y+3, r25	; 0x03
    284a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    284c:	80 91 0c 03 	lds	r24, 0x030C
    2850:	90 91 0d 03 	lds	r25, 0x030D
    2854:	02 96       	adiw	r24, 0x02	; 2
    2856:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    285a:	8a 81       	ldd	r24, Y+2	; 0x02
    285c:	9b 81       	ldd	r25, Y+3	; 0x03
    285e:	0e 94 04 1a 	call	0x3408	; 0x3408 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2862:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>
    2866:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2868:	89 81       	ldd	r24, Y+1	; 0x01
    286a:	88 23       	and	r24, r24
    286c:	11 f4       	brne	.+4      	; 0x2872 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    286e:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
		}
	}
    2872:	0f 90       	pop	r0
    2874:	0f 90       	pop	r0
    2876:	0f 90       	pop	r0
    2878:	0f 90       	pop	r0
    287a:	0f 90       	pop	r0
    287c:	cf 91       	pop	r28
    287e:	df 91       	pop	r29
    2880:	08 95       	ret

00002882 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    2882:	df 93       	push	r29
    2884:	cf 93       	push	r28
    2886:	00 d0       	rcall	.+0      	; 0x2888 <vTaskSuspend+0x6>
    2888:	00 d0       	rcall	.+0      	; 0x288a <vTaskSuspend+0x8>
    288a:	00 d0       	rcall	.+0      	; 0x288c <vTaskSuspend+0xa>
    288c:	cd b7       	in	r28, 0x3d	; 61
    288e:	de b7       	in	r29, 0x3e	; 62
    2890:	9c 83       	std	Y+4, r25	; 0x04
    2892:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2894:	0f b6       	in	r0, 0x3f	; 63
    2896:	f8 94       	cli
    2898:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    289a:	20 91 0c 03 	lds	r18, 0x030C
    289e:	30 91 0d 03 	lds	r19, 0x030D
    28a2:	8b 81       	ldd	r24, Y+3	; 0x03
    28a4:	9c 81       	ldd	r25, Y+4	; 0x04
    28a6:	82 17       	cp	r24, r18
    28a8:	93 07       	cpc	r25, r19
    28aa:	11 f4       	brne	.+4      	; 0x28b0 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    28ac:	1c 82       	std	Y+4, r1	; 0x04
    28ae:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    28b0:	8b 81       	ldd	r24, Y+3	; 0x03
    28b2:	9c 81       	ldd	r25, Y+4	; 0x04
    28b4:	00 97       	sbiw	r24, 0x00	; 0
    28b6:	39 f4       	brne	.+14     	; 0x28c6 <vTaskSuspend+0x44>
    28b8:	80 91 0c 03 	lds	r24, 0x030C
    28bc:	90 91 0d 03 	lds	r25, 0x030D
    28c0:	9e 83       	std	Y+6, r25	; 0x06
    28c2:	8d 83       	std	Y+5, r24	; 0x05
    28c4:	04 c0       	rjmp	.+8      	; 0x28ce <vTaskSuspend+0x4c>
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	9e 83       	std	Y+6, r25	; 0x06
    28cc:	8d 83       	std	Y+5, r24	; 0x05
    28ce:	8d 81       	ldd	r24, Y+5	; 0x05
    28d0:	9e 81       	ldd	r25, Y+6	; 0x06
    28d2:	9a 83       	std	Y+2, r25	; 0x02
    28d4:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    28d6:	89 81       	ldd	r24, Y+1	; 0x01
    28d8:	9a 81       	ldd	r25, Y+2	; 0x02
    28da:	02 96       	adiw	r24, 0x02	; 2
    28dc:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    28e0:	e9 81       	ldd	r30, Y+1	; 0x01
    28e2:	fa 81       	ldd	r31, Y+2	; 0x02
    28e4:	84 89       	ldd	r24, Z+20	; 0x14
    28e6:	95 89       	ldd	r25, Z+21	; 0x15
    28e8:	00 97       	sbiw	r24, 0x00	; 0
    28ea:	29 f0       	breq	.+10     	; 0x28f6 <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    28ec:	89 81       	ldd	r24, Y+1	; 0x01
    28ee:	9a 81       	ldd	r25, Y+2	; 0x02
    28f0:	0c 96       	adiw	r24, 0x0c	; 12
    28f2:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    28f6:	89 81       	ldd	r24, Y+1	; 0x01
    28f8:	9a 81       	ldd	r25, Y+2	; 0x02
    28fa:	9c 01       	movw	r18, r24
    28fc:	2e 5f       	subi	r18, 0xFE	; 254
    28fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2900:	8f e6       	ldi	r24, 0x6F	; 111
    2902:	93 e0       	ldi	r25, 0x03	; 3
    2904:	b9 01       	movw	r22, r18
    2906:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    290a:	0f 90       	pop	r0
    290c:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    290e:	8b 81       	ldd	r24, Y+3	; 0x03
    2910:	9c 81       	ldd	r25, Y+4	; 0x04
    2912:	00 97       	sbiw	r24, 0x00	; 0
    2914:	a1 f4       	brne	.+40     	; 0x293e <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    2916:	80 91 14 03 	lds	r24, 0x0314
    291a:	88 23       	and	r24, r24
    291c:	19 f0       	breq	.+6      	; 0x2924 <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    291e:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
    2922:	0d c0       	rjmp	.+26     	; 0x293e <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    2924:	90 91 6f 03 	lds	r25, 0x036F
    2928:	80 91 0f 03 	lds	r24, 0x030F
    292c:	98 17       	cp	r25, r24
    292e:	29 f4       	brne	.+10     	; 0x293a <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2930:	10 92 0d 03 	sts	0x030D, r1
    2934:	10 92 0c 03 	sts	0x030C, r1
    2938:	02 c0       	rjmp	.+4      	; 0x293e <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    293a:	0e 94 83 17 	call	0x2f06	; 0x2f06 <vTaskSwitchContext>
				}
			}
		}
	}
    293e:	26 96       	adiw	r28, 0x06	; 6
    2940:	0f b6       	in	r0, 0x3f	; 63
    2942:	f8 94       	cli
    2944:	de bf       	out	0x3e, r29	; 62
    2946:	0f be       	out	0x3f, r0	; 63
    2948:	cd bf       	out	0x3d, r28	; 61
    294a:	cf 91       	pop	r28
    294c:	df 91       	pop	r29
    294e:	08 95       	ret

00002950 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    2950:	df 93       	push	r29
    2952:	cf 93       	push	r28
    2954:	00 d0       	rcall	.+0      	; 0x2956 <xTaskIsTaskSuspended+0x6>
    2956:	00 d0       	rcall	.+0      	; 0x2958 <xTaskIsTaskSuspended+0x8>
    2958:	0f 92       	push	r0
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
    295e:	9d 83       	std	Y+5, r25	; 0x05
    2960:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    2962:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    2964:	8c 81       	ldd	r24, Y+4	; 0x04
    2966:	9d 81       	ldd	r25, Y+5	; 0x05
    2968:	9a 83       	std	Y+2, r25	; 0x02
    296a:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    296c:	e9 81       	ldd	r30, Y+1	; 0x01
    296e:	fa 81       	ldd	r31, Y+2	; 0x02
    2970:	82 85       	ldd	r24, Z+10	; 0x0a
    2972:	93 85       	ldd	r25, Z+11	; 0x0b
    2974:	23 e0       	ldi	r18, 0x03	; 3
    2976:	8f 36       	cpi	r24, 0x6F	; 111
    2978:	92 07       	cpc	r25, r18
    297a:	81 f4       	brne	.+32     	; 0x299c <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    297c:	e9 81       	ldd	r30, Y+1	; 0x01
    297e:	fa 81       	ldd	r31, Y+2	; 0x02
    2980:	84 89       	ldd	r24, Z+20	; 0x14
    2982:	95 89       	ldd	r25, Z+21	; 0x15
    2984:	23 e0       	ldi	r18, 0x03	; 3
    2986:	8d 35       	cpi	r24, 0x5D	; 93
    2988:	92 07       	cpc	r25, r18
    298a:	41 f0       	breq	.+16     	; 0x299c <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    298c:	e9 81       	ldd	r30, Y+1	; 0x01
    298e:	fa 81       	ldd	r31, Y+2	; 0x02
    2990:	84 89       	ldd	r24, Z+20	; 0x14
    2992:	95 89       	ldd	r25, Z+21	; 0x15
    2994:	00 97       	sbiw	r24, 0x00	; 0
    2996:	11 f4       	brne	.+4      	; 0x299c <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    2998:	81 e0       	ldi	r24, 0x01	; 1
    299a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    299c:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    299e:	0f 90       	pop	r0
    29a0:	0f 90       	pop	r0
    29a2:	0f 90       	pop	r0
    29a4:	0f 90       	pop	r0
    29a6:	0f 90       	pop	r0
    29a8:	cf 91       	pop	r28
    29aa:	df 91       	pop	r29
    29ac:	08 95       	ret

000029ae <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    29ae:	df 93       	push	r29
    29b0:	cf 93       	push	r28
    29b2:	00 d0       	rcall	.+0      	; 0x29b4 <vTaskResume+0x6>
    29b4:	00 d0       	rcall	.+0      	; 0x29b6 <vTaskResume+0x8>
    29b6:	cd b7       	in	r28, 0x3d	; 61
    29b8:	de b7       	in	r29, 0x3e	; 62
    29ba:	9c 83       	std	Y+4, r25	; 0x04
    29bc:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    29be:	8b 81       	ldd	r24, Y+3	; 0x03
    29c0:	9c 81       	ldd	r25, Y+4	; 0x04
    29c2:	9a 83       	std	Y+2, r25	; 0x02
    29c4:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    29c6:	89 81       	ldd	r24, Y+1	; 0x01
    29c8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ca:	00 97       	sbiw	r24, 0x00	; 0
    29cc:	09 f4       	brne	.+2      	; 0x29d0 <vTaskResume+0x22>
    29ce:	4c c0       	rjmp	.+152    	; 0x2a68 <vTaskResume+0xba>
    29d0:	20 91 0c 03 	lds	r18, 0x030C
    29d4:	30 91 0d 03 	lds	r19, 0x030D
    29d8:	89 81       	ldd	r24, Y+1	; 0x01
    29da:	9a 81       	ldd	r25, Y+2	; 0x02
    29dc:	82 17       	cp	r24, r18
    29de:	93 07       	cpc	r25, r19
    29e0:	09 f4       	brne	.+2      	; 0x29e4 <vTaskResume+0x36>
    29e2:	42 c0       	rjmp	.+132    	; 0x2a68 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    29e4:	0f b6       	in	r0, 0x3f	; 63
    29e6:	f8 94       	cli
    29e8:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    29ea:	89 81       	ldd	r24, Y+1	; 0x01
    29ec:	9a 81       	ldd	r25, Y+2	; 0x02
    29ee:	0e 94 a8 14 	call	0x2950	; 0x2950 <xTaskIsTaskSuspended>
    29f2:	81 30       	cpi	r24, 0x01	; 1
    29f4:	b9 f5       	brne	.+110    	; 0x2a64 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    29f6:	89 81       	ldd	r24, Y+1	; 0x01
    29f8:	9a 81       	ldd	r25, Y+2	; 0x02
    29fa:	02 96       	adiw	r24, 0x02	; 2
    29fc:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2a00:	e9 81       	ldd	r30, Y+1	; 0x01
    2a02:	fa 81       	ldd	r31, Y+2	; 0x02
    2a04:	96 89       	ldd	r25, Z+22	; 0x16
    2a06:	80 91 13 03 	lds	r24, 0x0313
    2a0a:	89 17       	cp	r24, r25
    2a0c:	28 f4       	brcc	.+10     	; 0x2a18 <vTaskResume+0x6a>
    2a0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a10:	fa 81       	ldd	r31, Y+2	; 0x02
    2a12:	86 89       	ldd	r24, Z+22	; 0x16
    2a14:	80 93 13 03 	sts	0x0313, r24
    2a18:	e9 81       	ldd	r30, Y+1	; 0x01
    2a1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a1c:	86 89       	ldd	r24, Z+22	; 0x16
    2a1e:	28 2f       	mov	r18, r24
    2a20:	30 e0       	ldi	r19, 0x00	; 0
    2a22:	c9 01       	movw	r24, r18
    2a24:	88 0f       	add	r24, r24
    2a26:	99 1f       	adc	r25, r25
    2a28:	88 0f       	add	r24, r24
    2a2a:	99 1f       	adc	r25, r25
    2a2c:	88 0f       	add	r24, r24
    2a2e:	99 1f       	adc	r25, r25
    2a30:	82 0f       	add	r24, r18
    2a32:	93 1f       	adc	r25, r19
    2a34:	ac 01       	movw	r20, r24
    2a36:	46 5e       	subi	r20, 0xE6	; 230
    2a38:	5c 4f       	sbci	r21, 0xFC	; 252
    2a3a:	89 81       	ldd	r24, Y+1	; 0x01
    2a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3e:	9c 01       	movw	r18, r24
    2a40:	2e 5f       	subi	r18, 0xFE	; 254
    2a42:	3f 4f       	sbci	r19, 0xFF	; 255
    2a44:	ca 01       	movw	r24, r20
    2a46:	b9 01       	movw	r22, r18
    2a48:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2a4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a50:	96 89       	ldd	r25, Z+22	; 0x16
    2a52:	e0 91 0c 03 	lds	r30, 0x030C
    2a56:	f0 91 0d 03 	lds	r31, 0x030D
    2a5a:	86 89       	ldd	r24, Z+22	; 0x16
    2a5c:	98 17       	cp	r25, r24
    2a5e:	10 f0       	brcs	.+4      	; 0x2a64 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    2a60:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    2a64:	0f 90       	pop	r0
    2a66:	0f be       	out	0x3f, r0	; 63
		}
	}
    2a68:	0f 90       	pop	r0
    2a6a:	0f 90       	pop	r0
    2a6c:	0f 90       	pop	r0
    2a6e:	0f 90       	pop	r0
    2a70:	cf 91       	pop	r28
    2a72:	df 91       	pop	r29
    2a74:	08 95       	ret

00002a76 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    2a76:	df 93       	push	r29
    2a78:	cf 93       	push	r28
    2a7a:	00 d0       	rcall	.+0      	; 0x2a7c <xTaskResumeFromISR+0x6>
    2a7c:	00 d0       	rcall	.+0      	; 0x2a7e <xTaskResumeFromISR+0x8>
    2a7e:	0f 92       	push	r0
    2a80:	cd b7       	in	r28, 0x3d	; 61
    2a82:	de b7       	in	r29, 0x3e	; 62
    2a84:	9d 83       	std	Y+5, r25	; 0x05
    2a86:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    2a88:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    2a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2a8c:	9d 81       	ldd	r25, Y+5	; 0x05
    2a8e:	9a 83       	std	Y+2, r25	; 0x02
    2a90:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2a92:	89 81       	ldd	r24, Y+1	; 0x01
    2a94:	9a 81       	ldd	r25, Y+2	; 0x02
    2a96:	0e 94 a8 14 	call	0x2950	; 0x2950 <xTaskIsTaskSuspended>
    2a9a:	81 30       	cpi	r24, 0x01	; 1
    2a9c:	09 f0       	breq	.+2      	; 0x2aa0 <xTaskResumeFromISR+0x2a>
    2a9e:	47 c0       	rjmp	.+142    	; 0x2b2e <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2aa0:	80 91 15 03 	lds	r24, 0x0315
    2aa4:	88 23       	and	r24, r24
    2aa6:	c9 f5       	brne	.+114    	; 0x2b1a <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    2aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    2aac:	96 89       	ldd	r25, Z+22	; 0x16
    2aae:	e0 91 0c 03 	lds	r30, 0x030C
    2ab2:	f0 91 0d 03 	lds	r31, 0x030D
    2ab6:	86 89       	ldd	r24, Z+22	; 0x16
    2ab8:	1b 82       	std	Y+3, r1	; 0x03
    2aba:	98 17       	cp	r25, r24
    2abc:	10 f0       	brcs	.+4      	; 0x2ac2 <xTaskResumeFromISR+0x4c>
    2abe:	81 e0       	ldi	r24, 0x01	; 1
    2ac0:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    2ac2:	89 81       	ldd	r24, Y+1	; 0x01
    2ac4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac6:	02 96       	adiw	r24, 0x02	; 2
    2ac8:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    2acc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ace:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad0:	96 89       	ldd	r25, Z+22	; 0x16
    2ad2:	80 91 13 03 	lds	r24, 0x0313
    2ad6:	89 17       	cp	r24, r25
    2ad8:	28 f4       	brcc	.+10     	; 0x2ae4 <xTaskResumeFromISR+0x6e>
    2ada:	e9 81       	ldd	r30, Y+1	; 0x01
    2adc:	fa 81       	ldd	r31, Y+2	; 0x02
    2ade:	86 89       	ldd	r24, Z+22	; 0x16
    2ae0:	80 93 13 03 	sts	0x0313, r24
    2ae4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae8:	86 89       	ldd	r24, Z+22	; 0x16
    2aea:	28 2f       	mov	r18, r24
    2aec:	30 e0       	ldi	r19, 0x00	; 0
    2aee:	c9 01       	movw	r24, r18
    2af0:	88 0f       	add	r24, r24
    2af2:	99 1f       	adc	r25, r25
    2af4:	88 0f       	add	r24, r24
    2af6:	99 1f       	adc	r25, r25
    2af8:	88 0f       	add	r24, r24
    2afa:	99 1f       	adc	r25, r25
    2afc:	82 0f       	add	r24, r18
    2afe:	93 1f       	adc	r25, r19
    2b00:	ac 01       	movw	r20, r24
    2b02:	46 5e       	subi	r20, 0xE6	; 230
    2b04:	5c 4f       	sbci	r21, 0xFC	; 252
    2b06:	89 81       	ldd	r24, Y+1	; 0x01
    2b08:	9a 81       	ldd	r25, Y+2	; 0x02
    2b0a:	9c 01       	movw	r18, r24
    2b0c:	2e 5f       	subi	r18, 0xFE	; 254
    2b0e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b10:	ca 01       	movw	r24, r20
    2b12:	b9 01       	movw	r22, r18
    2b14:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
    2b18:	0a c0       	rjmp	.+20     	; 0x2b2e <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2b1a:	89 81       	ldd	r24, Y+1	; 0x01
    2b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b1e:	9c 01       	movw	r18, r24
    2b20:	24 5f       	subi	r18, 0xF4	; 244
    2b22:	3f 4f       	sbci	r19, 0xFF	; 255
    2b24:	8d e5       	ldi	r24, 0x5D	; 93
    2b26:	93 e0       	ldi	r25, 0x03	; 3
    2b28:	b9 01       	movw	r22, r18
    2b2a:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
			}
		}

		return xYieldRequired;
    2b2e:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	0f 90       	pop	r0
    2b38:	0f 90       	pop	r0
    2b3a:	cf 91       	pop	r28
    2b3c:	df 91       	pop	r29
    2b3e:	08 95       	ret

00002b40 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2b40:	af 92       	push	r10
    2b42:	bf 92       	push	r11
    2b44:	cf 92       	push	r12
    2b46:	df 92       	push	r13
    2b48:	ef 92       	push	r14
    2b4a:	ff 92       	push	r15
    2b4c:	0f 93       	push	r16
    2b4e:	df 93       	push	r29
    2b50:	cf 93       	push	r28
    2b52:	0f 92       	push	r0
    2b54:	cd b7       	in	r28, 0x3d	; 61
    2b56:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2b58:	20 e6       	ldi	r18, 0x60	; 96
    2b5a:	30 e0       	ldi	r19, 0x00	; 0
    2b5c:	84 e2       	ldi	r24, 0x24	; 36
    2b5e:	99 e1       	ldi	r25, 0x19	; 25
    2b60:	b9 01       	movw	r22, r18
    2b62:	44 e6       	ldi	r20, 0x64	; 100
    2b64:	50 e0       	ldi	r21, 0x00	; 0
    2b66:	20 e0       	ldi	r18, 0x00	; 0
    2b68:	30 e0       	ldi	r19, 0x00	; 0
    2b6a:	00 e0       	ldi	r16, 0x00	; 0
    2b6c:	ee 24       	eor	r14, r14
    2b6e:	ff 24       	eor	r15, r15
    2b70:	cc 24       	eor	r12, r12
    2b72:	dd 24       	eor	r13, r13
    2b74:	aa 24       	eor	r10, r10
    2b76:	bb 24       	eor	r11, r11
    2b78:	0e 94 48 12 	call	0x2490	; 0x2490 <xTaskGenericCreate>
    2b7c:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
    2b80:	81 30       	cpi	r24, 0x01	; 1
    2b82:	51 f4       	brne	.+20     	; 0x2b98 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2b84:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	80 93 14 03 	sts	0x0314, r24
		xTickCount = ( portTickType ) 0U;
    2b8c:	10 92 11 03 	sts	0x0311, r1
    2b90:	10 92 10 03 	sts	0x0310, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2b94:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2b98:	0f 90       	pop	r0
    2b9a:	cf 91       	pop	r28
    2b9c:	df 91       	pop	r29
    2b9e:	0f 91       	pop	r16
    2ba0:	ff 90       	pop	r15
    2ba2:	ef 90       	pop	r14
    2ba4:	df 90       	pop	r13
    2ba6:	cf 90       	pop	r12
    2ba8:	bf 90       	pop	r11
    2baa:	af 90       	pop	r10
    2bac:	08 95       	ret

00002bae <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2bae:	df 93       	push	r29
    2bb0:	cf 93       	push	r28
    2bb2:	cd b7       	in	r28, 0x3d	; 61
    2bb4:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2bb6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2bb8:	10 92 14 03 	sts	0x0314, r1
	vPortEndScheduler();
    2bbc:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortEndScheduler>
}
    2bc0:	cf 91       	pop	r28
    2bc2:	df 91       	pop	r29
    2bc4:	08 95       	ret

00002bc6 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2bc6:	df 93       	push	r29
    2bc8:	cf 93       	push	r28
    2bca:	cd b7       	in	r28, 0x3d	; 61
    2bcc:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2bce:	80 91 15 03 	lds	r24, 0x0315
    2bd2:	8f 5f       	subi	r24, 0xFF	; 255
    2bd4:	80 93 15 03 	sts	0x0315, r24
}
    2bd8:	cf 91       	pop	r28
    2bda:	df 91       	pop	r29
    2bdc:	08 95       	ret

00002bde <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2bde:	df 93       	push	r29
    2be0:	cf 93       	push	r28
    2be2:	00 d0       	rcall	.+0      	; 0x2be4 <xTaskResumeAll+0x6>
    2be4:	00 d0       	rcall	.+0      	; 0x2be6 <xTaskResumeAll+0x8>
    2be6:	cd b7       	in	r28, 0x3d	; 61
    2be8:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2bea:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2bec:	0f b6       	in	r0, 0x3f	; 63
    2bee:	f8 94       	cli
    2bf0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2bf2:	80 91 15 03 	lds	r24, 0x0315
    2bf6:	81 50       	subi	r24, 0x01	; 1
    2bf8:	80 93 15 03 	sts	0x0315, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2bfc:	80 91 15 03 	lds	r24, 0x0315
    2c00:	88 23       	and	r24, r24
    2c02:	09 f0       	breq	.+2      	; 0x2c06 <xTaskResumeAll+0x28>
    2c04:	6c c0       	rjmp	.+216    	; 0x2cde <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2c06:	80 91 0f 03 	lds	r24, 0x030F
    2c0a:	88 23       	and	r24, r24
    2c0c:	09 f4       	brne	.+2      	; 0x2c10 <xTaskResumeAll+0x32>
    2c0e:	67 c0       	rjmp	.+206    	; 0x2cde <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2c10:	19 82       	std	Y+1, r1	; 0x01
    2c12:	41 c0       	rjmp	.+130    	; 0x2c96 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2c14:	e0 91 62 03 	lds	r30, 0x0362
    2c18:	f0 91 63 03 	lds	r31, 0x0363
    2c1c:	86 81       	ldd	r24, Z+6	; 0x06
    2c1e:	97 81       	ldd	r25, Z+7	; 0x07
    2c20:	9c 83       	std	Y+4, r25	; 0x04
    2c22:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2c24:	8b 81       	ldd	r24, Y+3	; 0x03
    2c26:	9c 81       	ldd	r25, Y+4	; 0x04
    2c28:	0c 96       	adiw	r24, 0x0c	; 12
    2c2a:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2c2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c30:	9c 81       	ldd	r25, Y+4	; 0x04
    2c32:	02 96       	adiw	r24, 0x02	; 2
    2c34:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2c38:	eb 81       	ldd	r30, Y+3	; 0x03
    2c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c3c:	96 89       	ldd	r25, Z+22	; 0x16
    2c3e:	80 91 13 03 	lds	r24, 0x0313
    2c42:	89 17       	cp	r24, r25
    2c44:	28 f4       	brcc	.+10     	; 0x2c50 <xTaskResumeAll+0x72>
    2c46:	eb 81       	ldd	r30, Y+3	; 0x03
    2c48:	fc 81       	ldd	r31, Y+4	; 0x04
    2c4a:	86 89       	ldd	r24, Z+22	; 0x16
    2c4c:	80 93 13 03 	sts	0x0313, r24
    2c50:	eb 81       	ldd	r30, Y+3	; 0x03
    2c52:	fc 81       	ldd	r31, Y+4	; 0x04
    2c54:	86 89       	ldd	r24, Z+22	; 0x16
    2c56:	28 2f       	mov	r18, r24
    2c58:	30 e0       	ldi	r19, 0x00	; 0
    2c5a:	c9 01       	movw	r24, r18
    2c5c:	88 0f       	add	r24, r24
    2c5e:	99 1f       	adc	r25, r25
    2c60:	88 0f       	add	r24, r24
    2c62:	99 1f       	adc	r25, r25
    2c64:	88 0f       	add	r24, r24
    2c66:	99 1f       	adc	r25, r25
    2c68:	82 0f       	add	r24, r18
    2c6a:	93 1f       	adc	r25, r19
    2c6c:	86 5e       	subi	r24, 0xE6	; 230
    2c6e:	9c 4f       	sbci	r25, 0xFC	; 252
    2c70:	2b 81       	ldd	r18, Y+3	; 0x03
    2c72:	3c 81       	ldd	r19, Y+4	; 0x04
    2c74:	2e 5f       	subi	r18, 0xFE	; 254
    2c76:	3f 4f       	sbci	r19, 0xFF	; 255
    2c78:	b9 01       	movw	r22, r18
    2c7a:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c80:	fc 81       	ldd	r31, Y+4	; 0x04
    2c82:	96 89       	ldd	r25, Z+22	; 0x16
    2c84:	e0 91 0c 03 	lds	r30, 0x030C
    2c88:	f0 91 0d 03 	lds	r31, 0x030D
    2c8c:	86 89       	ldd	r24, Z+22	; 0x16
    2c8e:	98 17       	cp	r25, r24
    2c90:	10 f0       	brcs	.+4      	; 0x2c96 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    2c92:	81 e0       	ldi	r24, 0x01	; 1
    2c94:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2c96:	80 91 5d 03 	lds	r24, 0x035D
    2c9a:	88 23       	and	r24, r24
    2c9c:	09 f0       	breq	.+2      	; 0x2ca0 <xTaskResumeAll+0xc2>
    2c9e:	ba cf       	rjmp	.-140    	; 0x2c14 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2ca0:	80 91 16 03 	lds	r24, 0x0316
    2ca4:	88 23       	and	r24, r24
    2ca6:	71 f0       	breq	.+28     	; 0x2cc4 <xTaskResumeAll+0xe6>
    2ca8:	07 c0       	rjmp	.+14     	; 0x2cb8 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2caa:	0e 94 ae 16 	call	0x2d5c	; 0x2d5c <vTaskIncrementTick>
						--uxMissedTicks;
    2cae:	80 91 16 03 	lds	r24, 0x0316
    2cb2:	81 50       	subi	r24, 0x01	; 1
    2cb4:	80 93 16 03 	sts	0x0316, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2cb8:	80 91 16 03 	lds	r24, 0x0316
    2cbc:	88 23       	and	r24, r24
    2cbe:	a9 f7       	brne	.-22     	; 0x2caa <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    2cc0:	81 e0       	ldi	r24, 0x01	; 1
    2cc2:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2cc4:	89 81       	ldd	r24, Y+1	; 0x01
    2cc6:	81 30       	cpi	r24, 0x01	; 1
    2cc8:	21 f0       	breq	.+8      	; 0x2cd2 <xTaskResumeAll+0xf4>
    2cca:	80 91 17 03 	lds	r24, 0x0317
    2cce:	81 30       	cpi	r24, 0x01	; 1
    2cd0:	31 f4       	brne	.+12     	; 0x2cde <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    2cd2:	81 e0       	ldi	r24, 0x01	; 1
    2cd4:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2cd6:	10 92 17 03 	sts	0x0317, r1
					portYIELD_WITHIN_API();
    2cda:	0e 94 b4 0c 	call	0x1968	; 0x1968 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2cde:	0f 90       	pop	r0
    2ce0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2ce2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2ce4:	0f 90       	pop	r0
    2ce6:	0f 90       	pop	r0
    2ce8:	0f 90       	pop	r0
    2cea:	0f 90       	pop	r0
    2cec:	cf 91       	pop	r28
    2cee:	df 91       	pop	r29
    2cf0:	08 95       	ret

00002cf2 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2cf2:	df 93       	push	r29
    2cf4:	cf 93       	push	r28
    2cf6:	00 d0       	rcall	.+0      	; 0x2cf8 <xTaskGetTickCount+0x6>
    2cf8:	cd b7       	in	r28, 0x3d	; 61
    2cfa:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2cfc:	0f b6       	in	r0, 0x3f	; 63
    2cfe:	f8 94       	cli
    2d00:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2d02:	80 91 10 03 	lds	r24, 0x0310
    2d06:	90 91 11 03 	lds	r25, 0x0311
    2d0a:	9a 83       	std	Y+2, r25	; 0x02
    2d0c:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2d0e:	0f 90       	pop	r0
    2d10:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2d12:	89 81       	ldd	r24, Y+1	; 0x01
    2d14:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d16:	0f 90       	pop	r0
    2d18:	0f 90       	pop	r0
    2d1a:	cf 91       	pop	r28
    2d1c:	df 91       	pop	r29
    2d1e:	08 95       	ret

00002d20 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2d20:	df 93       	push	r29
    2d22:	cf 93       	push	r28
    2d24:	00 d0       	rcall	.+0      	; 0x2d26 <xTaskGetTickCountFromISR+0x6>
    2d26:	0f 92       	push	r0
    2d28:	cd b7       	in	r28, 0x3d	; 61
    2d2a:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2d2c:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2d2e:	80 91 10 03 	lds	r24, 0x0310
    2d32:	90 91 11 03 	lds	r25, 0x0311
    2d36:	9b 83       	std	Y+3, r25	; 0x03
    2d38:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3c:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2d3e:	0f 90       	pop	r0
    2d40:	0f 90       	pop	r0
    2d42:	0f 90       	pop	r0
    2d44:	cf 91       	pop	r28
    2d46:	df 91       	pop	r29
    2d48:	08 95       	ret

00002d4a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2d4a:	df 93       	push	r29
    2d4c:	cf 93       	push	r28
    2d4e:	cd b7       	in	r28, 0x3d	; 61
    2d50:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2d52:	80 91 0f 03 	lds	r24, 0x030F
}
    2d56:	cf 91       	pop	r28
    2d58:	df 91       	pop	r29
    2d5a:	08 95       	ret

00002d5c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2d5c:	df 93       	push	r29
    2d5e:	cf 93       	push	r28
    2d60:	00 d0       	rcall	.+0      	; 0x2d62 <vTaskIncrementTick+0x6>
    2d62:	00 d0       	rcall	.+0      	; 0x2d64 <vTaskIncrementTick+0x8>
    2d64:	00 d0       	rcall	.+0      	; 0x2d66 <vTaskIncrementTick+0xa>
    2d66:	cd b7       	in	r28, 0x3d	; 61
    2d68:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d6a:	80 91 15 03 	lds	r24, 0x0315
    2d6e:	88 23       	and	r24, r24
    2d70:	09 f0       	breq	.+2      	; 0x2d74 <vTaskIncrementTick+0x18>
    2d72:	bb c0       	rjmp	.+374    	; 0x2eea <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2d74:	80 91 10 03 	lds	r24, 0x0310
    2d78:	90 91 11 03 	lds	r25, 0x0311
    2d7c:	01 96       	adiw	r24, 0x01	; 1
    2d7e:	90 93 11 03 	sts	0x0311, r25
    2d82:	80 93 10 03 	sts	0x0310, r24
		if( xTickCount == ( portTickType ) 0U )
    2d86:	80 91 10 03 	lds	r24, 0x0310
    2d8a:	90 91 11 03 	lds	r25, 0x0311
    2d8e:	00 97       	sbiw	r24, 0x00	; 0
    2d90:	d1 f5       	brne	.+116    	; 0x2e06 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2d92:	80 91 59 03 	lds	r24, 0x0359
    2d96:	90 91 5a 03 	lds	r25, 0x035A
    2d9a:	9c 83       	std	Y+4, r25	; 0x04
    2d9c:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2d9e:	80 91 5b 03 	lds	r24, 0x035B
    2da2:	90 91 5c 03 	lds	r25, 0x035C
    2da6:	90 93 5a 03 	sts	0x035A, r25
    2daa:	80 93 59 03 	sts	0x0359, r24
			pxOverflowDelayedTaskList = pxTemp;
    2dae:	8b 81       	ldd	r24, Y+3	; 0x03
    2db0:	9c 81       	ldd	r25, Y+4	; 0x04
    2db2:	90 93 5c 03 	sts	0x035C, r25
    2db6:	80 93 5b 03 	sts	0x035B, r24
			xNumOfOverflows++;
    2dba:	80 91 18 03 	lds	r24, 0x0318
    2dbe:	8f 5f       	subi	r24, 0xFF	; 255
    2dc0:	80 93 18 03 	sts	0x0318, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2dc4:	e0 91 59 03 	lds	r30, 0x0359
    2dc8:	f0 91 5a 03 	lds	r31, 0x035A
    2dcc:	80 81       	ld	r24, Z
    2dce:	88 23       	and	r24, r24
    2dd0:	39 f4       	brne	.+14     	; 0x2de0 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2dd2:	8f ef       	ldi	r24, 0xFF	; 255
    2dd4:	9f ef       	ldi	r25, 0xFF	; 255
    2dd6:	90 93 66 00 	sts	0x0066, r25
    2dda:	80 93 65 00 	sts	0x0065, r24
    2dde:	13 c0       	rjmp	.+38     	; 0x2e06 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2de0:	e0 91 59 03 	lds	r30, 0x0359
    2de4:	f0 91 5a 03 	lds	r31, 0x035A
    2de8:	05 80       	ldd	r0, Z+5	; 0x05
    2dea:	f6 81       	ldd	r31, Z+6	; 0x06
    2dec:	e0 2d       	mov	r30, r0
    2dee:	86 81       	ldd	r24, Z+6	; 0x06
    2df0:	97 81       	ldd	r25, Z+7	; 0x07
    2df2:	9e 83       	std	Y+6, r25	; 0x06
    2df4:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2df6:	ed 81       	ldd	r30, Y+5	; 0x05
    2df8:	fe 81       	ldd	r31, Y+6	; 0x06
    2dfa:	82 81       	ldd	r24, Z+2	; 0x02
    2dfc:	93 81       	ldd	r25, Z+3	; 0x03
    2dfe:	90 93 66 00 	sts	0x0066, r25
    2e02:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2e06:	20 91 10 03 	lds	r18, 0x0310
    2e0a:	30 91 11 03 	lds	r19, 0x0311
    2e0e:	80 91 65 00 	lds	r24, 0x0065
    2e12:	90 91 66 00 	lds	r25, 0x0066
    2e16:	28 17       	cp	r18, r24
    2e18:	39 07       	cpc	r19, r25
    2e1a:	08 f4       	brcc	.+2      	; 0x2e1e <vTaskIncrementTick+0xc2>
    2e1c:	6b c0       	rjmp	.+214    	; 0x2ef4 <vTaskIncrementTick+0x198>
    2e1e:	e0 91 59 03 	lds	r30, 0x0359
    2e22:	f0 91 5a 03 	lds	r31, 0x035A
    2e26:	80 81       	ld	r24, Z
    2e28:	88 23       	and	r24, r24
    2e2a:	39 f4       	brne	.+14     	; 0x2e3a <vTaskIncrementTick+0xde>
    2e2c:	8f ef       	ldi	r24, 0xFF	; 255
    2e2e:	9f ef       	ldi	r25, 0xFF	; 255
    2e30:	90 93 66 00 	sts	0x0066, r25
    2e34:	80 93 65 00 	sts	0x0065, r24
    2e38:	5d c0       	rjmp	.+186    	; 0x2ef4 <vTaskIncrementTick+0x198>
    2e3a:	e0 91 59 03 	lds	r30, 0x0359
    2e3e:	f0 91 5a 03 	lds	r31, 0x035A
    2e42:	05 80       	ldd	r0, Z+5	; 0x05
    2e44:	f6 81       	ldd	r31, Z+6	; 0x06
    2e46:	e0 2d       	mov	r30, r0
    2e48:	86 81       	ldd	r24, Z+6	; 0x06
    2e4a:	97 81       	ldd	r25, Z+7	; 0x07
    2e4c:	9e 83       	std	Y+6, r25	; 0x06
    2e4e:	8d 83       	std	Y+5, r24	; 0x05
    2e50:	ed 81       	ldd	r30, Y+5	; 0x05
    2e52:	fe 81       	ldd	r31, Y+6	; 0x06
    2e54:	82 81       	ldd	r24, Z+2	; 0x02
    2e56:	93 81       	ldd	r25, Z+3	; 0x03
    2e58:	9a 83       	std	Y+2, r25	; 0x02
    2e5a:	89 83       	std	Y+1, r24	; 0x01
    2e5c:	20 91 10 03 	lds	r18, 0x0310
    2e60:	30 91 11 03 	lds	r19, 0x0311
    2e64:	89 81       	ldd	r24, Y+1	; 0x01
    2e66:	9a 81       	ldd	r25, Y+2	; 0x02
    2e68:	28 17       	cp	r18, r24
    2e6a:	39 07       	cpc	r19, r25
    2e6c:	38 f4       	brcc	.+14     	; 0x2e7c <vTaskIncrementTick+0x120>
    2e6e:	89 81       	ldd	r24, Y+1	; 0x01
    2e70:	9a 81       	ldd	r25, Y+2	; 0x02
    2e72:	90 93 66 00 	sts	0x0066, r25
    2e76:	80 93 65 00 	sts	0x0065, r24
    2e7a:	3c c0       	rjmp	.+120    	; 0x2ef4 <vTaskIncrementTick+0x198>
    2e7c:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7e:	9e 81       	ldd	r25, Y+6	; 0x06
    2e80:	02 96       	adiw	r24, 0x02	; 2
    2e82:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
    2e86:	ed 81       	ldd	r30, Y+5	; 0x05
    2e88:	fe 81       	ldd	r31, Y+6	; 0x06
    2e8a:	84 89       	ldd	r24, Z+20	; 0x14
    2e8c:	95 89       	ldd	r25, Z+21	; 0x15
    2e8e:	00 97       	sbiw	r24, 0x00	; 0
    2e90:	29 f0       	breq	.+10     	; 0x2e9c <vTaskIncrementTick+0x140>
    2e92:	8d 81       	ldd	r24, Y+5	; 0x05
    2e94:	9e 81       	ldd	r25, Y+6	; 0x06
    2e96:	0c 96       	adiw	r24, 0x0c	; 12
    2e98:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
    2e9c:	ed 81       	ldd	r30, Y+5	; 0x05
    2e9e:	fe 81       	ldd	r31, Y+6	; 0x06
    2ea0:	96 89       	ldd	r25, Z+22	; 0x16
    2ea2:	80 91 13 03 	lds	r24, 0x0313
    2ea6:	89 17       	cp	r24, r25
    2ea8:	28 f4       	brcc	.+10     	; 0x2eb4 <vTaskIncrementTick+0x158>
    2eaa:	ed 81       	ldd	r30, Y+5	; 0x05
    2eac:	fe 81       	ldd	r31, Y+6	; 0x06
    2eae:	86 89       	ldd	r24, Z+22	; 0x16
    2eb0:	80 93 13 03 	sts	0x0313, r24
    2eb4:	ed 81       	ldd	r30, Y+5	; 0x05
    2eb6:	fe 81       	ldd	r31, Y+6	; 0x06
    2eb8:	86 89       	ldd	r24, Z+22	; 0x16
    2eba:	28 2f       	mov	r18, r24
    2ebc:	30 e0       	ldi	r19, 0x00	; 0
    2ebe:	c9 01       	movw	r24, r18
    2ec0:	88 0f       	add	r24, r24
    2ec2:	99 1f       	adc	r25, r25
    2ec4:	88 0f       	add	r24, r24
    2ec6:	99 1f       	adc	r25, r25
    2ec8:	88 0f       	add	r24, r24
    2eca:	99 1f       	adc	r25, r25
    2ecc:	82 0f       	add	r24, r18
    2ece:	93 1f       	adc	r25, r19
    2ed0:	ac 01       	movw	r20, r24
    2ed2:	46 5e       	subi	r20, 0xE6	; 230
    2ed4:	5c 4f       	sbci	r21, 0xFC	; 252
    2ed6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ed8:	9e 81       	ldd	r25, Y+6	; 0x06
    2eda:	9c 01       	movw	r18, r24
    2edc:	2e 5f       	subi	r18, 0xFE	; 254
    2ede:	3f 4f       	sbci	r19, 0xFF	; 255
    2ee0:	ca 01       	movw	r24, r20
    2ee2:	b9 01       	movw	r22, r18
    2ee4:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
    2ee8:	9a cf       	rjmp	.-204    	; 0x2e1e <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2eea:	80 91 16 03 	lds	r24, 0x0316
    2eee:	8f 5f       	subi	r24, 0xFF	; 255
    2ef0:	80 93 16 03 	sts	0x0316, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2ef4:	26 96       	adiw	r28, 0x06	; 6
    2ef6:	0f b6       	in	r0, 0x3f	; 63
    2ef8:	f8 94       	cli
    2efa:	de bf       	out	0x3e, r29	; 62
    2efc:	0f be       	out	0x3f, r0	; 63
    2efe:	cd bf       	out	0x3d, r28	; 61
    2f00:	cf 91       	pop	r28
    2f02:	df 91       	pop	r29
    2f04:	08 95       	ret

00002f06 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2f06:	df 93       	push	r29
    2f08:	cf 93       	push	r28
    2f0a:	00 d0       	rcall	.+0      	; 0x2f0c <vTaskSwitchContext+0x6>
    2f0c:	cd b7       	in	r28, 0x3d	; 61
    2f0e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2f10:	80 91 15 03 	lds	r24, 0x0315
    2f14:	88 23       	and	r24, r24
    2f16:	49 f0       	breq	.+18     	; 0x2f2a <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2f18:	81 e0       	ldi	r24, 0x01	; 1
    2f1a:	80 93 17 03 	sts	0x0317, r24
    2f1e:	54 c0       	rjmp	.+168    	; 0x2fc8 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2f20:	80 91 13 03 	lds	r24, 0x0313
    2f24:	81 50       	subi	r24, 0x01	; 1
    2f26:	80 93 13 03 	sts	0x0313, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2f2a:	80 91 13 03 	lds	r24, 0x0313
    2f2e:	28 2f       	mov	r18, r24
    2f30:	30 e0       	ldi	r19, 0x00	; 0
    2f32:	c9 01       	movw	r24, r18
    2f34:	88 0f       	add	r24, r24
    2f36:	99 1f       	adc	r25, r25
    2f38:	88 0f       	add	r24, r24
    2f3a:	99 1f       	adc	r25, r25
    2f3c:	88 0f       	add	r24, r24
    2f3e:	99 1f       	adc	r25, r25
    2f40:	82 0f       	add	r24, r18
    2f42:	93 1f       	adc	r25, r19
    2f44:	fc 01       	movw	r30, r24
    2f46:	e6 5e       	subi	r30, 0xE6	; 230
    2f48:	fc 4f       	sbci	r31, 0xFC	; 252
    2f4a:	80 81       	ld	r24, Z
    2f4c:	88 23       	and	r24, r24
    2f4e:	41 f3       	breq	.-48     	; 0x2f20 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2f50:	80 91 13 03 	lds	r24, 0x0313
    2f54:	28 2f       	mov	r18, r24
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	c9 01       	movw	r24, r18
    2f5a:	88 0f       	add	r24, r24
    2f5c:	99 1f       	adc	r25, r25
    2f5e:	88 0f       	add	r24, r24
    2f60:	99 1f       	adc	r25, r25
    2f62:	88 0f       	add	r24, r24
    2f64:	99 1f       	adc	r25, r25
    2f66:	82 0f       	add	r24, r18
    2f68:	93 1f       	adc	r25, r19
    2f6a:	86 5e       	subi	r24, 0xE6	; 230
    2f6c:	9c 4f       	sbci	r25, 0xFC	; 252
    2f6e:	9a 83       	std	Y+2, r25	; 0x02
    2f70:	89 83       	std	Y+1, r24	; 0x01
    2f72:	e9 81       	ldd	r30, Y+1	; 0x01
    2f74:	fa 81       	ldd	r31, Y+2	; 0x02
    2f76:	01 80       	ldd	r0, Z+1	; 0x01
    2f78:	f2 81       	ldd	r31, Z+2	; 0x02
    2f7a:	e0 2d       	mov	r30, r0
    2f7c:	82 81       	ldd	r24, Z+2	; 0x02
    2f7e:	93 81       	ldd	r25, Z+3	; 0x03
    2f80:	e9 81       	ldd	r30, Y+1	; 0x01
    2f82:	fa 81       	ldd	r31, Y+2	; 0x02
    2f84:	92 83       	std	Z+2, r25	; 0x02
    2f86:	81 83       	std	Z+1, r24	; 0x01
    2f88:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f8c:	21 81       	ldd	r18, Z+1	; 0x01
    2f8e:	32 81       	ldd	r19, Z+2	; 0x02
    2f90:	89 81       	ldd	r24, Y+1	; 0x01
    2f92:	9a 81       	ldd	r25, Y+2	; 0x02
    2f94:	03 96       	adiw	r24, 0x03	; 3
    2f96:	28 17       	cp	r18, r24
    2f98:	39 07       	cpc	r19, r25
    2f9a:	59 f4       	brne	.+22     	; 0x2fb2 <vTaskSwitchContext+0xac>
    2f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2fa0:	01 80       	ldd	r0, Z+1	; 0x01
    2fa2:	f2 81       	ldd	r31, Z+2	; 0x02
    2fa4:	e0 2d       	mov	r30, r0
    2fa6:	82 81       	ldd	r24, Z+2	; 0x02
    2fa8:	93 81       	ldd	r25, Z+3	; 0x03
    2faa:	e9 81       	ldd	r30, Y+1	; 0x01
    2fac:	fa 81       	ldd	r31, Y+2	; 0x02
    2fae:	92 83       	std	Z+2, r25	; 0x02
    2fb0:	81 83       	std	Z+1, r24	; 0x01
    2fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb6:	01 80       	ldd	r0, Z+1	; 0x01
    2fb8:	f2 81       	ldd	r31, Z+2	; 0x02
    2fba:	e0 2d       	mov	r30, r0
    2fbc:	86 81       	ldd	r24, Z+6	; 0x06
    2fbe:	97 81       	ldd	r25, Z+7	; 0x07
    2fc0:	90 93 0d 03 	sts	0x030D, r25
    2fc4:	80 93 0c 03 	sts	0x030C, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2fc8:	0f 90       	pop	r0
    2fca:	0f 90       	pop	r0
    2fcc:	cf 91       	pop	r28
    2fce:	df 91       	pop	r29
    2fd0:	08 95       	ret

00002fd2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2fd2:	df 93       	push	r29
    2fd4:	cf 93       	push	r28
    2fd6:	00 d0       	rcall	.+0      	; 0x2fd8 <vTaskPlaceOnEventList+0x6>
    2fd8:	00 d0       	rcall	.+0      	; 0x2fda <vTaskPlaceOnEventList+0x8>
    2fda:	00 d0       	rcall	.+0      	; 0x2fdc <vTaskPlaceOnEventList+0xa>
    2fdc:	cd b7       	in	r28, 0x3d	; 61
    2fde:	de b7       	in	r29, 0x3e	; 62
    2fe0:	9c 83       	std	Y+4, r25	; 0x04
    2fe2:	8b 83       	std	Y+3, r24	; 0x03
    2fe4:	7e 83       	std	Y+6, r23	; 0x06
    2fe6:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2fe8:	4b 81       	ldd	r20, Y+3	; 0x03
    2fea:	5c 81       	ldd	r21, Y+4	; 0x04
    2fec:	80 91 0c 03 	lds	r24, 0x030C
    2ff0:	90 91 0d 03 	lds	r25, 0x030D
    2ff4:	9c 01       	movw	r18, r24
    2ff6:	24 5f       	subi	r18, 0xF4	; 244
    2ff8:	3f 4f       	sbci	r19, 0xFF	; 255
    2ffa:	ca 01       	movw	r24, r20
    2ffc:	b9 01       	movw	r22, r18
    2ffe:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3002:	80 91 0c 03 	lds	r24, 0x030C
    3006:	90 91 0d 03 	lds	r25, 0x030D
    300a:	02 96       	adiw	r24, 0x02	; 2
    300c:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    3010:	8d 81       	ldd	r24, Y+5	; 0x05
    3012:	9e 81       	ldd	r25, Y+6	; 0x06
    3014:	2f ef       	ldi	r18, 0xFF	; 255
    3016:	8f 3f       	cpi	r24, 0xFF	; 255
    3018:	92 07       	cpc	r25, r18
    301a:	69 f4       	brne	.+26     	; 0x3036 <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    301c:	80 91 0c 03 	lds	r24, 0x030C
    3020:	90 91 0d 03 	lds	r25, 0x030D
    3024:	9c 01       	movw	r18, r24
    3026:	2e 5f       	subi	r18, 0xFE	; 254
    3028:	3f 4f       	sbci	r19, 0xFF	; 255
    302a:	8f e6       	ldi	r24, 0x6F	; 111
    302c:	93 e0       	ldi	r25, 0x03	; 3
    302e:	b9 01       	movw	r22, r18
    3030:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
    3034:	0e c0       	rjmp	.+28     	; 0x3052 <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3036:	20 91 10 03 	lds	r18, 0x0310
    303a:	30 91 11 03 	lds	r19, 0x0311
    303e:	8d 81       	ldd	r24, Y+5	; 0x05
    3040:	9e 81       	ldd	r25, Y+6	; 0x06
    3042:	82 0f       	add	r24, r18
    3044:	93 1f       	adc	r25, r19
    3046:	9a 83       	std	Y+2, r25	; 0x02
    3048:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	9a 81       	ldd	r25, Y+2	; 0x02
    304e:	0e 94 04 1a 	call	0x3408	; 0x3408 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    3052:	26 96       	adiw	r28, 0x06	; 6
    3054:	0f b6       	in	r0, 0x3f	; 63
    3056:	f8 94       	cli
    3058:	de bf       	out	0x3e, r29	; 62
    305a:	0f be       	out	0x3f, r0	; 63
    305c:	cd bf       	out	0x3d, r28	; 61
    305e:	cf 91       	pop	r28
    3060:	df 91       	pop	r29
    3062:	08 95       	ret

00003064 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3064:	df 93       	push	r29
    3066:	cf 93       	push	r28
    3068:	00 d0       	rcall	.+0      	; 0x306a <xTaskRemoveFromEventList+0x6>
    306a:	00 d0       	rcall	.+0      	; 0x306c <xTaskRemoveFromEventList+0x8>
    306c:	0f 92       	push	r0
    306e:	cd b7       	in	r28, 0x3d	; 61
    3070:	de b7       	in	r29, 0x3e	; 62
    3072:	9d 83       	std	Y+5, r25	; 0x05
    3074:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3076:	ec 81       	ldd	r30, Y+4	; 0x04
    3078:	fd 81       	ldd	r31, Y+5	; 0x05
    307a:	05 80       	ldd	r0, Z+5	; 0x05
    307c:	f6 81       	ldd	r31, Z+6	; 0x06
    307e:	e0 2d       	mov	r30, r0
    3080:	86 81       	ldd	r24, Z+6	; 0x06
    3082:	97 81       	ldd	r25, Z+7	; 0x07
    3084:	9b 83       	std	Y+3, r25	; 0x03
    3086:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3088:	8a 81       	ldd	r24, Y+2	; 0x02
    308a:	9b 81       	ldd	r25, Y+3	; 0x03
    308c:	0c 96       	adiw	r24, 0x0c	; 12
    308e:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3092:	80 91 15 03 	lds	r24, 0x0315
    3096:	88 23       	and	r24, r24
    3098:	61 f5       	brne	.+88     	; 0x30f2 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    309a:	8a 81       	ldd	r24, Y+2	; 0x02
    309c:	9b 81       	ldd	r25, Y+3	; 0x03
    309e:	02 96       	adiw	r24, 0x02	; 2
    30a0:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    30a4:	ea 81       	ldd	r30, Y+2	; 0x02
    30a6:	fb 81       	ldd	r31, Y+3	; 0x03
    30a8:	96 89       	ldd	r25, Z+22	; 0x16
    30aa:	80 91 13 03 	lds	r24, 0x0313
    30ae:	89 17       	cp	r24, r25
    30b0:	28 f4       	brcc	.+10     	; 0x30bc <xTaskRemoveFromEventList+0x58>
    30b2:	ea 81       	ldd	r30, Y+2	; 0x02
    30b4:	fb 81       	ldd	r31, Y+3	; 0x03
    30b6:	86 89       	ldd	r24, Z+22	; 0x16
    30b8:	80 93 13 03 	sts	0x0313, r24
    30bc:	ea 81       	ldd	r30, Y+2	; 0x02
    30be:	fb 81       	ldd	r31, Y+3	; 0x03
    30c0:	86 89       	ldd	r24, Z+22	; 0x16
    30c2:	28 2f       	mov	r18, r24
    30c4:	30 e0       	ldi	r19, 0x00	; 0
    30c6:	c9 01       	movw	r24, r18
    30c8:	88 0f       	add	r24, r24
    30ca:	99 1f       	adc	r25, r25
    30cc:	88 0f       	add	r24, r24
    30ce:	99 1f       	adc	r25, r25
    30d0:	88 0f       	add	r24, r24
    30d2:	99 1f       	adc	r25, r25
    30d4:	82 0f       	add	r24, r18
    30d6:	93 1f       	adc	r25, r19
    30d8:	ac 01       	movw	r20, r24
    30da:	46 5e       	subi	r20, 0xE6	; 230
    30dc:	5c 4f       	sbci	r21, 0xFC	; 252
    30de:	8a 81       	ldd	r24, Y+2	; 0x02
    30e0:	9b 81       	ldd	r25, Y+3	; 0x03
    30e2:	9c 01       	movw	r18, r24
    30e4:	2e 5f       	subi	r18, 0xFE	; 254
    30e6:	3f 4f       	sbci	r19, 0xFF	; 255
    30e8:	ca 01       	movw	r24, r20
    30ea:	b9 01       	movw	r22, r18
    30ec:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
    30f0:	0a c0       	rjmp	.+20     	; 0x3106 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    30f2:	8a 81       	ldd	r24, Y+2	; 0x02
    30f4:	9b 81       	ldd	r25, Y+3	; 0x03
    30f6:	9c 01       	movw	r18, r24
    30f8:	24 5f       	subi	r18, 0xF4	; 244
    30fa:	3f 4f       	sbci	r19, 0xFF	; 255
    30fc:	8d e5       	ldi	r24, 0x5D	; 93
    30fe:	93 e0       	ldi	r25, 0x03	; 3
    3100:	b9 01       	movw	r22, r18
    3102:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3106:	ea 81       	ldd	r30, Y+2	; 0x02
    3108:	fb 81       	ldd	r31, Y+3	; 0x03
    310a:	96 89       	ldd	r25, Z+22	; 0x16
    310c:	e0 91 0c 03 	lds	r30, 0x030C
    3110:	f0 91 0d 03 	lds	r31, 0x030D
    3114:	86 89       	ldd	r24, Z+22	; 0x16
    3116:	98 17       	cp	r25, r24
    3118:	18 f0       	brcs	.+6      	; 0x3120 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    311a:	81 e0       	ldi	r24, 0x01	; 1
    311c:	89 83       	std	Y+1, r24	; 0x01
    311e:	01 c0       	rjmp	.+2      	; 0x3122 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    3120:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3122:	89 81       	ldd	r24, Y+1	; 0x01
}
    3124:	0f 90       	pop	r0
    3126:	0f 90       	pop	r0
    3128:	0f 90       	pop	r0
    312a:	0f 90       	pop	r0
    312c:	0f 90       	pop	r0
    312e:	cf 91       	pop	r28
    3130:	df 91       	pop	r29
    3132:	08 95       	ret

00003134 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    3134:	df 93       	push	r29
    3136:	cf 93       	push	r28
    3138:	00 d0       	rcall	.+0      	; 0x313a <vTaskSetTimeOutState+0x6>
    313a:	cd b7       	in	r28, 0x3d	; 61
    313c:	de b7       	in	r29, 0x3e	; 62
    313e:	9a 83       	std	Y+2, r25	; 0x02
    3140:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3142:	80 91 18 03 	lds	r24, 0x0318
    3146:	e9 81       	ldd	r30, Y+1	; 0x01
    3148:	fa 81       	ldd	r31, Y+2	; 0x02
    314a:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    314c:	80 91 10 03 	lds	r24, 0x0310
    3150:	90 91 11 03 	lds	r25, 0x0311
    3154:	e9 81       	ldd	r30, Y+1	; 0x01
    3156:	fa 81       	ldd	r31, Y+2	; 0x02
    3158:	92 83       	std	Z+2, r25	; 0x02
    315a:	81 83       	std	Z+1, r24	; 0x01
}
    315c:	0f 90       	pop	r0
    315e:	0f 90       	pop	r0
    3160:	cf 91       	pop	r28
    3162:	df 91       	pop	r29
    3164:	08 95       	ret

00003166 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3166:	df 93       	push	r29
    3168:	cf 93       	push	r28
    316a:	00 d0       	rcall	.+0      	; 0x316c <xTaskCheckForTimeOut+0x6>
    316c:	00 d0       	rcall	.+0      	; 0x316e <xTaskCheckForTimeOut+0x8>
    316e:	0f 92       	push	r0
    3170:	cd b7       	in	r28, 0x3d	; 61
    3172:	de b7       	in	r29, 0x3e	; 62
    3174:	9b 83       	std	Y+3, r25	; 0x03
    3176:	8a 83       	std	Y+2, r24	; 0x02
    3178:	7d 83       	std	Y+5, r23	; 0x05
    317a:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    317c:	0f b6       	in	r0, 0x3f	; 63
    317e:	f8 94       	cli
    3180:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    3182:	ec 81       	ldd	r30, Y+4	; 0x04
    3184:	fd 81       	ldd	r31, Y+5	; 0x05
    3186:	80 81       	ld	r24, Z
    3188:	91 81       	ldd	r25, Z+1	; 0x01
    318a:	2f ef       	ldi	r18, 0xFF	; 255
    318c:	8f 3f       	cpi	r24, 0xFF	; 255
    318e:	92 07       	cpc	r25, r18
    3190:	11 f4       	brne	.+4      	; 0x3196 <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    3192:	19 82       	std	Y+1, r1	; 0x01
    3194:	44 c0       	rjmp	.+136    	; 0x321e <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3196:	ea 81       	ldd	r30, Y+2	; 0x02
    3198:	fb 81       	ldd	r31, Y+3	; 0x03
    319a:	90 81       	ld	r25, Z
    319c:	80 91 18 03 	lds	r24, 0x0318
    31a0:	98 17       	cp	r25, r24
    31a2:	71 f0       	breq	.+28     	; 0x31c0 <xTaskCheckForTimeOut+0x5a>
    31a4:	ea 81       	ldd	r30, Y+2	; 0x02
    31a6:	fb 81       	ldd	r31, Y+3	; 0x03
    31a8:	21 81       	ldd	r18, Z+1	; 0x01
    31aa:	32 81       	ldd	r19, Z+2	; 0x02
    31ac:	80 91 10 03 	lds	r24, 0x0310
    31b0:	90 91 11 03 	lds	r25, 0x0311
    31b4:	82 17       	cp	r24, r18
    31b6:	93 07       	cpc	r25, r19
    31b8:	18 f0       	brcs	.+6      	; 0x31c0 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    31ba:	81 e0       	ldi	r24, 0x01	; 1
    31bc:	89 83       	std	Y+1, r24	; 0x01
    31be:	2f c0       	rjmp	.+94     	; 0x321e <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    31c0:	20 91 10 03 	lds	r18, 0x0310
    31c4:	30 91 11 03 	lds	r19, 0x0311
    31c8:	ea 81       	ldd	r30, Y+2	; 0x02
    31ca:	fb 81       	ldd	r31, Y+3	; 0x03
    31cc:	81 81       	ldd	r24, Z+1	; 0x01
    31ce:	92 81       	ldd	r25, Z+2	; 0x02
    31d0:	28 1b       	sub	r18, r24
    31d2:	39 0b       	sbc	r19, r25
    31d4:	ec 81       	ldd	r30, Y+4	; 0x04
    31d6:	fd 81       	ldd	r31, Y+5	; 0x05
    31d8:	80 81       	ld	r24, Z
    31da:	91 81       	ldd	r25, Z+1	; 0x01
    31dc:	28 17       	cp	r18, r24
    31de:	39 07       	cpc	r19, r25
    31e0:	e0 f4       	brcc	.+56     	; 0x321a <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    31e2:	ec 81       	ldd	r30, Y+4	; 0x04
    31e4:	fd 81       	ldd	r31, Y+5	; 0x05
    31e6:	40 81       	ld	r20, Z
    31e8:	51 81       	ldd	r21, Z+1	; 0x01
    31ea:	ea 81       	ldd	r30, Y+2	; 0x02
    31ec:	fb 81       	ldd	r31, Y+3	; 0x03
    31ee:	21 81       	ldd	r18, Z+1	; 0x01
    31f0:	32 81       	ldd	r19, Z+2	; 0x02
    31f2:	80 91 10 03 	lds	r24, 0x0310
    31f6:	90 91 11 03 	lds	r25, 0x0311
    31fa:	b9 01       	movw	r22, r18
    31fc:	68 1b       	sub	r22, r24
    31fe:	79 0b       	sbc	r23, r25
    3200:	cb 01       	movw	r24, r22
    3202:	84 0f       	add	r24, r20
    3204:	95 1f       	adc	r25, r21
    3206:	ec 81       	ldd	r30, Y+4	; 0x04
    3208:	fd 81       	ldd	r31, Y+5	; 0x05
    320a:	91 83       	std	Z+1, r25	; 0x01
    320c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    320e:	8a 81       	ldd	r24, Y+2	; 0x02
    3210:	9b 81       	ldd	r25, Y+3	; 0x03
    3212:	0e 94 9a 18 	call	0x3134	; 0x3134 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3216:	19 82       	std	Y+1, r1	; 0x01
    3218:	02 c0       	rjmp	.+4      	; 0x321e <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    321a:	81 e0       	ldi	r24, 0x01	; 1
    321c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    321e:	0f 90       	pop	r0
    3220:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3222:	89 81       	ldd	r24, Y+1	; 0x01
}
    3224:	0f 90       	pop	r0
    3226:	0f 90       	pop	r0
    3228:	0f 90       	pop	r0
    322a:	0f 90       	pop	r0
    322c:	0f 90       	pop	r0
    322e:	cf 91       	pop	r28
    3230:	df 91       	pop	r29
    3232:	08 95       	ret

00003234 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3234:	df 93       	push	r29
    3236:	cf 93       	push	r28
    3238:	cd b7       	in	r28, 0x3d	; 61
    323a:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    323c:	81 e0       	ldi	r24, 0x01	; 1
    323e:	80 93 17 03 	sts	0x0317, r24
}
    3242:	cf 91       	pop	r28
    3244:	df 91       	pop	r29
    3246:	08 95       	ret

00003248 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3248:	df 93       	push	r29
    324a:	cf 93       	push	r28
    324c:	00 d0       	rcall	.+0      	; 0x324e <prvIdleTask+0x6>
    324e:	cd b7       	in	r28, 0x3d	; 61
    3250:	de b7       	in	r29, 0x3e	; 62
    3252:	9a 83       	std	Y+2, r25	; 0x02
    3254:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    3256:	0e 94 c6 19 	call	0x338c	; 0x338c <prvCheckTasksWaitingTermination>
    325a:	fd cf       	rjmp	.-6      	; 0x3256 <prvIdleTask+0xe>

0000325c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    325c:	0f 93       	push	r16
    325e:	1f 93       	push	r17
    3260:	df 93       	push	r29
    3262:	cf 93       	push	r28
    3264:	cd b7       	in	r28, 0x3d	; 61
    3266:	de b7       	in	r29, 0x3e	; 62
    3268:	29 97       	sbiw	r28, 0x09	; 9
    326a:	0f b6       	in	r0, 0x3f	; 63
    326c:	f8 94       	cli
    326e:	de bf       	out	0x3e, r29	; 62
    3270:	0f be       	out	0x3f, r0	; 63
    3272:	cd bf       	out	0x3d, r28	; 61
    3274:	9a 83       	std	Y+2, r25	; 0x02
    3276:	89 83       	std	Y+1, r24	; 0x01
    3278:	7c 83       	std	Y+4, r23	; 0x04
    327a:	6b 83       	std	Y+3, r22	; 0x03
    327c:	4d 83       	std	Y+5, r20	; 0x05
    327e:	3f 83       	std	Y+7, r19	; 0x07
    3280:	2e 83       	std	Y+6, r18	; 0x06
    3282:	19 87       	std	Y+9, r17	; 0x09
    3284:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    3286:	89 81       	ldd	r24, Y+1	; 0x01
    3288:	9a 81       	ldd	r25, Y+2	; 0x02
    328a:	49 96       	adiw	r24, 0x19	; 25
    328c:	2b 81       	ldd	r18, Y+3	; 0x03
    328e:	3c 81       	ldd	r19, Y+4	; 0x04
    3290:	b9 01       	movw	r22, r18
    3292:	48 e0       	ldi	r20, 0x08	; 8
    3294:	50 e0       	ldi	r21, 0x00	; 0
    3296:	0e 94 c3 1a 	call	0x3586	; 0x3586 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    329a:	e9 81       	ldd	r30, Y+1	; 0x01
    329c:	fa 81       	ldd	r31, Y+2	; 0x02
    329e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    32a0:	8d 81       	ldd	r24, Y+5	; 0x05
    32a2:	85 30       	cpi	r24, 0x05	; 5
    32a4:	10 f0       	brcs	.+4      	; 0x32aa <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    32a6:	84 e0       	ldi	r24, 0x04	; 4
    32a8:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    32aa:	e9 81       	ldd	r30, Y+1	; 0x01
    32ac:	fa 81       	ldd	r31, Y+2	; 0x02
    32ae:	8d 81       	ldd	r24, Y+5	; 0x05
    32b0:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    32b2:	89 81       	ldd	r24, Y+1	; 0x01
    32b4:	9a 81       	ldd	r25, Y+2	; 0x02
    32b6:	02 96       	adiw	r24, 0x02	; 2
    32b8:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    32bc:	89 81       	ldd	r24, Y+1	; 0x01
    32be:	9a 81       	ldd	r25, Y+2	; 0x02
    32c0:	0c 96       	adiw	r24, 0x0c	; 12
    32c2:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    32c6:	e9 81       	ldd	r30, Y+1	; 0x01
    32c8:	fa 81       	ldd	r31, Y+2	; 0x02
    32ca:	89 81       	ldd	r24, Y+1	; 0x01
    32cc:	9a 81       	ldd	r25, Y+2	; 0x02
    32ce:	91 87       	std	Z+9, r25	; 0x09
    32d0:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    32d2:	8d 81       	ldd	r24, Y+5	; 0x05
    32d4:	28 2f       	mov	r18, r24
    32d6:	30 e0       	ldi	r19, 0x00	; 0
    32d8:	85 e0       	ldi	r24, 0x05	; 5
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	82 1b       	sub	r24, r18
    32de:	93 0b       	sbc	r25, r19
    32e0:	e9 81       	ldd	r30, Y+1	; 0x01
    32e2:	fa 81       	ldd	r31, Y+2	; 0x02
    32e4:	95 87       	std	Z+13, r25	; 0x0d
    32e6:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    32e8:	e9 81       	ldd	r30, Y+1	; 0x01
    32ea:	fa 81       	ldd	r31, Y+2	; 0x02
    32ec:	89 81       	ldd	r24, Y+1	; 0x01
    32ee:	9a 81       	ldd	r25, Y+2	; 0x02
    32f0:	93 8b       	std	Z+19, r25	; 0x13
    32f2:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    32f4:	29 96       	adiw	r28, 0x09	; 9
    32f6:	0f b6       	in	r0, 0x3f	; 63
    32f8:	f8 94       	cli
    32fa:	de bf       	out	0x3e, r29	; 62
    32fc:	0f be       	out	0x3f, r0	; 63
    32fe:	cd bf       	out	0x3d, r28	; 61
    3300:	cf 91       	pop	r28
    3302:	df 91       	pop	r29
    3304:	1f 91       	pop	r17
    3306:	0f 91       	pop	r16
    3308:	08 95       	ret

0000330a <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    330a:	df 93       	push	r29
    330c:	cf 93       	push	r28
    330e:	0f 92       	push	r0
    3310:	cd b7       	in	r28, 0x3d	; 61
    3312:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3314:	19 82       	std	Y+1, r1	; 0x01
    3316:	13 c0       	rjmp	.+38     	; 0x333e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    3318:	89 81       	ldd	r24, Y+1	; 0x01
    331a:	28 2f       	mov	r18, r24
    331c:	30 e0       	ldi	r19, 0x00	; 0
    331e:	c9 01       	movw	r24, r18
    3320:	88 0f       	add	r24, r24
    3322:	99 1f       	adc	r25, r25
    3324:	88 0f       	add	r24, r24
    3326:	99 1f       	adc	r25, r25
    3328:	88 0f       	add	r24, r24
    332a:	99 1f       	adc	r25, r25
    332c:	82 0f       	add	r24, r18
    332e:	93 1f       	adc	r25, r19
    3330:	86 5e       	subi	r24, 0xE6	; 230
    3332:	9c 4f       	sbci	r25, 0xFC	; 252
    3334:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3338:	89 81       	ldd	r24, Y+1	; 0x01
    333a:	8f 5f       	subi	r24, 0xFF	; 255
    333c:	89 83       	std	Y+1, r24	; 0x01
    333e:	89 81       	ldd	r24, Y+1	; 0x01
    3340:	85 30       	cpi	r24, 0x05	; 5
    3342:	50 f3       	brcs	.-44     	; 0x3318 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    3344:	87 e4       	ldi	r24, 0x47	; 71
    3346:	93 e0       	ldi	r25, 0x03	; 3
    3348:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    334c:	80 e5       	ldi	r24, 0x50	; 80
    334e:	93 e0       	ldi	r25, 0x03	; 3
    3350:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    3354:	8d e5       	ldi	r24, 0x5D	; 93
    3356:	93 e0       	ldi	r25, 0x03	; 3
    3358:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    335c:	86 e6       	ldi	r24, 0x66	; 102
    335e:	93 e0       	ldi	r25, 0x03	; 3
    3360:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    3364:	8f e6       	ldi	r24, 0x6F	; 111
    3366:	93 e0       	ldi	r25, 0x03	; 3
    3368:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    336c:	87 e4       	ldi	r24, 0x47	; 71
    336e:	93 e0       	ldi	r25, 0x03	; 3
    3370:	90 93 5a 03 	sts	0x035A, r25
    3374:	80 93 59 03 	sts	0x0359, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3378:	80 e5       	ldi	r24, 0x50	; 80
    337a:	93 e0       	ldi	r25, 0x03	; 3
    337c:	90 93 5c 03 	sts	0x035C, r25
    3380:	80 93 5b 03 	sts	0x035B, r24
}
    3384:	0f 90       	pop	r0
    3386:	cf 91       	pop	r28
    3388:	df 91       	pop	r29
    338a:	08 95       	ret

0000338c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    338c:	df 93       	push	r29
    338e:	cf 93       	push	r28
    3390:	00 d0       	rcall	.+0      	; 0x3392 <prvCheckTasksWaitingTermination+0x6>
    3392:	0f 92       	push	r0
    3394:	cd b7       	in	r28, 0x3d	; 61
    3396:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    3398:	80 91 0e 03 	lds	r24, 0x030E
    339c:	88 23       	and	r24, r24
    339e:	71 f1       	breq	.+92     	; 0x33fc <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    33a0:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    33a4:	80 91 66 03 	lds	r24, 0x0366
    33a8:	1b 82       	std	Y+3, r1	; 0x03
    33aa:	88 23       	and	r24, r24
    33ac:	11 f4       	brne	.+4      	; 0x33b2 <prvCheckTasksWaitingTermination+0x26>
    33ae:	81 e0       	ldi	r24, 0x01	; 1
    33b0:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    33b2:	0e 94 ef 15 	call	0x2bde	; 0x2bde <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    33b6:	8b 81       	ldd	r24, Y+3	; 0x03
    33b8:	88 23       	and	r24, r24
    33ba:	01 f5       	brne	.+64     	; 0x33fc <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    33bc:	0f b6       	in	r0, 0x3f	; 63
    33be:	f8 94       	cli
    33c0:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    33c2:	e0 91 6b 03 	lds	r30, 0x036B
    33c6:	f0 91 6c 03 	lds	r31, 0x036C
    33ca:	86 81       	ldd	r24, Z+6	; 0x06
    33cc:	97 81       	ldd	r25, Z+7	; 0x07
    33ce:	9a 83       	std	Y+2, r25	; 0x02
    33d0:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    33d2:	89 81       	ldd	r24, Y+1	; 0x01
    33d4:	9a 81       	ldd	r25, Y+2	; 0x02
    33d6:	02 96       	adiw	r24, 0x02	; 2
    33d8:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
					--uxCurrentNumberOfTasks;
    33dc:	80 91 0f 03 	lds	r24, 0x030F
    33e0:	81 50       	subi	r24, 0x01	; 1
    33e2:	80 93 0f 03 	sts	0x030F, r24
					--uxTasksDeleted;
    33e6:	80 91 0e 03 	lds	r24, 0x030E
    33ea:	81 50       	subi	r24, 0x01	; 1
    33ec:	80 93 0e 03 	sts	0x030E, r24
				}
				taskEXIT_CRITICAL();
    33f0:	0f 90       	pop	r0
    33f2:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    33f4:	89 81       	ldd	r24, Y+1	; 0x01
    33f6:	9a 81       	ldd	r25, Y+2	; 0x02
    33f8:	0e 94 9d 1a 	call	0x353a	; 0x353a <prvDeleteTCB>
			}
		}
	}
	#endif
}
    33fc:	0f 90       	pop	r0
    33fe:	0f 90       	pop	r0
    3400:	0f 90       	pop	r0
    3402:	cf 91       	pop	r28
    3404:	df 91       	pop	r29
    3406:	08 95       	ret

00003408 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    3408:	df 93       	push	r29
    340a:	cf 93       	push	r28
    340c:	00 d0       	rcall	.+0      	; 0x340e <prvAddCurrentTaskToDelayedList+0x6>
    340e:	cd b7       	in	r28, 0x3d	; 61
    3410:	de b7       	in	r29, 0x3e	; 62
    3412:	9a 83       	std	Y+2, r25	; 0x02
    3414:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    3416:	e0 91 0c 03 	lds	r30, 0x030C
    341a:	f0 91 0d 03 	lds	r31, 0x030D
    341e:	89 81       	ldd	r24, Y+1	; 0x01
    3420:	9a 81       	ldd	r25, Y+2	; 0x02
    3422:	93 83       	std	Z+3, r25	; 0x03
    3424:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    3426:	20 91 10 03 	lds	r18, 0x0310
    342a:	30 91 11 03 	lds	r19, 0x0311
    342e:	89 81       	ldd	r24, Y+1	; 0x01
    3430:	9a 81       	ldd	r25, Y+2	; 0x02
    3432:	82 17       	cp	r24, r18
    3434:	93 07       	cpc	r25, r19
    3436:	70 f4       	brcc	.+28     	; 0x3454 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3438:	80 91 5b 03 	lds	r24, 0x035B
    343c:	90 91 5c 03 	lds	r25, 0x035C
    3440:	20 91 0c 03 	lds	r18, 0x030C
    3444:	30 91 0d 03 	lds	r19, 0x030D
    3448:	2e 5f       	subi	r18, 0xFE	; 254
    344a:	3f 4f       	sbci	r19, 0xFF	; 255
    344c:	b9 01       	movw	r22, r18
    344e:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
    3452:	1e c0       	rjmp	.+60     	; 0x3490 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3454:	40 91 59 03 	lds	r20, 0x0359
    3458:	50 91 5a 03 	lds	r21, 0x035A
    345c:	80 91 0c 03 	lds	r24, 0x030C
    3460:	90 91 0d 03 	lds	r25, 0x030D
    3464:	9c 01       	movw	r18, r24
    3466:	2e 5f       	subi	r18, 0xFE	; 254
    3468:	3f 4f       	sbci	r19, 0xFF	; 255
    346a:	ca 01       	movw	r24, r20
    346c:	b9 01       	movw	r22, r18
    346e:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3472:	20 91 65 00 	lds	r18, 0x0065
    3476:	30 91 66 00 	lds	r19, 0x0066
    347a:	89 81       	ldd	r24, Y+1	; 0x01
    347c:	9a 81       	ldd	r25, Y+2	; 0x02
    347e:	82 17       	cp	r24, r18
    3480:	93 07       	cpc	r25, r19
    3482:	30 f4       	brcc	.+12     	; 0x3490 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3484:	89 81       	ldd	r24, Y+1	; 0x01
    3486:	9a 81       	ldd	r25, Y+2	; 0x02
    3488:	90 93 66 00 	sts	0x0066, r25
    348c:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    3490:	0f 90       	pop	r0
    3492:	0f 90       	pop	r0
    3494:	cf 91       	pop	r28
    3496:	df 91       	pop	r29
    3498:	08 95       	ret

0000349a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    349a:	df 93       	push	r29
    349c:	cf 93       	push	r28
    349e:	cd b7       	in	r28, 0x3d	; 61
    34a0:	de b7       	in	r29, 0x3e	; 62
    34a2:	28 97       	sbiw	r28, 0x08	; 8
    34a4:	0f b6       	in	r0, 0x3f	; 63
    34a6:	f8 94       	cli
    34a8:	de bf       	out	0x3e, r29	; 62
    34aa:	0f be       	out	0x3f, r0	; 63
    34ac:	cd bf       	out	0x3d, r28	; 61
    34ae:	9c 83       	std	Y+4, r25	; 0x04
    34b0:	8b 83       	std	Y+3, r24	; 0x03
    34b2:	7e 83       	std	Y+6, r23	; 0x06
    34b4:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    34b6:	81 e2       	ldi	r24, 0x21	; 33
    34b8:	90 e0       	ldi	r25, 0x00	; 0
    34ba:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    34be:	9a 83       	std	Y+2, r25	; 0x02
    34c0:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    34c2:	89 81       	ldd	r24, Y+1	; 0x01
    34c4:	9a 81       	ldd	r25, Y+2	; 0x02
    34c6:	00 97       	sbiw	r24, 0x00	; 0
    34c8:	69 f1       	breq	.+90     	; 0x3524 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    34ca:	8d 81       	ldd	r24, Y+5	; 0x05
    34cc:	9e 81       	ldd	r25, Y+6	; 0x06
    34ce:	00 97       	sbiw	r24, 0x00	; 0
    34d0:	39 f4       	brne	.+14     	; 0x34e0 <prvAllocateTCBAndStack+0x46>
    34d2:	8b 81       	ldd	r24, Y+3	; 0x03
    34d4:	9c 81       	ldd	r25, Y+4	; 0x04
    34d6:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    34da:	98 87       	std	Y+8, r25	; 0x08
    34dc:	8f 83       	std	Y+7, r24	; 0x07
    34de:	04 c0       	rjmp	.+8      	; 0x34e8 <prvAllocateTCBAndStack+0x4e>
    34e0:	8d 81       	ldd	r24, Y+5	; 0x05
    34e2:	9e 81       	ldd	r25, Y+6	; 0x06
    34e4:	98 87       	std	Y+8, r25	; 0x08
    34e6:	8f 83       	std	Y+7, r24	; 0x07
    34e8:	e9 81       	ldd	r30, Y+1	; 0x01
    34ea:	fa 81       	ldd	r31, Y+2	; 0x02
    34ec:	8f 81       	ldd	r24, Y+7	; 0x07
    34ee:	98 85       	ldd	r25, Y+8	; 0x08
    34f0:	90 8f       	std	Z+24, r25	; 0x18
    34f2:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    34f4:	e9 81       	ldd	r30, Y+1	; 0x01
    34f6:	fa 81       	ldd	r31, Y+2	; 0x02
    34f8:	87 89       	ldd	r24, Z+23	; 0x17
    34fa:	90 8d       	ldd	r25, Z+24	; 0x18
    34fc:	00 97       	sbiw	r24, 0x00	; 0
    34fe:	39 f4       	brne	.+14     	; 0x350e <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3500:	89 81       	ldd	r24, Y+1	; 0x01
    3502:	9a 81       	ldd	r25, Y+2	; 0x02
    3504:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
			pxNewTCB = NULL;
    3508:	1a 82       	std	Y+2, r1	; 0x02
    350a:	19 82       	std	Y+1, r1	; 0x01
    350c:	0b c0       	rjmp	.+22     	; 0x3524 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    350e:	e9 81       	ldd	r30, Y+1	; 0x01
    3510:	fa 81       	ldd	r31, Y+2	; 0x02
    3512:	87 89       	ldd	r24, Z+23	; 0x17
    3514:	90 8d       	ldd	r25, Z+24	; 0x18
    3516:	2b 81       	ldd	r18, Y+3	; 0x03
    3518:	3c 81       	ldd	r19, Y+4	; 0x04
    351a:	65 ea       	ldi	r22, 0xA5	; 165
    351c:	70 e0       	ldi	r23, 0x00	; 0
    351e:	a9 01       	movw	r20, r18
    3520:	0e 94 bc 1a 	call	0x3578	; 0x3578 <memset>
		}
	}

	return pxNewTCB;
    3524:	89 81       	ldd	r24, Y+1	; 0x01
    3526:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3528:	28 96       	adiw	r28, 0x08	; 8
    352a:	0f b6       	in	r0, 0x3f	; 63
    352c:	f8 94       	cli
    352e:	de bf       	out	0x3e, r29	; 62
    3530:	0f be       	out	0x3f, r0	; 63
    3532:	cd bf       	out	0x3d, r28	; 61
    3534:	cf 91       	pop	r28
    3536:	df 91       	pop	r29
    3538:	08 95       	ret

0000353a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    353a:	df 93       	push	r29
    353c:	cf 93       	push	r28
    353e:	00 d0       	rcall	.+0      	; 0x3540 <prvDeleteTCB+0x6>
    3540:	cd b7       	in	r28, 0x3d	; 61
    3542:	de b7       	in	r29, 0x3e	; 62
    3544:	9a 83       	std	Y+2, r25	; 0x02
    3546:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    3548:	e9 81       	ldd	r30, Y+1	; 0x01
    354a:	fa 81       	ldd	r31, Y+2	; 0x02
    354c:	87 89       	ldd	r24, Z+23	; 0x17
    354e:	90 8d       	ldd	r25, Z+24	; 0x18
    3550:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
		vPortFree( pxTCB );
    3554:	89 81       	ldd	r24, Y+1	; 0x01
    3556:	9a 81       	ldd	r25, Y+2	; 0x02
    3558:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
	}
    355c:	0f 90       	pop	r0
    355e:	0f 90       	pop	r0
    3560:	cf 91       	pop	r28
    3562:	df 91       	pop	r29
    3564:	08 95       	ret

00003566 <memcpy>:
    3566:	fb 01       	movw	r30, r22
    3568:	dc 01       	movw	r26, r24
    356a:	02 c0       	rjmp	.+4      	; 0x3570 <memcpy+0xa>
    356c:	01 90       	ld	r0, Z+
    356e:	0d 92       	st	X+, r0
    3570:	41 50       	subi	r20, 0x01	; 1
    3572:	50 40       	sbci	r21, 0x00	; 0
    3574:	d8 f7       	brcc	.-10     	; 0x356c <memcpy+0x6>
    3576:	08 95       	ret

00003578 <memset>:
    3578:	dc 01       	movw	r26, r24
    357a:	01 c0       	rjmp	.+2      	; 0x357e <memset+0x6>
    357c:	6d 93       	st	X+, r22
    357e:	41 50       	subi	r20, 0x01	; 1
    3580:	50 40       	sbci	r21, 0x00	; 0
    3582:	e0 f7       	brcc	.-8      	; 0x357c <memset+0x4>
    3584:	08 95       	ret

00003586 <strncpy>:
    3586:	fb 01       	movw	r30, r22
    3588:	dc 01       	movw	r26, r24
    358a:	41 50       	subi	r20, 0x01	; 1
    358c:	50 40       	sbci	r21, 0x00	; 0
    358e:	48 f0       	brcs	.+18     	; 0x35a2 <strncpy+0x1c>
    3590:	01 90       	ld	r0, Z+
    3592:	0d 92       	st	X+, r0
    3594:	00 20       	and	r0, r0
    3596:	c9 f7       	brne	.-14     	; 0x358a <strncpy+0x4>
    3598:	01 c0       	rjmp	.+2      	; 0x359c <strncpy+0x16>
    359a:	1d 92       	st	X+, r1
    359c:	41 50       	subi	r20, 0x01	; 1
    359e:	50 40       	sbci	r21, 0x00	; 0
    35a0:	e0 f7       	brcc	.-8      	; 0x359a <strncpy+0x14>
    35a2:	08 95       	ret

000035a4 <_exit>:
    35a4:	f8 94       	cli

000035a6 <__stop_program>:
    35a6:	ff cf       	rjmp	.-2      	; 0x35a6 <__stop_program>
