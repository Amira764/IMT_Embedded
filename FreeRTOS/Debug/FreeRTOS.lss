
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003280  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00003280  00003314  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000300  00800068  00800068  0000331c  2**0
                  ALLOC
  3 .stab         000050a0  00000000  00000000  0000331c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002e93  00000000  00000000  000083bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 e1 04 	jmp	0x9c2	; 0x9c2 <__vector_1>
       8:	0c 94 0e 05 	jmp	0xa1c	; 0xa1c <__vector_2>
       c:	0c 94 3b 05 	jmp	0xa76	; 0xa76 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 b0 0d 	jmp	0x1b60	; 0x1b60 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e8       	ldi	r30, 0x80	; 128
      68:	f2 e3       	ldi	r31, 0x32	; 50
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 36       	cpi	r26, 0x68	; 104
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <main>
      8a:	0c 94 3e 19 	jmp	0x327c	; 0x327c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_SetPinDirection>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_SetPinDirection+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <DIO_SetPinDirection+0x8>
      9a:	0f 92       	push	r0
      9c:	cd b7       	in	r28, 0x3d	; 61
      9e:	de b7       	in	r29, 0x3e	; 62
      a0:	89 83       	std	Y+1, r24	; 0x01
      a2:	6a 83       	std	Y+2, r22	; 0x02
      a4:	4b 83       	std	Y+3, r20	; 0x03
      a6:	89 81       	ldd	r24, Y+1	; 0x01
      a8:	28 2f       	mov	r18, r24
      aa:	30 e0       	ldi	r19, 0x00	; 0
      ac:	3d 83       	std	Y+5, r19	; 0x05
      ae:	2c 83       	std	Y+4, r18	; 0x04
      b0:	8c 81       	ldd	r24, Y+4	; 0x04
      b2:	9d 81       	ldd	r25, Y+5	; 0x05
      b4:	81 30       	cpi	r24, 0x01	; 1
      b6:	91 05       	cpc	r25, r1
      b8:	09 f4       	brne	.+2      	; 0xbc <DIO_SetPinDirection+0x2a>
      ba:	47 c0       	rjmp	.+142    	; 0x14a <DIO_SetPinDirection+0xb8>
      bc:	2c 81       	ldd	r18, Y+4	; 0x04
      be:	3d 81       	ldd	r19, Y+5	; 0x05
      c0:	22 30       	cpi	r18, 0x02	; 2
      c2:	31 05       	cpc	r19, r1
      c4:	2c f4       	brge	.+10     	; 0xd0 <DIO_SetPinDirection+0x3e>
      c6:	8c 81       	ldd	r24, Y+4	; 0x04
      c8:	9d 81       	ldd	r25, Y+5	; 0x05
      ca:	00 97       	sbiw	r24, 0x00	; 0
      cc:	71 f0       	breq	.+28     	; 0xea <DIO_SetPinDirection+0x58>
      ce:	cb c0       	rjmp	.+406    	; 0x266 <DIO_SetPinDirection+0x1d4>
      d0:	2c 81       	ldd	r18, Y+4	; 0x04
      d2:	3d 81       	ldd	r19, Y+5	; 0x05
      d4:	22 30       	cpi	r18, 0x02	; 2
      d6:	31 05       	cpc	r19, r1
      d8:	09 f4       	brne	.+2      	; 0xdc <DIO_SetPinDirection+0x4a>
      da:	67 c0       	rjmp	.+206    	; 0x1aa <DIO_SetPinDirection+0x118>
      dc:	8c 81       	ldd	r24, Y+4	; 0x04
      de:	9d 81       	ldd	r25, Y+5	; 0x05
      e0:	83 30       	cpi	r24, 0x03	; 3
      e2:	91 05       	cpc	r25, r1
      e4:	09 f4       	brne	.+2      	; 0xe8 <DIO_SetPinDirection+0x56>
      e6:	91 c0       	rjmp	.+290    	; 0x20a <DIO_SetPinDirection+0x178>
      e8:	be c0       	rjmp	.+380    	; 0x266 <DIO_SetPinDirection+0x1d4>
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	88 23       	and	r24, r24
      ee:	a9 f4       	brne	.+42     	; 0x11a <DIO_SetPinDirection+0x88>
      f0:	aa e3       	ldi	r26, 0x3A	; 58
      f2:	b0 e0       	ldi	r27, 0x00	; 0
      f4:	ea e3       	ldi	r30, 0x3A	; 58
      f6:	f0 e0       	ldi	r31, 0x00	; 0
      f8:	80 81       	ld	r24, Z
      fa:	48 2f       	mov	r20, r24
      fc:	8a 81       	ldd	r24, Y+2	; 0x02
      fe:	28 2f       	mov	r18, r24
     100:	30 e0       	ldi	r19, 0x00	; 0
     102:	81 e0       	ldi	r24, 0x01	; 1
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	02 2e       	mov	r0, r18
     108:	02 c0       	rjmp	.+4      	; 0x10e <DIO_SetPinDirection+0x7c>
     10a:	88 0f       	add	r24, r24
     10c:	99 1f       	adc	r25, r25
     10e:	0a 94       	dec	r0
     110:	e2 f7       	brpl	.-8      	; 0x10a <DIO_SetPinDirection+0x78>
     112:	80 95       	com	r24
     114:	84 23       	and	r24, r20
     116:	8c 93       	st	X, r24
     118:	a6 c0       	rjmp	.+332    	; 0x266 <DIO_SetPinDirection+0x1d4>
     11a:	8b 81       	ldd	r24, Y+3	; 0x03
     11c:	81 30       	cpi	r24, 0x01	; 1
     11e:	09 f0       	breq	.+2      	; 0x122 <DIO_SetPinDirection+0x90>
     120:	a2 c0       	rjmp	.+324    	; 0x266 <DIO_SetPinDirection+0x1d4>
     122:	aa e3       	ldi	r26, 0x3A	; 58
     124:	b0 e0       	ldi	r27, 0x00	; 0
     126:	ea e3       	ldi	r30, 0x3A	; 58
     128:	f0 e0       	ldi	r31, 0x00	; 0
     12a:	80 81       	ld	r24, Z
     12c:	48 2f       	mov	r20, r24
     12e:	8a 81       	ldd	r24, Y+2	; 0x02
     130:	28 2f       	mov	r18, r24
     132:	30 e0       	ldi	r19, 0x00	; 0
     134:	81 e0       	ldi	r24, 0x01	; 1
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	02 2e       	mov	r0, r18
     13a:	02 c0       	rjmp	.+4      	; 0x140 <DIO_SetPinDirection+0xae>
     13c:	88 0f       	add	r24, r24
     13e:	99 1f       	adc	r25, r25
     140:	0a 94       	dec	r0
     142:	e2 f7       	brpl	.-8      	; 0x13c <DIO_SetPinDirection+0xaa>
     144:	84 2b       	or	r24, r20
     146:	8c 93       	st	X, r24
     148:	8e c0       	rjmp	.+284    	; 0x266 <DIO_SetPinDirection+0x1d4>
     14a:	8b 81       	ldd	r24, Y+3	; 0x03
     14c:	88 23       	and	r24, r24
     14e:	a9 f4       	brne	.+42     	; 0x17a <DIO_SetPinDirection+0xe8>
     150:	a7 e3       	ldi	r26, 0x37	; 55
     152:	b0 e0       	ldi	r27, 0x00	; 0
     154:	e7 e3       	ldi	r30, 0x37	; 55
     156:	f0 e0       	ldi	r31, 0x00	; 0
     158:	80 81       	ld	r24, Z
     15a:	48 2f       	mov	r20, r24
     15c:	8a 81       	ldd	r24, Y+2	; 0x02
     15e:	28 2f       	mov	r18, r24
     160:	30 e0       	ldi	r19, 0x00	; 0
     162:	81 e0       	ldi	r24, 0x01	; 1
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	02 2e       	mov	r0, r18
     168:	02 c0       	rjmp	.+4      	; 0x16e <DIO_SetPinDirection+0xdc>
     16a:	88 0f       	add	r24, r24
     16c:	99 1f       	adc	r25, r25
     16e:	0a 94       	dec	r0
     170:	e2 f7       	brpl	.-8      	; 0x16a <DIO_SetPinDirection+0xd8>
     172:	80 95       	com	r24
     174:	84 23       	and	r24, r20
     176:	8c 93       	st	X, r24
     178:	76 c0       	rjmp	.+236    	; 0x266 <DIO_SetPinDirection+0x1d4>
     17a:	8b 81       	ldd	r24, Y+3	; 0x03
     17c:	81 30       	cpi	r24, 0x01	; 1
     17e:	09 f0       	breq	.+2      	; 0x182 <DIO_SetPinDirection+0xf0>
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_SetPinDirection+0x1d4>
     182:	a7 e3       	ldi	r26, 0x37	; 55
     184:	b0 e0       	ldi	r27, 0x00	; 0
     186:	e7 e3       	ldi	r30, 0x37	; 55
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	80 81       	ld	r24, Z
     18c:	48 2f       	mov	r20, r24
     18e:	8a 81       	ldd	r24, Y+2	; 0x02
     190:	28 2f       	mov	r18, r24
     192:	30 e0       	ldi	r19, 0x00	; 0
     194:	81 e0       	ldi	r24, 0x01	; 1
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	02 2e       	mov	r0, r18
     19a:	02 c0       	rjmp	.+4      	; 0x1a0 <DIO_SetPinDirection+0x10e>
     19c:	88 0f       	add	r24, r24
     19e:	99 1f       	adc	r25, r25
     1a0:	0a 94       	dec	r0
     1a2:	e2 f7       	brpl	.-8      	; 0x19c <DIO_SetPinDirection+0x10a>
     1a4:	84 2b       	or	r24, r20
     1a6:	8c 93       	st	X, r24
     1a8:	5e c0       	rjmp	.+188    	; 0x266 <DIO_SetPinDirection+0x1d4>
     1aa:	8b 81       	ldd	r24, Y+3	; 0x03
     1ac:	88 23       	and	r24, r24
     1ae:	a9 f4       	brne	.+42     	; 0x1da <DIO_SetPinDirection+0x148>
     1b0:	a4 e3       	ldi	r26, 0x34	; 52
     1b2:	b0 e0       	ldi	r27, 0x00	; 0
     1b4:	e4 e3       	ldi	r30, 0x34	; 52
     1b6:	f0 e0       	ldi	r31, 0x00	; 0
     1b8:	80 81       	ld	r24, Z
     1ba:	48 2f       	mov	r20, r24
     1bc:	8a 81       	ldd	r24, Y+2	; 0x02
     1be:	28 2f       	mov	r18, r24
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	81 e0       	ldi	r24, 0x01	; 1
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	02 2e       	mov	r0, r18
     1c8:	02 c0       	rjmp	.+4      	; 0x1ce <DIO_SetPinDirection+0x13c>
     1ca:	88 0f       	add	r24, r24
     1cc:	99 1f       	adc	r25, r25
     1ce:	0a 94       	dec	r0
     1d0:	e2 f7       	brpl	.-8      	; 0x1ca <DIO_SetPinDirection+0x138>
     1d2:	80 95       	com	r24
     1d4:	84 23       	and	r24, r20
     1d6:	8c 93       	st	X, r24
     1d8:	46 c0       	rjmp	.+140    	; 0x266 <DIO_SetPinDirection+0x1d4>
     1da:	8b 81       	ldd	r24, Y+3	; 0x03
     1dc:	81 30       	cpi	r24, 0x01	; 1
     1de:	09 f0       	breq	.+2      	; 0x1e2 <DIO_SetPinDirection+0x150>
     1e0:	42 c0       	rjmp	.+132    	; 0x266 <DIO_SetPinDirection+0x1d4>
     1e2:	a4 e3       	ldi	r26, 0x34	; 52
     1e4:	b0 e0       	ldi	r27, 0x00	; 0
     1e6:	e4 e3       	ldi	r30, 0x34	; 52
     1e8:	f0 e0       	ldi	r31, 0x00	; 0
     1ea:	80 81       	ld	r24, Z
     1ec:	48 2f       	mov	r20, r24
     1ee:	8a 81       	ldd	r24, Y+2	; 0x02
     1f0:	28 2f       	mov	r18, r24
     1f2:	30 e0       	ldi	r19, 0x00	; 0
     1f4:	81 e0       	ldi	r24, 0x01	; 1
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	02 2e       	mov	r0, r18
     1fa:	02 c0       	rjmp	.+4      	; 0x200 <DIO_SetPinDirection+0x16e>
     1fc:	88 0f       	add	r24, r24
     1fe:	99 1f       	adc	r25, r25
     200:	0a 94       	dec	r0
     202:	e2 f7       	brpl	.-8      	; 0x1fc <DIO_SetPinDirection+0x16a>
     204:	84 2b       	or	r24, r20
     206:	8c 93       	st	X, r24
     208:	2e c0       	rjmp	.+92     	; 0x266 <DIO_SetPinDirection+0x1d4>
     20a:	8b 81       	ldd	r24, Y+3	; 0x03
     20c:	88 23       	and	r24, r24
     20e:	a9 f4       	brne	.+42     	; 0x23a <DIO_SetPinDirection+0x1a8>
     210:	a1 e3       	ldi	r26, 0x31	; 49
     212:	b0 e0       	ldi	r27, 0x00	; 0
     214:	e1 e3       	ldi	r30, 0x31	; 49
     216:	f0 e0       	ldi	r31, 0x00	; 0
     218:	80 81       	ld	r24, Z
     21a:	48 2f       	mov	r20, r24
     21c:	8a 81       	ldd	r24, Y+2	; 0x02
     21e:	28 2f       	mov	r18, r24
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	90 e0       	ldi	r25, 0x00	; 0
     226:	02 2e       	mov	r0, r18
     228:	02 c0       	rjmp	.+4      	; 0x22e <DIO_SetPinDirection+0x19c>
     22a:	88 0f       	add	r24, r24
     22c:	99 1f       	adc	r25, r25
     22e:	0a 94       	dec	r0
     230:	e2 f7       	brpl	.-8      	; 0x22a <DIO_SetPinDirection+0x198>
     232:	80 95       	com	r24
     234:	84 23       	and	r24, r20
     236:	8c 93       	st	X, r24
     238:	16 c0       	rjmp	.+44     	; 0x266 <DIO_SetPinDirection+0x1d4>
     23a:	8b 81       	ldd	r24, Y+3	; 0x03
     23c:	81 30       	cpi	r24, 0x01	; 1
     23e:	99 f4       	brne	.+38     	; 0x266 <DIO_SetPinDirection+0x1d4>
     240:	a1 e3       	ldi	r26, 0x31	; 49
     242:	b0 e0       	ldi	r27, 0x00	; 0
     244:	e1 e3       	ldi	r30, 0x31	; 49
     246:	f0 e0       	ldi	r31, 0x00	; 0
     248:	80 81       	ld	r24, Z
     24a:	48 2f       	mov	r20, r24
     24c:	8a 81       	ldd	r24, Y+2	; 0x02
     24e:	28 2f       	mov	r18, r24
     250:	30 e0       	ldi	r19, 0x00	; 0
     252:	81 e0       	ldi	r24, 0x01	; 1
     254:	90 e0       	ldi	r25, 0x00	; 0
     256:	02 2e       	mov	r0, r18
     258:	02 c0       	rjmp	.+4      	; 0x25e <DIO_SetPinDirection+0x1cc>
     25a:	88 0f       	add	r24, r24
     25c:	99 1f       	adc	r25, r25
     25e:	0a 94       	dec	r0
     260:	e2 f7       	brpl	.-8      	; 0x25a <DIO_SetPinDirection+0x1c8>
     262:	84 2b       	or	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	0f 90       	pop	r0
     26c:	0f 90       	pop	r0
     26e:	0f 90       	pop	r0
     270:	cf 91       	pop	r28
     272:	df 91       	pop	r29
     274:	08 95       	ret

00000276 <DIO_SetPinValue>:
	}
}


void DIO_SetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin, u8 Copy_u8Value)
{
     276:	df 93       	push	r29
     278:	cf 93       	push	r28
     27a:	00 d0       	rcall	.+0      	; 0x27c <DIO_SetPinValue+0x6>
     27c:	00 d0       	rcall	.+0      	; 0x27e <DIO_SetPinValue+0x8>
     27e:	0f 92       	push	r0
     280:	cd b7       	in	r28, 0x3d	; 61
     282:	de b7       	in	r29, 0x3e	; 62
     284:	89 83       	std	Y+1, r24	; 0x01
     286:	6a 83       	std	Y+2, r22	; 0x02
     288:	4b 83       	std	Y+3, r20	; 0x03
	switch(Copy_u8Port)
     28a:	89 81       	ldd	r24, Y+1	; 0x01
     28c:	28 2f       	mov	r18, r24
     28e:	30 e0       	ldi	r19, 0x00	; 0
     290:	3d 83       	std	Y+5, r19	; 0x05
     292:	2c 83       	std	Y+4, r18	; 0x04
     294:	8c 81       	ldd	r24, Y+4	; 0x04
     296:	9d 81       	ldd	r25, Y+5	; 0x05
     298:	81 30       	cpi	r24, 0x01	; 1
     29a:	91 05       	cpc	r25, r1
     29c:	09 f4       	brne	.+2      	; 0x2a0 <DIO_SetPinValue+0x2a>
     29e:	47 c0       	rjmp	.+142    	; 0x32e <DIO_SetPinValue+0xb8>
     2a0:	2c 81       	ldd	r18, Y+4	; 0x04
     2a2:	3d 81       	ldd	r19, Y+5	; 0x05
     2a4:	22 30       	cpi	r18, 0x02	; 2
     2a6:	31 05       	cpc	r19, r1
     2a8:	2c f4       	brge	.+10     	; 0x2b4 <DIO_SetPinValue+0x3e>
     2aa:	8c 81       	ldd	r24, Y+4	; 0x04
     2ac:	9d 81       	ldd	r25, Y+5	; 0x05
     2ae:	00 97       	sbiw	r24, 0x00	; 0
     2b0:	71 f0       	breq	.+28     	; 0x2ce <DIO_SetPinValue+0x58>
     2b2:	cb c0       	rjmp	.+406    	; 0x44a <DIO_SetPinValue+0x1d4>
     2b4:	2c 81       	ldd	r18, Y+4	; 0x04
     2b6:	3d 81       	ldd	r19, Y+5	; 0x05
     2b8:	22 30       	cpi	r18, 0x02	; 2
     2ba:	31 05       	cpc	r19, r1
     2bc:	09 f4       	brne	.+2      	; 0x2c0 <DIO_SetPinValue+0x4a>
     2be:	67 c0       	rjmp	.+206    	; 0x38e <DIO_SetPinValue+0x118>
     2c0:	8c 81       	ldd	r24, Y+4	; 0x04
     2c2:	9d 81       	ldd	r25, Y+5	; 0x05
     2c4:	83 30       	cpi	r24, 0x03	; 3
     2c6:	91 05       	cpc	r25, r1
     2c8:	09 f4       	brne	.+2      	; 0x2cc <DIO_SetPinValue+0x56>
     2ca:	91 c0       	rjmp	.+290    	; 0x3ee <DIO_SetPinValue+0x178>
     2cc:	be c0       	rjmp	.+380    	; 0x44a <DIO_SetPinValue+0x1d4>
	{
	case PORTA:
		if(Copy_u8Value==LOW)
     2ce:	8b 81       	ldd	r24, Y+3	; 0x03
     2d0:	88 23       	and	r24, r24
     2d2:	a9 f4       	brne	.+42     	; 0x2fe <DIO_SetPinValue+0x88>
			CLR_BIT(PORTA_Register,Copy_u8Pin);
     2d4:	ab e3       	ldi	r26, 0x3B	; 59
     2d6:	b0 e0       	ldi	r27, 0x00	; 0
     2d8:	eb e3       	ldi	r30, 0x3B	; 59
     2da:	f0 e0       	ldi	r31, 0x00	; 0
     2dc:	80 81       	ld	r24, Z
     2de:	48 2f       	mov	r20, r24
     2e0:	8a 81       	ldd	r24, Y+2	; 0x02
     2e2:	28 2f       	mov	r18, r24
     2e4:	30 e0       	ldi	r19, 0x00	; 0
     2e6:	81 e0       	ldi	r24, 0x01	; 1
     2e8:	90 e0       	ldi	r25, 0x00	; 0
     2ea:	02 2e       	mov	r0, r18
     2ec:	02 c0       	rjmp	.+4      	; 0x2f2 <DIO_SetPinValue+0x7c>
     2ee:	88 0f       	add	r24, r24
     2f0:	99 1f       	adc	r25, r25
     2f2:	0a 94       	dec	r0
     2f4:	e2 f7       	brpl	.-8      	; 0x2ee <DIO_SetPinValue+0x78>
     2f6:	80 95       	com	r24
     2f8:	84 23       	and	r24, r20
     2fa:	8c 93       	st	X, r24
     2fc:	a6 c0       	rjmp	.+332    	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     2fe:	8b 81       	ldd	r24, Y+3	; 0x03
     300:	81 30       	cpi	r24, 0x01	; 1
     302:	09 f0       	breq	.+2      	; 0x306 <DIO_SetPinValue+0x90>
     304:	a2 c0       	rjmp	.+324    	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTA_Register,Copy_u8Pin);
     306:	ab e3       	ldi	r26, 0x3B	; 59
     308:	b0 e0       	ldi	r27, 0x00	; 0
     30a:	eb e3       	ldi	r30, 0x3B	; 59
     30c:	f0 e0       	ldi	r31, 0x00	; 0
     30e:	80 81       	ld	r24, Z
     310:	48 2f       	mov	r20, r24
     312:	8a 81       	ldd	r24, Y+2	; 0x02
     314:	28 2f       	mov	r18, r24
     316:	30 e0       	ldi	r19, 0x00	; 0
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	02 2e       	mov	r0, r18
     31e:	02 c0       	rjmp	.+4      	; 0x324 <DIO_SetPinValue+0xae>
     320:	88 0f       	add	r24, r24
     322:	99 1f       	adc	r25, r25
     324:	0a 94       	dec	r0
     326:	e2 f7       	brpl	.-8      	; 0x320 <DIO_SetPinValue+0xaa>
     328:	84 2b       	or	r24, r20
     32a:	8c 93       	st	X, r24
     32c:	8e c0       	rjmp	.+284    	; 0x44a <DIO_SetPinValue+0x1d4>
		break;
	case PORTB:
		if(Copy_u8Value==LOW)
     32e:	8b 81       	ldd	r24, Y+3	; 0x03
     330:	88 23       	and	r24, r24
     332:	a9 f4       	brne	.+42     	; 0x35e <DIO_SetPinValue+0xe8>
			CLR_BIT(PORTB_Register,Copy_u8Pin);
     334:	a8 e3       	ldi	r26, 0x38	; 56
     336:	b0 e0       	ldi	r27, 0x00	; 0
     338:	e8 e3       	ldi	r30, 0x38	; 56
     33a:	f0 e0       	ldi	r31, 0x00	; 0
     33c:	80 81       	ld	r24, Z
     33e:	48 2f       	mov	r20, r24
     340:	8a 81       	ldd	r24, Y+2	; 0x02
     342:	28 2f       	mov	r18, r24
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	81 e0       	ldi	r24, 0x01	; 1
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	02 2e       	mov	r0, r18
     34c:	02 c0       	rjmp	.+4      	; 0x352 <DIO_SetPinValue+0xdc>
     34e:	88 0f       	add	r24, r24
     350:	99 1f       	adc	r25, r25
     352:	0a 94       	dec	r0
     354:	e2 f7       	brpl	.-8      	; 0x34e <DIO_SetPinValue+0xd8>
     356:	80 95       	com	r24
     358:	84 23       	and	r24, r20
     35a:	8c 93       	st	X, r24
     35c:	76 c0       	rjmp	.+236    	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     35e:	8b 81       	ldd	r24, Y+3	; 0x03
     360:	81 30       	cpi	r24, 0x01	; 1
     362:	09 f0       	breq	.+2      	; 0x366 <DIO_SetPinValue+0xf0>
     364:	72 c0       	rjmp	.+228    	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTB_Register,Copy_u8Pin);
     366:	a8 e3       	ldi	r26, 0x38	; 56
     368:	b0 e0       	ldi	r27, 0x00	; 0
     36a:	e8 e3       	ldi	r30, 0x38	; 56
     36c:	f0 e0       	ldi	r31, 0x00	; 0
     36e:	80 81       	ld	r24, Z
     370:	48 2f       	mov	r20, r24
     372:	8a 81       	ldd	r24, Y+2	; 0x02
     374:	28 2f       	mov	r18, r24
     376:	30 e0       	ldi	r19, 0x00	; 0
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	02 2e       	mov	r0, r18
     37e:	02 c0       	rjmp	.+4      	; 0x384 <DIO_SetPinValue+0x10e>
     380:	88 0f       	add	r24, r24
     382:	99 1f       	adc	r25, r25
     384:	0a 94       	dec	r0
     386:	e2 f7       	brpl	.-8      	; 0x380 <DIO_SetPinValue+0x10a>
     388:	84 2b       	or	r24, r20
     38a:	8c 93       	st	X, r24
     38c:	5e c0       	rjmp	.+188    	; 0x44a <DIO_SetPinValue+0x1d4>
		break;
	case PORTC:
		if(Copy_u8Value==LOW)
     38e:	8b 81       	ldd	r24, Y+3	; 0x03
     390:	88 23       	and	r24, r24
     392:	a9 f4       	brne	.+42     	; 0x3be <DIO_SetPinValue+0x148>
			CLR_BIT(PORTC_Register,Copy_u8Pin);
     394:	a5 e3       	ldi	r26, 0x35	; 53
     396:	b0 e0       	ldi	r27, 0x00	; 0
     398:	e5 e3       	ldi	r30, 0x35	; 53
     39a:	f0 e0       	ldi	r31, 0x00	; 0
     39c:	80 81       	ld	r24, Z
     39e:	48 2f       	mov	r20, r24
     3a0:	8a 81       	ldd	r24, Y+2	; 0x02
     3a2:	28 2f       	mov	r18, r24
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	81 e0       	ldi	r24, 0x01	; 1
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	02 2e       	mov	r0, r18
     3ac:	02 c0       	rjmp	.+4      	; 0x3b2 <DIO_SetPinValue+0x13c>
     3ae:	88 0f       	add	r24, r24
     3b0:	99 1f       	adc	r25, r25
     3b2:	0a 94       	dec	r0
     3b4:	e2 f7       	brpl	.-8      	; 0x3ae <DIO_SetPinValue+0x138>
     3b6:	80 95       	com	r24
     3b8:	84 23       	and	r24, r20
     3ba:	8c 93       	st	X, r24
     3bc:	46 c0       	rjmp	.+140    	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     3be:	8b 81       	ldd	r24, Y+3	; 0x03
     3c0:	81 30       	cpi	r24, 0x01	; 1
     3c2:	09 f0       	breq	.+2      	; 0x3c6 <DIO_SetPinValue+0x150>
     3c4:	42 c0       	rjmp	.+132    	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTC_Register,Copy_u8Pin);
     3c6:	a5 e3       	ldi	r26, 0x35	; 53
     3c8:	b0 e0       	ldi	r27, 0x00	; 0
     3ca:	e5 e3       	ldi	r30, 0x35	; 53
     3cc:	f0 e0       	ldi	r31, 0x00	; 0
     3ce:	80 81       	ld	r24, Z
     3d0:	48 2f       	mov	r20, r24
     3d2:	8a 81       	ldd	r24, Y+2	; 0x02
     3d4:	28 2f       	mov	r18, r24
     3d6:	30 e0       	ldi	r19, 0x00	; 0
     3d8:	81 e0       	ldi	r24, 0x01	; 1
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	02 2e       	mov	r0, r18
     3de:	02 c0       	rjmp	.+4      	; 0x3e4 <DIO_SetPinValue+0x16e>
     3e0:	88 0f       	add	r24, r24
     3e2:	99 1f       	adc	r25, r25
     3e4:	0a 94       	dec	r0
     3e6:	e2 f7       	brpl	.-8      	; 0x3e0 <DIO_SetPinValue+0x16a>
     3e8:	84 2b       	or	r24, r20
     3ea:	8c 93       	st	X, r24
     3ec:	2e c0       	rjmp	.+92     	; 0x44a <DIO_SetPinValue+0x1d4>
		break;
	case PORTD:
		if(Copy_u8Value==LOW)
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	88 23       	and	r24, r24
     3f2:	a9 f4       	brne	.+42     	; 0x41e <DIO_SetPinValue+0x1a8>
			CLR_BIT(PORTD_Register,Copy_u8Pin);
     3f4:	a2 e3       	ldi	r26, 0x32	; 50
     3f6:	b0 e0       	ldi	r27, 0x00	; 0
     3f8:	e2 e3       	ldi	r30, 0x32	; 50
     3fa:	f0 e0       	ldi	r31, 0x00	; 0
     3fc:	80 81       	ld	r24, Z
     3fe:	48 2f       	mov	r20, r24
     400:	8a 81       	ldd	r24, Y+2	; 0x02
     402:	28 2f       	mov	r18, r24
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	81 e0       	ldi	r24, 0x01	; 1
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	02 2e       	mov	r0, r18
     40c:	02 c0       	rjmp	.+4      	; 0x412 <DIO_SetPinValue+0x19c>
     40e:	88 0f       	add	r24, r24
     410:	99 1f       	adc	r25, r25
     412:	0a 94       	dec	r0
     414:	e2 f7       	brpl	.-8      	; 0x40e <DIO_SetPinValue+0x198>
     416:	80 95       	com	r24
     418:	84 23       	and	r24, r20
     41a:	8c 93       	st	X, r24
     41c:	16 c0       	rjmp	.+44     	; 0x44a <DIO_SetPinValue+0x1d4>
		else if(Copy_u8Value==HIGH)
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	81 30       	cpi	r24, 0x01	; 1
     422:	99 f4       	brne	.+38     	; 0x44a <DIO_SetPinValue+0x1d4>
			SET_BIT(PORTD_Register,Copy_u8Pin);
     424:	a2 e3       	ldi	r26, 0x32	; 50
     426:	b0 e0       	ldi	r27, 0x00	; 0
     428:	e2 e3       	ldi	r30, 0x32	; 50
     42a:	f0 e0       	ldi	r31, 0x00	; 0
     42c:	80 81       	ld	r24, Z
     42e:	48 2f       	mov	r20, r24
     430:	8a 81       	ldd	r24, Y+2	; 0x02
     432:	28 2f       	mov	r18, r24
     434:	30 e0       	ldi	r19, 0x00	; 0
     436:	81 e0       	ldi	r24, 0x01	; 1
     438:	90 e0       	ldi	r25, 0x00	; 0
     43a:	02 2e       	mov	r0, r18
     43c:	02 c0       	rjmp	.+4      	; 0x442 <DIO_SetPinValue+0x1cc>
     43e:	88 0f       	add	r24, r24
     440:	99 1f       	adc	r25, r25
     442:	0a 94       	dec	r0
     444:	e2 f7       	brpl	.-8      	; 0x43e <DIO_SetPinValue+0x1c8>
     446:	84 2b       	or	r24, r20
     448:	8c 93       	st	X, r24
		break;
	default:
		break;
	}
}
     44a:	0f 90       	pop	r0
     44c:	0f 90       	pop	r0
     44e:	0f 90       	pop	r0
     450:	0f 90       	pop	r0
     452:	0f 90       	pop	r0
     454:	cf 91       	pop	r28
     456:	df 91       	pop	r29
     458:	08 95       	ret

0000045a <DIO_GetPinValue>:

u8 DIO_GetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin)
{
     45a:	df 93       	push	r29
     45c:	cf 93       	push	r28
     45e:	00 d0       	rcall	.+0      	; 0x460 <DIO_GetPinValue+0x6>
     460:	00 d0       	rcall	.+0      	; 0x462 <DIO_GetPinValue+0x8>
     462:	0f 92       	push	r0
     464:	cd b7       	in	r28, 0x3d	; 61
     466:	de b7       	in	r29, 0x3e	; 62
     468:	8a 83       	std	Y+2, r24	; 0x02
     46a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Copy_u8LocalVariable;
	switch(Copy_u8Port)
     46c:	8a 81       	ldd	r24, Y+2	; 0x02
     46e:	28 2f       	mov	r18, r24
     470:	30 e0       	ldi	r19, 0x00	; 0
     472:	3d 83       	std	Y+5, r19	; 0x05
     474:	2c 83       	std	Y+4, r18	; 0x04
     476:	4c 81       	ldd	r20, Y+4	; 0x04
     478:	5d 81       	ldd	r21, Y+5	; 0x05
     47a:	41 30       	cpi	r20, 0x01	; 1
     47c:	51 05       	cpc	r21, r1
     47e:	41 f1       	breq	.+80     	; 0x4d0 <DIO_GetPinValue+0x76>
     480:	8c 81       	ldd	r24, Y+4	; 0x04
     482:	9d 81       	ldd	r25, Y+5	; 0x05
     484:	82 30       	cpi	r24, 0x02	; 2
     486:	91 05       	cpc	r25, r1
     488:	34 f4       	brge	.+12     	; 0x496 <DIO_GetPinValue+0x3c>
     48a:	2c 81       	ldd	r18, Y+4	; 0x04
     48c:	3d 81       	ldd	r19, Y+5	; 0x05
     48e:	21 15       	cp	r18, r1
     490:	31 05       	cpc	r19, r1
     492:	61 f0       	breq	.+24     	; 0x4ac <DIO_GetPinValue+0x52>
     494:	52 c0       	rjmp	.+164    	; 0x53a <DIO_GetPinValue+0xe0>
     496:	4c 81       	ldd	r20, Y+4	; 0x04
     498:	5d 81       	ldd	r21, Y+5	; 0x05
     49a:	42 30       	cpi	r20, 0x02	; 2
     49c:	51 05       	cpc	r21, r1
     49e:	51 f1       	breq	.+84     	; 0x4f4 <DIO_GetPinValue+0x9a>
     4a0:	8c 81       	ldd	r24, Y+4	; 0x04
     4a2:	9d 81       	ldd	r25, Y+5	; 0x05
     4a4:	83 30       	cpi	r24, 0x03	; 3
     4a6:	91 05       	cpc	r25, r1
     4a8:	b9 f1       	breq	.+110    	; 0x518 <DIO_GetPinValue+0xbe>
     4aa:	47 c0       	rjmp	.+142    	; 0x53a <DIO_GetPinValue+0xe0>
	{
	case PORTA:
		Copy_u8LocalVariable = GET_BIT(PINA, Copy_u8Pin);
     4ac:	e9 e3       	ldi	r30, 0x39	; 57
     4ae:	f0 e0       	ldi	r31, 0x00	; 0
     4b0:	80 81       	ld	r24, Z
     4b2:	28 2f       	mov	r18, r24
     4b4:	30 e0       	ldi	r19, 0x00	; 0
     4b6:	8b 81       	ldd	r24, Y+3	; 0x03
     4b8:	88 2f       	mov	r24, r24
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	a9 01       	movw	r20, r18
     4be:	02 c0       	rjmp	.+4      	; 0x4c4 <DIO_GetPinValue+0x6a>
     4c0:	55 95       	asr	r21
     4c2:	47 95       	ror	r20
     4c4:	8a 95       	dec	r24
     4c6:	e2 f7       	brpl	.-8      	; 0x4c0 <DIO_GetPinValue+0x66>
     4c8:	ca 01       	movw	r24, r20
     4ca:	81 70       	andi	r24, 0x01	; 1
     4cc:	89 83       	std	Y+1, r24	; 0x01
     4ce:	35 c0       	rjmp	.+106    	; 0x53a <DIO_GetPinValue+0xe0>
		break;
	case PORTB:
		Copy_u8LocalVariable = GET_BIT(PINB, Copy_u8Pin);
     4d0:	e6 e3       	ldi	r30, 0x36	; 54
     4d2:	f0 e0       	ldi	r31, 0x00	; 0
     4d4:	80 81       	ld	r24, Z
     4d6:	28 2f       	mov	r18, r24
     4d8:	30 e0       	ldi	r19, 0x00	; 0
     4da:	8b 81       	ldd	r24, Y+3	; 0x03
     4dc:	88 2f       	mov	r24, r24
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	a9 01       	movw	r20, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_GetPinValue+0x8e>
     4e4:	55 95       	asr	r21
     4e6:	47 95       	ror	r20
     4e8:	8a 95       	dec	r24
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_GetPinValue+0x8a>
     4ec:	ca 01       	movw	r24, r20
     4ee:	81 70       	andi	r24, 0x01	; 1
     4f0:	89 83       	std	Y+1, r24	; 0x01
     4f2:	23 c0       	rjmp	.+70     	; 0x53a <DIO_GetPinValue+0xe0>
		break;
	case PORTC:
		Copy_u8LocalVariable = GET_BIT(PINC, Copy_u8Pin);
     4f4:	e3 e3       	ldi	r30, 0x33	; 51
     4f6:	f0 e0       	ldi	r31, 0x00	; 0
     4f8:	80 81       	ld	r24, Z
     4fa:	28 2f       	mov	r18, r24
     4fc:	30 e0       	ldi	r19, 0x00	; 0
     4fe:	8b 81       	ldd	r24, Y+3	; 0x03
     500:	88 2f       	mov	r24, r24
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	a9 01       	movw	r20, r18
     506:	02 c0       	rjmp	.+4      	; 0x50c <DIO_GetPinValue+0xb2>
     508:	55 95       	asr	r21
     50a:	47 95       	ror	r20
     50c:	8a 95       	dec	r24
     50e:	e2 f7       	brpl	.-8      	; 0x508 <DIO_GetPinValue+0xae>
     510:	ca 01       	movw	r24, r20
     512:	81 70       	andi	r24, 0x01	; 1
     514:	89 83       	std	Y+1, r24	; 0x01
     516:	11 c0       	rjmp	.+34     	; 0x53a <DIO_GetPinValue+0xe0>
		break;
	case PORTD:
		Copy_u8LocalVariable = GET_BIT(PIND, Copy_u8Pin);
     518:	e0 e3       	ldi	r30, 0x30	; 48
     51a:	f0 e0       	ldi	r31, 0x00	; 0
     51c:	80 81       	ld	r24, Z
     51e:	28 2f       	mov	r18, r24
     520:	30 e0       	ldi	r19, 0x00	; 0
     522:	8b 81       	ldd	r24, Y+3	; 0x03
     524:	88 2f       	mov	r24, r24
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	a9 01       	movw	r20, r18
     52a:	02 c0       	rjmp	.+4      	; 0x530 <DIO_GetPinValue+0xd6>
     52c:	55 95       	asr	r21
     52e:	47 95       	ror	r20
     530:	8a 95       	dec	r24
     532:	e2 f7       	brpl	.-8      	; 0x52c <DIO_GetPinValue+0xd2>
     534:	ca 01       	movw	r24, r20
     536:	81 70       	andi	r24, 0x01	; 1
     538:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Copy_u8LocalVariable;
     53a:	89 81       	ldd	r24, Y+1	; 0x01
}
     53c:	0f 90       	pop	r0
     53e:	0f 90       	pop	r0
     540:	0f 90       	pop	r0
     542:	0f 90       	pop	r0
     544:	0f 90       	pop	r0
     546:	cf 91       	pop	r28
     548:	df 91       	pop	r29
     54a:	08 95       	ret

0000054c <DIO_GetPinValueByPtr>:


void DIO_GetPinValueByPtr(u8 Copy_u8Port, u8 Copy_u8Pin, u8 * Copy_u8ptr)
{
     54c:	df 93       	push	r29
     54e:	cf 93       	push	r28
     550:	00 d0       	rcall	.+0      	; 0x552 <DIO_GetPinValueByPtr+0x6>
     552:	00 d0       	rcall	.+0      	; 0x554 <DIO_GetPinValueByPtr+0x8>
     554:	00 d0       	rcall	.+0      	; 0x556 <DIO_GetPinValueByPtr+0xa>
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
     55a:	89 83       	std	Y+1, r24	; 0x01
     55c:	6a 83       	std	Y+2, r22	; 0x02
     55e:	5c 83       	std	Y+4, r21	; 0x04
     560:	4b 83       	std	Y+3, r20	; 0x03
	switch(Copy_u8Port)
     562:	89 81       	ldd	r24, Y+1	; 0x01
     564:	28 2f       	mov	r18, r24
     566:	30 e0       	ldi	r19, 0x00	; 0
     568:	3e 83       	std	Y+6, r19	; 0x06
     56a:	2d 83       	std	Y+5, r18	; 0x05
     56c:	4d 81       	ldd	r20, Y+5	; 0x05
     56e:	5e 81       	ldd	r21, Y+6	; 0x06
     570:	41 30       	cpi	r20, 0x01	; 1
     572:	51 05       	cpc	r21, r1
     574:	59 f1       	breq	.+86     	; 0x5cc <DIO_GetPinValueByPtr+0x80>
     576:	8d 81       	ldd	r24, Y+5	; 0x05
     578:	9e 81       	ldd	r25, Y+6	; 0x06
     57a:	82 30       	cpi	r24, 0x02	; 2
     57c:	91 05       	cpc	r25, r1
     57e:	34 f4       	brge	.+12     	; 0x58c <DIO_GetPinValueByPtr+0x40>
     580:	2d 81       	ldd	r18, Y+5	; 0x05
     582:	3e 81       	ldd	r19, Y+6	; 0x06
     584:	21 15       	cp	r18, r1
     586:	31 05       	cpc	r19, r1
     588:	69 f0       	breq	.+26     	; 0x5a4 <DIO_GetPinValueByPtr+0x58>
     58a:	5b c0       	rjmp	.+182    	; 0x642 <DIO_GetPinValueByPtr+0xf6>
     58c:	4d 81       	ldd	r20, Y+5	; 0x05
     58e:	5e 81       	ldd	r21, Y+6	; 0x06
     590:	42 30       	cpi	r20, 0x02	; 2
     592:	51 05       	cpc	r21, r1
     594:	79 f1       	breq	.+94     	; 0x5f4 <DIO_GetPinValueByPtr+0xa8>
     596:	8d 81       	ldd	r24, Y+5	; 0x05
     598:	9e 81       	ldd	r25, Y+6	; 0x06
     59a:	83 30       	cpi	r24, 0x03	; 3
     59c:	91 05       	cpc	r25, r1
     59e:	09 f4       	brne	.+2      	; 0x5a2 <DIO_GetPinValueByPtr+0x56>
     5a0:	3d c0       	rjmp	.+122    	; 0x61c <DIO_GetPinValueByPtr+0xd0>
     5a2:	4f c0       	rjmp	.+158    	; 0x642 <DIO_GetPinValueByPtr+0xf6>
	{
	case PORTA:
		*Copy_u8ptr = GET_BIT(PINA, Copy_u8Pin);
     5a4:	e9 e3       	ldi	r30, 0x39	; 57
     5a6:	f0 e0       	ldi	r31, 0x00	; 0
     5a8:	80 81       	ld	r24, Z
     5aa:	28 2f       	mov	r18, r24
     5ac:	30 e0       	ldi	r19, 0x00	; 0
     5ae:	8a 81       	ldd	r24, Y+2	; 0x02
     5b0:	88 2f       	mov	r24, r24
     5b2:	90 e0       	ldi	r25, 0x00	; 0
     5b4:	a9 01       	movw	r20, r18
     5b6:	02 c0       	rjmp	.+4      	; 0x5bc <DIO_GetPinValueByPtr+0x70>
     5b8:	55 95       	asr	r21
     5ba:	47 95       	ror	r20
     5bc:	8a 95       	dec	r24
     5be:	e2 f7       	brpl	.-8      	; 0x5b8 <DIO_GetPinValueByPtr+0x6c>
     5c0:	ca 01       	movw	r24, r20
     5c2:	81 70       	andi	r24, 0x01	; 1
     5c4:	eb 81       	ldd	r30, Y+3	; 0x03
     5c6:	fc 81       	ldd	r31, Y+4	; 0x04
     5c8:	80 83       	st	Z, r24
     5ca:	3b c0       	rjmp	.+118    	; 0x642 <DIO_GetPinValueByPtr+0xf6>
		break;
	case PORTB:
		*Copy_u8ptr = GET_BIT(PINB, Copy_u8Pin);
     5cc:	e6 e3       	ldi	r30, 0x36	; 54
     5ce:	f0 e0       	ldi	r31, 0x00	; 0
     5d0:	80 81       	ld	r24, Z
     5d2:	28 2f       	mov	r18, r24
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	8a 81       	ldd	r24, Y+2	; 0x02
     5d8:	88 2f       	mov	r24, r24
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	a9 01       	movw	r20, r18
     5de:	02 c0       	rjmp	.+4      	; 0x5e4 <DIO_GetPinValueByPtr+0x98>
     5e0:	55 95       	asr	r21
     5e2:	47 95       	ror	r20
     5e4:	8a 95       	dec	r24
     5e6:	e2 f7       	brpl	.-8      	; 0x5e0 <DIO_GetPinValueByPtr+0x94>
     5e8:	ca 01       	movw	r24, r20
     5ea:	81 70       	andi	r24, 0x01	; 1
     5ec:	eb 81       	ldd	r30, Y+3	; 0x03
     5ee:	fc 81       	ldd	r31, Y+4	; 0x04
     5f0:	80 83       	st	Z, r24
     5f2:	27 c0       	rjmp	.+78     	; 0x642 <DIO_GetPinValueByPtr+0xf6>
		break;
	case PORTC:
		*Copy_u8ptr = GET_BIT(PINC, Copy_u8Pin);
     5f4:	e3 e3       	ldi	r30, 0x33	; 51
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
     5f8:	80 81       	ld	r24, Z
     5fa:	28 2f       	mov	r18, r24
     5fc:	30 e0       	ldi	r19, 0x00	; 0
     5fe:	8a 81       	ldd	r24, Y+2	; 0x02
     600:	88 2f       	mov	r24, r24
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	a9 01       	movw	r20, r18
     606:	02 c0       	rjmp	.+4      	; 0x60c <DIO_GetPinValueByPtr+0xc0>
     608:	55 95       	asr	r21
     60a:	47 95       	ror	r20
     60c:	8a 95       	dec	r24
     60e:	e2 f7       	brpl	.-8      	; 0x608 <DIO_GetPinValueByPtr+0xbc>
     610:	ca 01       	movw	r24, r20
     612:	81 70       	andi	r24, 0x01	; 1
     614:	eb 81       	ldd	r30, Y+3	; 0x03
     616:	fc 81       	ldd	r31, Y+4	; 0x04
     618:	80 83       	st	Z, r24
     61a:	13 c0       	rjmp	.+38     	; 0x642 <DIO_GetPinValueByPtr+0xf6>
		break;
	case PORTD:
		*Copy_u8ptr = GET_BIT(PIND, Copy_u8Pin);
     61c:	e0 e3       	ldi	r30, 0x30	; 48
     61e:	f0 e0       	ldi	r31, 0x00	; 0
     620:	80 81       	ld	r24, Z
     622:	28 2f       	mov	r18, r24
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	8a 81       	ldd	r24, Y+2	; 0x02
     628:	88 2f       	mov	r24, r24
     62a:	90 e0       	ldi	r25, 0x00	; 0
     62c:	a9 01       	movw	r20, r18
     62e:	02 c0       	rjmp	.+4      	; 0x634 <DIO_GetPinValueByPtr+0xe8>
     630:	55 95       	asr	r21
     632:	47 95       	ror	r20
     634:	8a 95       	dec	r24
     636:	e2 f7       	brpl	.-8      	; 0x630 <DIO_GetPinValueByPtr+0xe4>
     638:	ca 01       	movw	r24, r20
     63a:	81 70       	andi	r24, 0x01	; 1
     63c:	eb 81       	ldd	r30, Y+3	; 0x03
     63e:	fc 81       	ldd	r31, Y+4	; 0x04
     640:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
}
     642:	26 96       	adiw	r28, 0x06	; 6
     644:	0f b6       	in	r0, 0x3f	; 63
     646:	f8 94       	cli
     648:	de bf       	out	0x3e, r29	; 62
     64a:	0f be       	out	0x3f, r0	; 63
     64c:	cd bf       	out	0x3d, r28	; 61
     64e:	cf 91       	pop	r28
     650:	df 91       	pop	r29
     652:	08 95       	ret

00000654 <DIO_SetPortDirection>:

void DIO_SetPortDirection(u8 Copy_u8Port, u8 Copy_u8Direction)
{
     654:	df 93       	push	r29
     656:	cf 93       	push	r28
     658:	00 d0       	rcall	.+0      	; 0x65a <DIO_SetPortDirection+0x6>
     65a:	00 d0       	rcall	.+0      	; 0x65c <DIO_SetPortDirection+0x8>
     65c:	cd b7       	in	r28, 0x3d	; 61
     65e:	de b7       	in	r29, 0x3e	; 62
     660:	89 83       	std	Y+1, r24	; 0x01
     662:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8Port)
     664:	89 81       	ldd	r24, Y+1	; 0x01
     666:	28 2f       	mov	r18, r24
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	3c 83       	std	Y+4, r19	; 0x04
     66c:	2b 83       	std	Y+3, r18	; 0x03
     66e:	8b 81       	ldd	r24, Y+3	; 0x03
     670:	9c 81       	ldd	r25, Y+4	; 0x04
     672:	81 30       	cpi	r24, 0x01	; 1
     674:	91 05       	cpc	r25, r1
     676:	d1 f0       	breq	.+52     	; 0x6ac <DIO_SetPortDirection+0x58>
     678:	2b 81       	ldd	r18, Y+3	; 0x03
     67a:	3c 81       	ldd	r19, Y+4	; 0x04
     67c:	22 30       	cpi	r18, 0x02	; 2
     67e:	31 05       	cpc	r19, r1
     680:	2c f4       	brge	.+10     	; 0x68c <DIO_SetPortDirection+0x38>
     682:	8b 81       	ldd	r24, Y+3	; 0x03
     684:	9c 81       	ldd	r25, Y+4	; 0x04
     686:	00 97       	sbiw	r24, 0x00	; 0
     688:	61 f0       	breq	.+24     	; 0x6a2 <DIO_SetPortDirection+0x4e>
     68a:	1e c0       	rjmp	.+60     	; 0x6c8 <DIO_SetPortDirection+0x74>
     68c:	2b 81       	ldd	r18, Y+3	; 0x03
     68e:	3c 81       	ldd	r19, Y+4	; 0x04
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 05       	cpc	r19, r1
     694:	81 f0       	breq	.+32     	; 0x6b6 <DIO_SetPortDirection+0x62>
     696:	8b 81       	ldd	r24, Y+3	; 0x03
     698:	9c 81       	ldd	r25, Y+4	; 0x04
     69a:	83 30       	cpi	r24, 0x03	; 3
     69c:	91 05       	cpc	r25, r1
     69e:	81 f0       	breq	.+32     	; 0x6c0 <DIO_SetPortDirection+0x6c>
     6a0:	13 c0       	rjmp	.+38     	; 0x6c8 <DIO_SetPortDirection+0x74>
	{
	case PORTA:
		DDRA = Copy_u8Direction;
     6a2:	ea e3       	ldi	r30, 0x3A	; 58
     6a4:	f0 e0       	ldi	r31, 0x00	; 0
     6a6:	8a 81       	ldd	r24, Y+2	; 0x02
     6a8:	80 83       	st	Z, r24
     6aa:	0e c0       	rjmp	.+28     	; 0x6c8 <DIO_SetPortDirection+0x74>
		break;
	case PORTB:
		DDRB = Copy_u8Direction;
     6ac:	e7 e3       	ldi	r30, 0x37	; 55
     6ae:	f0 e0       	ldi	r31, 0x00	; 0
     6b0:	8a 81       	ldd	r24, Y+2	; 0x02
     6b2:	80 83       	st	Z, r24
     6b4:	09 c0       	rjmp	.+18     	; 0x6c8 <DIO_SetPortDirection+0x74>
		break;
	case PORTC:
		DDRC = Copy_u8Direction;
     6b6:	e4 e3       	ldi	r30, 0x34	; 52
     6b8:	f0 e0       	ldi	r31, 0x00	; 0
     6ba:	8a 81       	ldd	r24, Y+2	; 0x02
     6bc:	80 83       	st	Z, r24
     6be:	04 c0       	rjmp	.+8      	; 0x6c8 <DIO_SetPortDirection+0x74>
		break;
	case PORTD:
		DDRD = Copy_u8Direction;
     6c0:	e1 e3       	ldi	r30, 0x31	; 49
     6c2:	f0 e0       	ldi	r31, 0x00	; 0
     6c4:	8a 81       	ldd	r24, Y+2	; 0x02
     6c6:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
}
     6c8:	0f 90       	pop	r0
     6ca:	0f 90       	pop	r0
     6cc:	0f 90       	pop	r0
     6ce:	0f 90       	pop	r0
     6d0:	cf 91       	pop	r28
     6d2:	df 91       	pop	r29
     6d4:	08 95       	ret

000006d6 <DIO_SetPortValue>:
void DIO_SetPortValue(u8 Copy_u8Port, u8 Copy_u8Value)
{
     6d6:	df 93       	push	r29
     6d8:	cf 93       	push	r28
     6da:	00 d0       	rcall	.+0      	; 0x6dc <DIO_SetPortValue+0x6>
     6dc:	00 d0       	rcall	.+0      	; 0x6de <DIO_SetPortValue+0x8>
     6de:	cd b7       	in	r28, 0x3d	; 61
     6e0:	de b7       	in	r29, 0x3e	; 62
     6e2:	89 83       	std	Y+1, r24	; 0x01
     6e4:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8Port)
     6e6:	89 81       	ldd	r24, Y+1	; 0x01
     6e8:	28 2f       	mov	r18, r24
     6ea:	30 e0       	ldi	r19, 0x00	; 0
     6ec:	3c 83       	std	Y+4, r19	; 0x04
     6ee:	2b 83       	std	Y+3, r18	; 0x03
     6f0:	8b 81       	ldd	r24, Y+3	; 0x03
     6f2:	9c 81       	ldd	r25, Y+4	; 0x04
     6f4:	81 30       	cpi	r24, 0x01	; 1
     6f6:	91 05       	cpc	r25, r1
     6f8:	d1 f0       	breq	.+52     	; 0x72e <DIO_SetPortValue+0x58>
     6fa:	2b 81       	ldd	r18, Y+3	; 0x03
     6fc:	3c 81       	ldd	r19, Y+4	; 0x04
     6fe:	22 30       	cpi	r18, 0x02	; 2
     700:	31 05       	cpc	r19, r1
     702:	2c f4       	brge	.+10     	; 0x70e <DIO_SetPortValue+0x38>
     704:	8b 81       	ldd	r24, Y+3	; 0x03
     706:	9c 81       	ldd	r25, Y+4	; 0x04
     708:	00 97       	sbiw	r24, 0x00	; 0
     70a:	61 f0       	breq	.+24     	; 0x724 <DIO_SetPortValue+0x4e>
     70c:	1e c0       	rjmp	.+60     	; 0x74a <DIO_SetPortValue+0x74>
     70e:	2b 81       	ldd	r18, Y+3	; 0x03
     710:	3c 81       	ldd	r19, Y+4	; 0x04
     712:	22 30       	cpi	r18, 0x02	; 2
     714:	31 05       	cpc	r19, r1
     716:	81 f0       	breq	.+32     	; 0x738 <DIO_SetPortValue+0x62>
     718:	8b 81       	ldd	r24, Y+3	; 0x03
     71a:	9c 81       	ldd	r25, Y+4	; 0x04
     71c:	83 30       	cpi	r24, 0x03	; 3
     71e:	91 05       	cpc	r25, r1
     720:	81 f0       	breq	.+32     	; 0x742 <DIO_SetPortValue+0x6c>
     722:	13 c0       	rjmp	.+38     	; 0x74a <DIO_SetPortValue+0x74>
	{
	case PORTA:
		PORTA_Register = Copy_u8Value;
     724:	eb e3       	ldi	r30, 0x3B	; 59
     726:	f0 e0       	ldi	r31, 0x00	; 0
     728:	8a 81       	ldd	r24, Y+2	; 0x02
     72a:	80 83       	st	Z, r24
     72c:	0e c0       	rjmp	.+28     	; 0x74a <DIO_SetPortValue+0x74>
		break;
	case PORTB:
		PORTB_Register = Copy_u8Value;
     72e:	e8 e3       	ldi	r30, 0x38	; 56
     730:	f0 e0       	ldi	r31, 0x00	; 0
     732:	8a 81       	ldd	r24, Y+2	; 0x02
     734:	80 83       	st	Z, r24
     736:	09 c0       	rjmp	.+18     	; 0x74a <DIO_SetPortValue+0x74>
		break;
	case PORTC:
		PORTC_Register = Copy_u8Value;
     738:	e5 e3       	ldi	r30, 0x35	; 53
     73a:	f0 e0       	ldi	r31, 0x00	; 0
     73c:	8a 81       	ldd	r24, Y+2	; 0x02
     73e:	80 83       	st	Z, r24
     740:	04 c0       	rjmp	.+8      	; 0x74a <DIO_SetPortValue+0x74>
		break;
	case PORTD:
		PORTD_Register = Copy_u8Value;
     742:	e2 e3       	ldi	r30, 0x32	; 50
     744:	f0 e0       	ldi	r31, 0x00	; 0
     746:	8a 81       	ldd	r24, Y+2	; 0x02
     748:	80 83       	st	Z, r24
		break;
	default:
		break;
	}
}
     74a:	0f 90       	pop	r0
     74c:	0f 90       	pop	r0
     74e:	0f 90       	pop	r0
     750:	0f 90       	pop	r0
     752:	cf 91       	pop	r28
     754:	df 91       	pop	r29
     756:	08 95       	ret

00000758 <EXTI_SetTriggerMode>:
void(*EXTI1_GlobalPtr)(void)=0;
void(*EXTI2_GlobalPtr)(void)=0;


void EXTI_SetTriggerMode(void)
{
     758:	df 93       	push	r29
     75a:	cf 93       	push	r28
     75c:	cd b7       	in	r28, 0x3d	; 61
     75e:	de b7       	in	r29, 0x3e	; 62
#if(EXTI0_mode==FallingEdge)
	SET_BIT(MCUCR_Register,ISC01);
	CLR_BIT(MCUCR_Register,ISC00);

#elif(EXTI0_mode==RisingEdge)
	SET_BIT(MCUCR_Register,ISC01);
     760:	a5 e5       	ldi	r26, 0x55	; 85
     762:	b0 e0       	ldi	r27, 0x00	; 0
     764:	e5 e5       	ldi	r30, 0x55	; 85
     766:	f0 e0       	ldi	r31, 0x00	; 0
     768:	80 81       	ld	r24, Z
     76a:	82 60       	ori	r24, 0x02	; 2
     76c:	8c 93       	st	X, r24
	SET_BIT(MCUCR_Register,ISC00);
     76e:	a5 e5       	ldi	r26, 0x55	; 85
     770:	b0 e0       	ldi	r27, 0x00	; 0
     772:	e5 e5       	ldi	r30, 0x55	; 85
     774:	f0 e0       	ldi	r31, 0x00	; 0
     776:	80 81       	ld	r24, Z
     778:	81 60       	ori	r24, 0x01	; 1
     77a:	8c 93       	st	X, r24
#if(EXTI1_mode==FallingEdge)
	SET_BIT(MCUCR_Register,ISC11);
	CLR_BIT(MCUCR_Register,ISC10);

#elif(EXTI1_mode==RisingEdge)
	SET_BIT(MCUCR_Register,ISC11);
     77c:	a5 e5       	ldi	r26, 0x55	; 85
     77e:	b0 e0       	ldi	r27, 0x00	; 0
     780:	e5 e5       	ldi	r30, 0x55	; 85
     782:	f0 e0       	ldi	r31, 0x00	; 0
     784:	80 81       	ld	r24, Z
     786:	88 60       	ori	r24, 0x08	; 8
     788:	8c 93       	st	X, r24
	SET_BIT(MCUCR_Register,ISC10);
     78a:	a5 e5       	ldi	r26, 0x55	; 85
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	e5 e5       	ldi	r30, 0x55	; 85
     790:	f0 e0       	ldi	r31, 0x00	; 0
     792:	80 81       	ld	r24, Z
     794:	84 60       	ori	r24, 0x04	; 4
     796:	8c 93       	st	X, r24

#if(EXTI2_mode==FallingEdge)
	CLR_BIT(MCUCSR_Register,ISC2);

#elif(EXTI2_mode==RisingEdge)
	SET_BIT(MCUCSR_Register,ISC2);
     798:	a4 e5       	ldi	r26, 0x54	; 84
     79a:	b0 e0       	ldi	r27, 0x00	; 0
     79c:	e4 e5       	ldi	r30, 0x54	; 84
     79e:	f0 e0       	ldi	r31, 0x00	; 0
     7a0:	80 81       	ld	r24, Z
     7a2:	80 64       	ori	r24, 0x40	; 64
     7a4:	8c 93       	st	X, r24

#endif

}
     7a6:	cf 91       	pop	r28
     7a8:	df 91       	pop	r29
     7aa:	08 95       	ret

000007ac <EXTI0_ChangeTriggerMode>:

void EXTI0_ChangeTriggerMode(u8 Copy_u8Mode)
{
     7ac:	df 93       	push	r29
     7ae:	cf 93       	push	r28
     7b0:	00 d0       	rcall	.+0      	; 0x7b2 <EXTI0_ChangeTriggerMode+0x6>
     7b2:	0f 92       	push	r0
     7b4:	cd b7       	in	r28, 0x3d	; 61
     7b6:	de b7       	in	r29, 0x3e	; 62
     7b8:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8Mode)
     7ba:	89 81       	ldd	r24, Y+1	; 0x01
     7bc:	28 2f       	mov	r18, r24
     7be:	30 e0       	ldi	r19, 0x00	; 0
     7c0:	3b 83       	std	Y+3, r19	; 0x03
     7c2:	2a 83       	std	Y+2, r18	; 0x02
     7c4:	8a 81       	ldd	r24, Y+2	; 0x02
     7c6:	9b 81       	ldd	r25, Y+3	; 0x03
     7c8:	81 30       	cpi	r24, 0x01	; 1
     7ca:	91 05       	cpc	r25, r1
     7cc:	21 f1       	breq	.+72     	; 0x816 <EXTI0_ChangeTriggerMode+0x6a>
     7ce:	2a 81       	ldd	r18, Y+2	; 0x02
     7d0:	3b 81       	ldd	r19, Y+3	; 0x03
     7d2:	22 30       	cpi	r18, 0x02	; 2
     7d4:	31 05       	cpc	r19, r1
     7d6:	2c f4       	brge	.+10     	; 0x7e2 <EXTI0_ChangeTriggerMode+0x36>
     7d8:	8a 81       	ldd	r24, Y+2	; 0x02
     7da:	9b 81       	ldd	r25, Y+3	; 0x03
     7dc:	00 97       	sbiw	r24, 0x00	; 0
     7de:	61 f0       	breq	.+24     	; 0x7f8 <EXTI0_ChangeTriggerMode+0x4c>
     7e0:	46 c0       	rjmp	.+140    	; 0x86e <__stack+0xf>
     7e2:	2a 81       	ldd	r18, Y+2	; 0x02
     7e4:	3b 81       	ldd	r19, Y+3	; 0x03
     7e6:	22 30       	cpi	r18, 0x02	; 2
     7e8:	31 05       	cpc	r19, r1
     7ea:	21 f1       	breq	.+72     	; 0x834 <EXTI0_ChangeTriggerMode+0x88>
     7ec:	8a 81       	ldd	r24, Y+2	; 0x02
     7ee:	9b 81       	ldd	r25, Y+3	; 0x03
     7f0:	83 30       	cpi	r24, 0x03	; 3
     7f2:	91 05       	cpc	r25, r1
     7f4:	71 f1       	breq	.+92     	; 0x852 <EXTI0_ChangeTriggerMode+0xa6>
     7f6:	3b c0       	rjmp	.+118    	; 0x86e <__stack+0xf>
	{
		case FallingEdge:
			SET_BIT(MCUCR_Register,ISC01);
     7f8:	a5 e5       	ldi	r26, 0x55	; 85
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	e5 e5       	ldi	r30, 0x55	; 85
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	80 81       	ld	r24, Z
     802:	82 60       	ori	r24, 0x02	; 2
     804:	8c 93       	st	X, r24
			CLR_BIT(MCUCR_Register,ISC00);
     806:	a5 e5       	ldi	r26, 0x55	; 85
     808:	b0 e0       	ldi	r27, 0x00	; 0
     80a:	e5 e5       	ldi	r30, 0x55	; 85
     80c:	f0 e0       	ldi	r31, 0x00	; 0
     80e:	80 81       	ld	r24, Z
     810:	8e 7f       	andi	r24, 0xFE	; 254
     812:	8c 93       	st	X, r24
     814:	2c c0       	rjmp	.+88     	; 0x86e <__stack+0xf>
			break;
		case RisingEdge:
			SET_BIT(MCUCR_Register,ISC01);
     816:	a5 e5       	ldi	r26, 0x55	; 85
     818:	b0 e0       	ldi	r27, 0x00	; 0
     81a:	e5 e5       	ldi	r30, 0x55	; 85
     81c:	f0 e0       	ldi	r31, 0x00	; 0
     81e:	80 81       	ld	r24, Z
     820:	82 60       	ori	r24, 0x02	; 2
     822:	8c 93       	st	X, r24
			SET_BIT(MCUCR_Register,ISC00);
     824:	a5 e5       	ldi	r26, 0x55	; 85
     826:	b0 e0       	ldi	r27, 0x00	; 0
     828:	e5 e5       	ldi	r30, 0x55	; 85
     82a:	f0 e0       	ldi	r31, 0x00	; 0
     82c:	80 81       	ld	r24, Z
     82e:	81 60       	ori	r24, 0x01	; 1
     830:	8c 93       	st	X, r24
     832:	1d c0       	rjmp	.+58     	; 0x86e <__stack+0xf>
			break;
		case OnChange:
			SET_BIT(MCUCR_Register,ISC00);
     834:	a5 e5       	ldi	r26, 0x55	; 85
     836:	b0 e0       	ldi	r27, 0x00	; 0
     838:	e5 e5       	ldi	r30, 0x55	; 85
     83a:	f0 e0       	ldi	r31, 0x00	; 0
     83c:	80 81       	ld	r24, Z
     83e:	81 60       	ori	r24, 0x01	; 1
     840:	8c 93       	st	X, r24
			CLR_BIT(MCUCR_Register,ISC01);
     842:	a5 e5       	ldi	r26, 0x55	; 85
     844:	b0 e0       	ldi	r27, 0x00	; 0
     846:	e5 e5       	ldi	r30, 0x55	; 85
     848:	f0 e0       	ldi	r31, 0x00	; 0
     84a:	80 81       	ld	r24, Z
     84c:	8d 7f       	andi	r24, 0xFD	; 253
     84e:	8c 93       	st	X, r24
     850:	0e c0       	rjmp	.+28     	; 0x86e <__stack+0xf>
			break;
		case LowLevel:
			CLR_BIT(MCUCR_Register,ISC00);
     852:	a5 e5       	ldi	r26, 0x55	; 85
     854:	b0 e0       	ldi	r27, 0x00	; 0
     856:	e5 e5       	ldi	r30, 0x55	; 85
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	80 81       	ld	r24, Z
     85c:	8e 7f       	andi	r24, 0xFE	; 254
     85e:	8c 93       	st	X, r24
			CLR_BIT(MCUCR_Register,ISC01);
     860:	a5 e5       	ldi	r26, 0x55	; 85
     862:	b0 e0       	ldi	r27, 0x00	; 0
     864:	e5 e5       	ldi	r30, 0x55	; 85
     866:	f0 e0       	ldi	r31, 0x00	; 0
     868:	80 81       	ld	r24, Z
     86a:	8d 7f       	andi	r24, 0xFD	; 253
     86c:	8c 93       	st	X, r24
			break;
		default:
			break;
	}
}
     86e:	0f 90       	pop	r0
     870:	0f 90       	pop	r0
     872:	0f 90       	pop	r0
     874:	cf 91       	pop	r28
     876:	df 91       	pop	r29
     878:	08 95       	ret

0000087a <EXTI_Enable>:


void EXTI_Enable(u8 Copy_u8IntNumber)
{
     87a:	df 93       	push	r29
     87c:	cf 93       	push	r28
     87e:	00 d0       	rcall	.+0      	; 0x880 <EXTI_Enable+0x6>
     880:	0f 92       	push	r0
     882:	cd b7       	in	r28, 0x3d	; 61
     884:	de b7       	in	r29, 0x3e	; 62
     886:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8IntNumber) {
     888:	89 81       	ldd	r24, Y+1	; 0x01
     88a:	28 2f       	mov	r18, r24
     88c:	30 e0       	ldi	r19, 0x00	; 0
     88e:	3b 83       	std	Y+3, r19	; 0x03
     890:	2a 83       	std	Y+2, r18	; 0x02
     892:	8a 81       	ldd	r24, Y+2	; 0x02
     894:	9b 81       	ldd	r25, Y+3	; 0x03
     896:	81 30       	cpi	r24, 0x01	; 1
     898:	91 05       	cpc	r25, r1
     89a:	89 f0       	breq	.+34     	; 0x8be <EXTI_Enable+0x44>
     89c:	2a 81       	ldd	r18, Y+2	; 0x02
     89e:	3b 81       	ldd	r19, Y+3	; 0x03
     8a0:	22 30       	cpi	r18, 0x02	; 2
     8a2:	31 05       	cpc	r19, r1
     8a4:	a1 f0       	breq	.+40     	; 0x8ce <EXTI_Enable+0x54>
     8a6:	8a 81       	ldd	r24, Y+2	; 0x02
     8a8:	9b 81       	ldd	r25, Y+3	; 0x03
     8aa:	00 97       	sbiw	r24, 0x00	; 0
     8ac:	b9 f4       	brne	.+46     	; 0x8dc <EXTI_Enable+0x62>
	case EXTI0:
		SET_BIT(GICR_Register,INT0);
     8ae:	ab e5       	ldi	r26, 0x5B	; 91
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	eb e5       	ldi	r30, 0x5B	; 91
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	80 81       	ld	r24, Z
     8b8:	80 64       	ori	r24, 0x40	; 64
     8ba:	8c 93       	st	X, r24
     8bc:	0f c0       	rjmp	.+30     	; 0x8dc <EXTI_Enable+0x62>
		break;
	case EXTI1:
		SET_BIT(GICR_Register,INT1);
     8be:	ab e5       	ldi	r26, 0x5B	; 91
     8c0:	b0 e0       	ldi	r27, 0x00	; 0
     8c2:	eb e5       	ldi	r30, 0x5B	; 91
     8c4:	f0 e0       	ldi	r31, 0x00	; 0
     8c6:	80 81       	ld	r24, Z
     8c8:	80 68       	ori	r24, 0x80	; 128
     8ca:	8c 93       	st	X, r24
     8cc:	07 c0       	rjmp	.+14     	; 0x8dc <EXTI_Enable+0x62>
		break;
	case EXTI2:
		SET_BIT(GICR_Register,INT2);
     8ce:	ab e5       	ldi	r26, 0x5B	; 91
     8d0:	b0 e0       	ldi	r27, 0x00	; 0
     8d2:	eb e5       	ldi	r30, 0x5B	; 91
     8d4:	f0 e0       	ldi	r31, 0x00	; 0
     8d6:	80 81       	ld	r24, Z
     8d8:	80 62       	ori	r24, 0x20	; 32
     8da:	8c 93       	st	X, r24
		break;
	default:
		break;
	}

}
     8dc:	0f 90       	pop	r0
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	cf 91       	pop	r28
     8e4:	df 91       	pop	r29
     8e6:	08 95       	ret

000008e8 <EXTI_Disable>:
void EXTI_Disable(u8 Copy_u8IntNumber)
{
     8e8:	df 93       	push	r29
     8ea:	cf 93       	push	r28
     8ec:	00 d0       	rcall	.+0      	; 0x8ee <EXTI_Disable+0x6>
     8ee:	0f 92       	push	r0
     8f0:	cd b7       	in	r28, 0x3d	; 61
     8f2:	de b7       	in	r29, 0x3e	; 62
     8f4:	89 83       	std	Y+1, r24	; 0x01
	switch (Copy_u8IntNumber) {
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	28 2f       	mov	r18, r24
     8fa:	30 e0       	ldi	r19, 0x00	; 0
     8fc:	3b 83       	std	Y+3, r19	; 0x03
     8fe:	2a 83       	std	Y+2, r18	; 0x02
     900:	8a 81       	ldd	r24, Y+2	; 0x02
     902:	9b 81       	ldd	r25, Y+3	; 0x03
     904:	81 30       	cpi	r24, 0x01	; 1
     906:	91 05       	cpc	r25, r1
     908:	89 f0       	breq	.+34     	; 0x92c <EXTI_Disable+0x44>
     90a:	2a 81       	ldd	r18, Y+2	; 0x02
     90c:	3b 81       	ldd	r19, Y+3	; 0x03
     90e:	22 30       	cpi	r18, 0x02	; 2
     910:	31 05       	cpc	r19, r1
     912:	a1 f0       	breq	.+40     	; 0x93c <EXTI_Disable+0x54>
     914:	8a 81       	ldd	r24, Y+2	; 0x02
     916:	9b 81       	ldd	r25, Y+3	; 0x03
     918:	00 97       	sbiw	r24, 0x00	; 0
     91a:	b9 f4       	brne	.+46     	; 0x94a <EXTI_Disable+0x62>
	case EXTI0:
		CLR_BIT(GICR_Register,INT0);
     91c:	ab e5       	ldi	r26, 0x5B	; 91
     91e:	b0 e0       	ldi	r27, 0x00	; 0
     920:	eb e5       	ldi	r30, 0x5B	; 91
     922:	f0 e0       	ldi	r31, 0x00	; 0
     924:	80 81       	ld	r24, Z
     926:	8f 7b       	andi	r24, 0xBF	; 191
     928:	8c 93       	st	X, r24
     92a:	0f c0       	rjmp	.+30     	; 0x94a <EXTI_Disable+0x62>
		break;
	case EXTI1:
		CLR_BIT(GICR_Register,INT1);
     92c:	ab e5       	ldi	r26, 0x5B	; 91
     92e:	b0 e0       	ldi	r27, 0x00	; 0
     930:	eb e5       	ldi	r30, 0x5B	; 91
     932:	f0 e0       	ldi	r31, 0x00	; 0
     934:	80 81       	ld	r24, Z
     936:	8f 77       	andi	r24, 0x7F	; 127
     938:	8c 93       	st	X, r24
     93a:	07 c0       	rjmp	.+14     	; 0x94a <EXTI_Disable+0x62>
		break;
	case EXTI2:
		CLR_BIT(GICR_Register,INT2);
     93c:	ab e5       	ldi	r26, 0x5B	; 91
     93e:	b0 e0       	ldi	r27, 0x00	; 0
     940:	eb e5       	ldi	r30, 0x5B	; 91
     942:	f0 e0       	ldi	r31, 0x00	; 0
     944:	80 81       	ld	r24, Z
     946:	8f 7d       	andi	r24, 0xDF	; 223
     948:	8c 93       	st	X, r24
		break;
	default:
		break;
	}

}
     94a:	0f 90       	pop	r0
     94c:	0f 90       	pop	r0
     94e:	0f 90       	pop	r0
     950:	cf 91       	pop	r28
     952:	df 91       	pop	r29
     954:	08 95       	ret

00000956 <EXTI0_CallBackFunc>:


void EXTI0_CallBackFunc(void(*ptr)(void))
{
     956:	df 93       	push	r29
     958:	cf 93       	push	r28
     95a:	00 d0       	rcall	.+0      	; 0x95c <EXTI0_CallBackFunc+0x6>
     95c:	cd b7       	in	r28, 0x3d	; 61
     95e:	de b7       	in	r29, 0x3e	; 62
     960:	9a 83       	std	Y+2, r25	; 0x02
     962:	89 83       	std	Y+1, r24	; 0x01
	EXTI0_GlobalPtr=ptr;
     964:	89 81       	ldd	r24, Y+1	; 0x01
     966:	9a 81       	ldd	r25, Y+2	; 0x02
     968:	90 93 69 00 	sts	0x0069, r25
     96c:	80 93 68 00 	sts	0x0068, r24
}
     970:	0f 90       	pop	r0
     972:	0f 90       	pop	r0
     974:	cf 91       	pop	r28
     976:	df 91       	pop	r29
     978:	08 95       	ret

0000097a <EXTI1_CallBackFunc>:
void EXTI1_CallBackFunc(void(*ptr)(void))
{
     97a:	df 93       	push	r29
     97c:	cf 93       	push	r28
     97e:	00 d0       	rcall	.+0      	; 0x980 <EXTI1_CallBackFunc+0x6>
     980:	cd b7       	in	r28, 0x3d	; 61
     982:	de b7       	in	r29, 0x3e	; 62
     984:	9a 83       	std	Y+2, r25	; 0x02
     986:	89 83       	std	Y+1, r24	; 0x01
	EXTI1_GlobalPtr=ptr;
     988:	89 81       	ldd	r24, Y+1	; 0x01
     98a:	9a 81       	ldd	r25, Y+2	; 0x02
     98c:	90 93 6b 00 	sts	0x006B, r25
     990:	80 93 6a 00 	sts	0x006A, r24

}
     994:	0f 90       	pop	r0
     996:	0f 90       	pop	r0
     998:	cf 91       	pop	r28
     99a:	df 91       	pop	r29
     99c:	08 95       	ret

0000099e <EXTI2_CallBackFunc>:
void EXTI2_CallBackFunc(void(*ptr)(void))
{
     99e:	df 93       	push	r29
     9a0:	cf 93       	push	r28
     9a2:	00 d0       	rcall	.+0      	; 0x9a4 <EXTI2_CallBackFunc+0x6>
     9a4:	cd b7       	in	r28, 0x3d	; 61
     9a6:	de b7       	in	r29, 0x3e	; 62
     9a8:	9a 83       	std	Y+2, r25	; 0x02
     9aa:	89 83       	std	Y+1, r24	; 0x01
	EXTI2_GlobalPtr=ptr;
     9ac:	89 81       	ldd	r24, Y+1	; 0x01
     9ae:	9a 81       	ldd	r25, Y+2	; 0x02
     9b0:	90 93 6d 00 	sts	0x006D, r25
     9b4:	80 93 6c 00 	sts	0x006C, r24
}
     9b8:	0f 90       	pop	r0
     9ba:	0f 90       	pop	r0
     9bc:	cf 91       	pop	r28
     9be:	df 91       	pop	r29
     9c0:	08 95       	ret

000009c2 <__vector_1>:

void __vector_1 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_1 (void)
{
     9c2:	1f 92       	push	r1
     9c4:	0f 92       	push	r0
     9c6:	0f b6       	in	r0, 0x3f	; 63
     9c8:	0f 92       	push	r0
     9ca:	11 24       	eor	r1, r1
     9cc:	2f 93       	push	r18
     9ce:	3f 93       	push	r19
     9d0:	4f 93       	push	r20
     9d2:	5f 93       	push	r21
     9d4:	6f 93       	push	r22
     9d6:	7f 93       	push	r23
     9d8:	8f 93       	push	r24
     9da:	9f 93       	push	r25
     9dc:	af 93       	push	r26
     9de:	bf 93       	push	r27
     9e0:	ef 93       	push	r30
     9e2:	ff 93       	push	r31
     9e4:	df 93       	push	r29
     9e6:	cf 93       	push	r28
     9e8:	cd b7       	in	r28, 0x3d	; 61
     9ea:	de b7       	in	r29, 0x3e	; 62
	EXTI0_GlobalPtr();
     9ec:	e0 91 68 00 	lds	r30, 0x0068
     9f0:	f0 91 69 00 	lds	r31, 0x0069
     9f4:	09 95       	icall
}
     9f6:	cf 91       	pop	r28
     9f8:	df 91       	pop	r29
     9fa:	ff 91       	pop	r31
     9fc:	ef 91       	pop	r30
     9fe:	bf 91       	pop	r27
     a00:	af 91       	pop	r26
     a02:	9f 91       	pop	r25
     a04:	8f 91       	pop	r24
     a06:	7f 91       	pop	r23
     a08:	6f 91       	pop	r22
     a0a:	5f 91       	pop	r21
     a0c:	4f 91       	pop	r20
     a0e:	3f 91       	pop	r19
     a10:	2f 91       	pop	r18
     a12:	0f 90       	pop	r0
     a14:	0f be       	out	0x3f, r0	; 63
     a16:	0f 90       	pop	r0
     a18:	1f 90       	pop	r1
     a1a:	18 95       	reti

00000a1c <__vector_2>:

void __vector_2 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_2 (void)
{
     a1c:	1f 92       	push	r1
     a1e:	0f 92       	push	r0
     a20:	0f b6       	in	r0, 0x3f	; 63
     a22:	0f 92       	push	r0
     a24:	11 24       	eor	r1, r1
     a26:	2f 93       	push	r18
     a28:	3f 93       	push	r19
     a2a:	4f 93       	push	r20
     a2c:	5f 93       	push	r21
     a2e:	6f 93       	push	r22
     a30:	7f 93       	push	r23
     a32:	8f 93       	push	r24
     a34:	9f 93       	push	r25
     a36:	af 93       	push	r26
     a38:	bf 93       	push	r27
     a3a:	ef 93       	push	r30
     a3c:	ff 93       	push	r31
     a3e:	df 93       	push	r29
     a40:	cf 93       	push	r28
     a42:	cd b7       	in	r28, 0x3d	; 61
     a44:	de b7       	in	r29, 0x3e	; 62
	EXTI1_GlobalPtr();
     a46:	e0 91 6a 00 	lds	r30, 0x006A
     a4a:	f0 91 6b 00 	lds	r31, 0x006B
     a4e:	09 95       	icall
}
     a50:	cf 91       	pop	r28
     a52:	df 91       	pop	r29
     a54:	ff 91       	pop	r31
     a56:	ef 91       	pop	r30
     a58:	bf 91       	pop	r27
     a5a:	af 91       	pop	r26
     a5c:	9f 91       	pop	r25
     a5e:	8f 91       	pop	r24
     a60:	7f 91       	pop	r23
     a62:	6f 91       	pop	r22
     a64:	5f 91       	pop	r21
     a66:	4f 91       	pop	r20
     a68:	3f 91       	pop	r19
     a6a:	2f 91       	pop	r18
     a6c:	0f 90       	pop	r0
     a6e:	0f be       	out	0x3f, r0	; 63
     a70:	0f 90       	pop	r0
     a72:	1f 90       	pop	r1
     a74:	18 95       	reti

00000a76 <__vector_3>:

void __vector_3 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_3 (void)
{
     a76:	1f 92       	push	r1
     a78:	0f 92       	push	r0
     a7a:	0f b6       	in	r0, 0x3f	; 63
     a7c:	0f 92       	push	r0
     a7e:	11 24       	eor	r1, r1
     a80:	2f 93       	push	r18
     a82:	3f 93       	push	r19
     a84:	4f 93       	push	r20
     a86:	5f 93       	push	r21
     a88:	6f 93       	push	r22
     a8a:	7f 93       	push	r23
     a8c:	8f 93       	push	r24
     a8e:	9f 93       	push	r25
     a90:	af 93       	push	r26
     a92:	bf 93       	push	r27
     a94:	ef 93       	push	r30
     a96:	ff 93       	push	r31
     a98:	df 93       	push	r29
     a9a:	cf 93       	push	r28
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
	EXTI2_GlobalPtr();
     aa0:	e0 91 6c 00 	lds	r30, 0x006C
     aa4:	f0 91 6d 00 	lds	r31, 0x006D
     aa8:	09 95       	icall
}
     aaa:	cf 91       	pop	r28
     aac:	df 91       	pop	r29
     aae:	ff 91       	pop	r31
     ab0:	ef 91       	pop	r30
     ab2:	bf 91       	pop	r27
     ab4:	af 91       	pop	r26
     ab6:	9f 91       	pop	r25
     ab8:	8f 91       	pop	r24
     aba:	7f 91       	pop	r23
     abc:	6f 91       	pop	r22
     abe:	5f 91       	pop	r21
     ac0:	4f 91       	pop	r20
     ac2:	3f 91       	pop	r19
     ac4:	2f 91       	pop	r18
     ac6:	0f 90       	pop	r0
     ac8:	0f be       	out	0x3f, r0	; 63
     aca:	0f 90       	pop	r0
     acc:	1f 90       	pop	r1
     ace:	18 95       	reti

00000ad0 <GIE_Enable>:
#include "GIE_int.h"



void GIE_Enable(void)
{
     ad0:	df 93       	push	r29
     ad2:	cf 93       	push	r28
     ad4:	cd b7       	in	r28, 0x3d	; 61
     ad6:	de b7       	in	r29, 0x3e	; 62
SET_BIT(SREG_Register,I);
     ad8:	af e5       	ldi	r26, 0x5F	; 95
     ada:	b0 e0       	ldi	r27, 0x00	; 0
     adc:	ef e5       	ldi	r30, 0x5F	; 95
     ade:	f0 e0       	ldi	r31, 0x00	; 0
     ae0:	80 81       	ld	r24, Z
     ae2:	80 68       	ori	r24, 0x80	; 128
     ae4:	8c 93       	st	X, r24
}
     ae6:	cf 91       	pop	r28
     ae8:	df 91       	pop	r29
     aea:	08 95       	ret

00000aec <GIE_Disable>:
void GIE_Disable(void)
{
     aec:	df 93       	push	r29
     aee:	cf 93       	push	r28
     af0:	cd b7       	in	r28, 0x3d	; 61
     af2:	de b7       	in	r29, 0x3e	; 62
CLR_BIT(SREG_Register,I);
     af4:	af e5       	ldi	r26, 0x5F	; 95
     af6:	b0 e0       	ldi	r27, 0x00	; 0
     af8:	ef e5       	ldi	r30, 0x5F	; 95
     afa:	f0 e0       	ldi	r31, 0x00	; 0
     afc:	80 81       	ld	r24, Z
     afe:	8f 77       	andi	r24, 0x7F	; 127
     b00:	8c 93       	st	X, r24
}
     b02:	cf 91       	pop	r28
     b04:	df 91       	pop	r29
     b06:	08 95       	ret

00000b08 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     b08:	df 93       	push	r29
     b0a:	cf 93       	push	r28
     b0c:	cd b7       	in	r28, 0x3d	; 61
     b0e:	de b7       	in	r29, 0x3e	; 62
     b10:	27 97       	sbiw	r28, 0x07	; 7
     b12:	0f b6       	in	r0, 0x3f	; 63
     b14:	f8 94       	cli
     b16:	de bf       	out	0x3e, r29	; 62
     b18:	0f be       	out	0x3f, r0	; 63
     b1a:	cd bf       	out	0x3d, r28	; 61
     b1c:	9d 83       	std	Y+5, r25	; 0x05
     b1e:	8c 83       	std	Y+4, r24	; 0x04
     b20:	6e 83       	std	Y+6, r22	; 0x06
     b22:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     b24:	8a e1       	ldi	r24, 0x1A	; 26
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
     b2c:	9a 83       	std	Y+2, r25	; 0x02
     b2e:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     b30:	89 81       	ldd	r24, Y+1	; 0x01
     b32:	9a 81       	ldd	r25, Y+2	; 0x02
     b34:	00 97       	sbiw	r24, 0x00	; 0
     b36:	09 f4       	brne	.+2      	; 0xb3a <xCoRoutineCreate+0x32>
     b38:	6f c0       	rjmp	.+222    	; 0xc18 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     b3a:	80 91 6e 00 	lds	r24, 0x006E
     b3e:	90 91 6f 00 	lds	r25, 0x006F
     b42:	00 97       	sbiw	r24, 0x00	; 0
     b44:	41 f4       	brne	.+16     	; 0xb56 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     b46:	89 81       	ldd	r24, Y+1	; 0x01
     b48:	9a 81       	ldd	r25, Y+2	; 0x02
     b4a:	90 93 6f 00 	sts	0x006F, r25
     b4e:	80 93 6e 00 	sts	0x006E, r24
			prvInitialiseCoRoutineLists();
     b52:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     b56:	8e 81       	ldd	r24, Y+6	; 0x06
     b58:	82 30       	cpi	r24, 0x02	; 2
     b5a:	10 f0       	brcs	.+4      	; 0xb60 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     b5c:	81 e0       	ldi	r24, 0x01	; 1
     b5e:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     b60:	e9 81       	ldd	r30, Y+1	; 0x01
     b62:	fa 81       	ldd	r31, Y+2	; 0x02
     b64:	11 8e       	std	Z+25, r1	; 0x19
     b66:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     b68:	e9 81       	ldd	r30, Y+1	; 0x01
     b6a:	fa 81       	ldd	r31, Y+2	; 0x02
     b6c:	8e 81       	ldd	r24, Y+6	; 0x06
     b6e:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     b70:	e9 81       	ldd	r30, Y+1	; 0x01
     b72:	fa 81       	ldd	r31, Y+2	; 0x02
     b74:	8f 81       	ldd	r24, Y+7	; 0x07
     b76:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     b78:	e9 81       	ldd	r30, Y+1	; 0x01
     b7a:	fa 81       	ldd	r31, Y+2	; 0x02
     b7c:	8c 81       	ldd	r24, Y+4	; 0x04
     b7e:	9d 81       	ldd	r25, Y+5	; 0x05
     b80:	91 83       	std	Z+1, r25	; 0x01
     b82:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	02 96       	adiw	r24, 0x02	; 2
     b8a:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     b8e:	89 81       	ldd	r24, Y+1	; 0x01
     b90:	9a 81       	ldd	r25, Y+2	; 0x02
     b92:	0c 96       	adiw	r24, 0x0c	; 12
     b94:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     b98:	e9 81       	ldd	r30, Y+1	; 0x01
     b9a:	fa 81       	ldd	r31, Y+2	; 0x02
     b9c:	89 81       	ldd	r24, Y+1	; 0x01
     b9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ba0:	91 87       	std	Z+9, r25	; 0x09
     ba2:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     ba4:	e9 81       	ldd	r30, Y+1	; 0x01
     ba6:	fa 81       	ldd	r31, Y+2	; 0x02
     ba8:	89 81       	ldd	r24, Y+1	; 0x01
     baa:	9a 81       	ldd	r25, Y+2	; 0x02
     bac:	93 8b       	std	Z+19, r25	; 0x13
     bae:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     bb0:	8e 81       	ldd	r24, Y+6	; 0x06
     bb2:	28 2f       	mov	r18, r24
     bb4:	30 e0       	ldi	r19, 0x00	; 0
     bb6:	85 e0       	ldi	r24, 0x05	; 5
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	82 1b       	sub	r24, r18
     bbc:	93 0b       	sbc	r25, r19
     bbe:	e9 81       	ldd	r30, Y+1	; 0x01
     bc0:	fa 81       	ldd	r31, Y+2	; 0x02
     bc2:	95 87       	std	Z+13, r25	; 0x0d
     bc4:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     bc6:	e9 81       	ldd	r30, Y+1	; 0x01
     bc8:	fa 81       	ldd	r31, Y+2	; 0x02
     bca:	96 89       	ldd	r25, Z+22	; 0x16
     bcc:	80 91 70 00 	lds	r24, 0x0070
     bd0:	89 17       	cp	r24, r25
     bd2:	28 f4       	brcc	.+10     	; 0xbde <xCoRoutineCreate+0xd6>
     bd4:	e9 81       	ldd	r30, Y+1	; 0x01
     bd6:	fa 81       	ldd	r31, Y+2	; 0x02
     bd8:	86 89       	ldd	r24, Z+22	; 0x16
     bda:	80 93 70 00 	sts	0x0070, r24
     bde:	e9 81       	ldd	r30, Y+1	; 0x01
     be0:	fa 81       	ldd	r31, Y+2	; 0x02
     be2:	86 89       	ldd	r24, Z+22	; 0x16
     be4:	28 2f       	mov	r18, r24
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	c9 01       	movw	r24, r18
     bea:	88 0f       	add	r24, r24
     bec:	99 1f       	adc	r25, r25
     bee:	88 0f       	add	r24, r24
     bf0:	99 1f       	adc	r25, r25
     bf2:	88 0f       	add	r24, r24
     bf4:	99 1f       	adc	r25, r25
     bf6:	82 0f       	add	r24, r18
     bf8:	93 1f       	adc	r25, r19
     bfa:	ac 01       	movw	r20, r24
     bfc:	49 58       	subi	r20, 0x89	; 137
     bfe:	5f 4f       	sbci	r21, 0xFF	; 255
     c00:	89 81       	ldd	r24, Y+1	; 0x01
     c02:	9a 81       	ldd	r25, Y+2	; 0x02
     c04:	9c 01       	movw	r18, r24
     c06:	2e 5f       	subi	r18, 0xFE	; 254
     c08:	3f 4f       	sbci	r19, 0xFF	; 255
     c0a:	ca 01       	movw	r24, r20
     c0c:	b9 01       	movw	r22, r18
     c0e:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

		xReturn = pdPASS;
     c12:	81 e0       	ldi	r24, 0x01	; 1
     c14:	8b 83       	std	Y+3, r24	; 0x03
     c16:	02 c0       	rjmp	.+4      	; 0xc1c <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c18:	8f ef       	ldi	r24, 0xFF	; 255
     c1a:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     c1c:	8b 81       	ldd	r24, Y+3	; 0x03
}
     c1e:	27 96       	adiw	r28, 0x07	; 7
     c20:	0f b6       	in	r0, 0x3f	; 63
     c22:	f8 94       	cli
     c24:	de bf       	out	0x3e, r29	; 62
     c26:	0f be       	out	0x3f, r0	; 63
     c28:	cd bf       	out	0x3d, r28	; 61
     c2a:	cf 91       	pop	r28
     c2c:	df 91       	pop	r29
     c2e:	08 95       	ret

00000c30 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     c30:	df 93       	push	r29
     c32:	cf 93       	push	r28
     c34:	00 d0       	rcall	.+0      	; 0xc36 <vCoRoutineAddToDelayedList+0x6>
     c36:	00 d0       	rcall	.+0      	; 0xc38 <vCoRoutineAddToDelayedList+0x8>
     c38:	00 d0       	rcall	.+0      	; 0xc3a <vCoRoutineAddToDelayedList+0xa>
     c3a:	cd b7       	in	r28, 0x3d	; 61
     c3c:	de b7       	in	r29, 0x3e	; 62
     c3e:	9c 83       	std	Y+4, r25	; 0x04
     c40:	8b 83       	std	Y+3, r24	; 0x03
     c42:	7e 83       	std	Y+6, r23	; 0x06
     c44:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     c46:	20 91 71 00 	lds	r18, 0x0071
     c4a:	30 91 72 00 	lds	r19, 0x0072
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	9c 81       	ldd	r25, Y+4	; 0x04
     c52:	82 0f       	add	r24, r18
     c54:	93 1f       	adc	r25, r19
     c56:	9a 83       	std	Y+2, r25	; 0x02
     c58:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c5a:	80 91 6e 00 	lds	r24, 0x006E
     c5e:	90 91 6f 00 	lds	r25, 0x006F
     c62:	02 96       	adiw	r24, 0x02	; 2
     c64:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     c68:	e0 91 6e 00 	lds	r30, 0x006E
     c6c:	f0 91 6f 00 	lds	r31, 0x006F
     c70:	89 81       	ldd	r24, Y+1	; 0x01
     c72:	9a 81       	ldd	r25, Y+2	; 0x02
     c74:	93 83       	std	Z+3, r25	; 0x03
     c76:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     c78:	20 91 71 00 	lds	r18, 0x0071
     c7c:	30 91 72 00 	lds	r19, 0x0072
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	9a 81       	ldd	r25, Y+2	; 0x02
     c84:	82 17       	cp	r24, r18
     c86:	93 07       	cpc	r25, r19
     c88:	70 f4       	brcc	.+28     	; 0xca6 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c8a:	80 91 9d 00 	lds	r24, 0x009D
     c8e:	90 91 9e 00 	lds	r25, 0x009E
     c92:	20 91 6e 00 	lds	r18, 0x006E
     c96:	30 91 6f 00 	lds	r19, 0x006F
     c9a:	2e 5f       	subi	r18, 0xFE	; 254
     c9c:	3f 4f       	sbci	r19, 0xFF	; 255
     c9e:	b9 01       	movw	r22, r18
     ca0:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
     ca4:	0d c0       	rjmp	.+26     	; 0xcc0 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ca6:	80 91 9b 00 	lds	r24, 0x009B
     caa:	90 91 9c 00 	lds	r25, 0x009C
     cae:	20 91 6e 00 	lds	r18, 0x006E
     cb2:	30 91 6f 00 	lds	r19, 0x006F
     cb6:	2e 5f       	subi	r18, 0xFE	; 254
     cb8:	3f 4f       	sbci	r19, 0xFF	; 255
     cba:	b9 01       	movw	r22, r18
     cbc:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
	}

	if( pxEventList )
     cc0:	8d 81       	ldd	r24, Y+5	; 0x05
     cc2:	9e 81       	ldd	r25, Y+6	; 0x06
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	61 f0       	breq	.+24     	; 0xce0 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     cc8:	80 91 6e 00 	lds	r24, 0x006E
     ccc:	90 91 6f 00 	lds	r25, 0x006F
     cd0:	9c 01       	movw	r18, r24
     cd2:	24 5f       	subi	r18, 0xF4	; 244
     cd4:	3f 4f       	sbci	r19, 0xFF	; 255
     cd6:	8d 81       	ldd	r24, Y+5	; 0x05
     cd8:	9e 81       	ldd	r25, Y+6	; 0x06
     cda:	b9 01       	movw	r22, r18
     cdc:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
	}
}
     ce0:	26 96       	adiw	r28, 0x06	; 6
     ce2:	0f b6       	in	r0, 0x3f	; 63
     ce4:	f8 94       	cli
     ce6:	de bf       	out	0x3e, r29	; 62
     ce8:	0f be       	out	0x3f, r0	; 63
     cea:	cd bf       	out	0x3d, r28	; 61
     cec:	cf 91       	pop	r28
     cee:	df 91       	pop	r29
     cf0:	08 95       	ret

00000cf2 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     cf2:	df 93       	push	r29
     cf4:	cf 93       	push	r28
     cf6:	00 d0       	rcall	.+0      	; 0xcf8 <prvCheckPendingReadyList+0x6>
     cf8:	cd b7       	in	r28, 0x3d	; 61
     cfa:	de b7       	in	r29, 0x3e	; 62
     cfc:	3a c0       	rjmp	.+116    	; 0xd72 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     cfe:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     d00:	e0 91 a4 00 	lds	r30, 0x00A4
     d04:	f0 91 a5 00 	lds	r31, 0x00A5
     d08:	86 81       	ldd	r24, Z+6	; 0x06
     d0a:	97 81       	ldd	r25, Z+7	; 0x07
     d0c:	9a 83       	std	Y+2, r25	; 0x02
     d0e:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d10:	89 81       	ldd	r24, Y+1	; 0x01
     d12:	9a 81       	ldd	r25, Y+2	; 0x02
     d14:	0c 96       	adiw	r24, 0x0c	; 12
     d16:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     d1a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     d1c:	89 81       	ldd	r24, Y+1	; 0x01
     d1e:	9a 81       	ldd	r25, Y+2	; 0x02
     d20:	02 96       	adiw	r24, 0x02	; 2
     d22:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     d26:	e9 81       	ldd	r30, Y+1	; 0x01
     d28:	fa 81       	ldd	r31, Y+2	; 0x02
     d2a:	96 89       	ldd	r25, Z+22	; 0x16
     d2c:	80 91 70 00 	lds	r24, 0x0070
     d30:	89 17       	cp	r24, r25
     d32:	28 f4       	brcc	.+10     	; 0xd3e <prvCheckPendingReadyList+0x4c>
     d34:	e9 81       	ldd	r30, Y+1	; 0x01
     d36:	fa 81       	ldd	r31, Y+2	; 0x02
     d38:	86 89       	ldd	r24, Z+22	; 0x16
     d3a:	80 93 70 00 	sts	0x0070, r24
     d3e:	e9 81       	ldd	r30, Y+1	; 0x01
     d40:	fa 81       	ldd	r31, Y+2	; 0x02
     d42:	86 89       	ldd	r24, Z+22	; 0x16
     d44:	28 2f       	mov	r18, r24
     d46:	30 e0       	ldi	r19, 0x00	; 0
     d48:	c9 01       	movw	r24, r18
     d4a:	88 0f       	add	r24, r24
     d4c:	99 1f       	adc	r25, r25
     d4e:	88 0f       	add	r24, r24
     d50:	99 1f       	adc	r25, r25
     d52:	88 0f       	add	r24, r24
     d54:	99 1f       	adc	r25, r25
     d56:	82 0f       	add	r24, r18
     d58:	93 1f       	adc	r25, r19
     d5a:	ac 01       	movw	r20, r24
     d5c:	49 58       	subi	r20, 0x89	; 137
     d5e:	5f 4f       	sbci	r21, 0xFF	; 255
     d60:	89 81       	ldd	r24, Y+1	; 0x01
     d62:	9a 81       	ldd	r25, Y+2	; 0x02
     d64:	9c 01       	movw	r18, r24
     d66:	2e 5f       	subi	r18, 0xFE	; 254
     d68:	3f 4f       	sbci	r19, 0xFF	; 255
     d6a:	ca 01       	movw	r24, r20
     d6c:	b9 01       	movw	r22, r18
     d6e:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     d72:	80 91 9f 00 	lds	r24, 0x009F
     d76:	88 23       	and	r24, r24
     d78:	09 f0       	breq	.+2      	; 0xd7c <prvCheckPendingReadyList+0x8a>
     d7a:	c1 cf       	rjmp	.-126    	; 0xcfe <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	cf 91       	pop	r28
     d82:	df 91       	pop	r29
     d84:	08 95       	ret

00000d86 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     d86:	df 93       	push	r29
     d88:	cf 93       	push	r28
     d8a:	00 d0       	rcall	.+0      	; 0xd8c <prvCheckDelayedList+0x6>
     d8c:	00 d0       	rcall	.+0      	; 0xd8e <prvCheckDelayedList+0x8>
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     d92:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <xTaskGetTickCount>
     d96:	20 91 73 00 	lds	r18, 0x0073
     d9a:	30 91 74 00 	lds	r19, 0x0074
     d9e:	82 1b       	sub	r24, r18
     da0:	93 0b       	sbc	r25, r19
     da2:	90 93 76 00 	sts	0x0076, r25
     da6:	80 93 75 00 	sts	0x0075, r24
     daa:	85 c0       	rjmp	.+266    	; 0xeb6 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     dac:	80 91 71 00 	lds	r24, 0x0071
     db0:	90 91 72 00 	lds	r25, 0x0072
     db4:	01 96       	adiw	r24, 0x01	; 1
     db6:	90 93 72 00 	sts	0x0072, r25
     dba:	80 93 71 00 	sts	0x0071, r24
		xPassedTicks--;
     dbe:	80 91 75 00 	lds	r24, 0x0075
     dc2:	90 91 76 00 	lds	r25, 0x0076
     dc6:	01 97       	sbiw	r24, 0x01	; 1
     dc8:	90 93 76 00 	sts	0x0076, r25
     dcc:	80 93 75 00 	sts	0x0075, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     dd0:	80 91 71 00 	lds	r24, 0x0071
     dd4:	90 91 72 00 	lds	r25, 0x0072
     dd8:	00 97       	sbiw	r24, 0x00	; 0
     dda:	09 f0       	breq	.+2      	; 0xdde <prvCheckDelayedList+0x58>
     ddc:	64 c0       	rjmp	.+200    	; 0xea6 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     dde:	80 91 9b 00 	lds	r24, 0x009B
     de2:	90 91 9c 00 	lds	r25, 0x009C
     de6:	9a 83       	std	Y+2, r25	; 0x02
     de8:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     dea:	80 91 9d 00 	lds	r24, 0x009D
     dee:	90 91 9e 00 	lds	r25, 0x009E
     df2:	90 93 9c 00 	sts	0x009C, r25
     df6:	80 93 9b 00 	sts	0x009B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     dfa:	89 81       	ldd	r24, Y+1	; 0x01
     dfc:	9a 81       	ldd	r25, Y+2	; 0x02
     dfe:	90 93 9e 00 	sts	0x009E, r25
     e02:	80 93 9d 00 	sts	0x009D, r24
     e06:	4f c0       	rjmp	.+158    	; 0xea6 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     e08:	e0 91 9b 00 	lds	r30, 0x009B
     e0c:	f0 91 9c 00 	lds	r31, 0x009C
     e10:	05 80       	ldd	r0, Z+5	; 0x05
     e12:	f6 81       	ldd	r31, Z+6	; 0x06
     e14:	e0 2d       	mov	r30, r0
     e16:	86 81       	ldd	r24, Z+6	; 0x06
     e18:	97 81       	ldd	r25, Z+7	; 0x07
     e1a:	9c 83       	std	Y+4, r25	; 0x04
     e1c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     e1e:	eb 81       	ldd	r30, Y+3	; 0x03
     e20:	fc 81       	ldd	r31, Y+4	; 0x04
     e22:	22 81       	ldd	r18, Z+2	; 0x02
     e24:	33 81       	ldd	r19, Z+3	; 0x03
     e26:	80 91 71 00 	lds	r24, 0x0071
     e2a:	90 91 72 00 	lds	r25, 0x0072
     e2e:	82 17       	cp	r24, r18
     e30:	93 07       	cpc	r25, r19
     e32:	08 f4       	brcc	.+2      	; 0xe36 <prvCheckDelayedList+0xb0>
     e34:	40 c0       	rjmp	.+128    	; 0xeb6 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     e36:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	9c 81       	ldd	r25, Y+4	; 0x04
     e3c:	02 96       	adiw	r24, 0x02	; 2
     e3e:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     e42:	eb 81       	ldd	r30, Y+3	; 0x03
     e44:	fc 81       	ldd	r31, Y+4	; 0x04
     e46:	84 89       	ldd	r24, Z+20	; 0x14
     e48:	95 89       	ldd	r25, Z+21	; 0x15
     e4a:	00 97       	sbiw	r24, 0x00	; 0
     e4c:	29 f0       	breq	.+10     	; 0xe58 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     e4e:	8b 81       	ldd	r24, Y+3	; 0x03
     e50:	9c 81       	ldd	r25, Y+4	; 0x04
     e52:	0c 96       	adiw	r24, 0x0c	; 12
     e54:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     e58:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     e5a:	eb 81       	ldd	r30, Y+3	; 0x03
     e5c:	fc 81       	ldd	r31, Y+4	; 0x04
     e5e:	96 89       	ldd	r25, Z+22	; 0x16
     e60:	80 91 70 00 	lds	r24, 0x0070
     e64:	89 17       	cp	r24, r25
     e66:	28 f4       	brcc	.+10     	; 0xe72 <prvCheckDelayedList+0xec>
     e68:	eb 81       	ldd	r30, Y+3	; 0x03
     e6a:	fc 81       	ldd	r31, Y+4	; 0x04
     e6c:	86 89       	ldd	r24, Z+22	; 0x16
     e6e:	80 93 70 00 	sts	0x0070, r24
     e72:	eb 81       	ldd	r30, Y+3	; 0x03
     e74:	fc 81       	ldd	r31, Y+4	; 0x04
     e76:	86 89       	ldd	r24, Z+22	; 0x16
     e78:	28 2f       	mov	r18, r24
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	c9 01       	movw	r24, r18
     e7e:	88 0f       	add	r24, r24
     e80:	99 1f       	adc	r25, r25
     e82:	88 0f       	add	r24, r24
     e84:	99 1f       	adc	r25, r25
     e86:	88 0f       	add	r24, r24
     e88:	99 1f       	adc	r25, r25
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	ac 01       	movw	r20, r24
     e90:	49 58       	subi	r20, 0x89	; 137
     e92:	5f 4f       	sbci	r21, 0xFF	; 255
     e94:	8b 81       	ldd	r24, Y+3	; 0x03
     e96:	9c 81       	ldd	r25, Y+4	; 0x04
     e98:	9c 01       	movw	r18, r24
     e9a:	2e 5f       	subi	r18, 0xFE	; 254
     e9c:	3f 4f       	sbci	r19, 0xFF	; 255
     e9e:	ca 01       	movw	r24, r20
     ea0:	b9 01       	movw	r22, r18
     ea2:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     ea6:	e0 91 9b 00 	lds	r30, 0x009B
     eaa:	f0 91 9c 00 	lds	r31, 0x009C
     eae:	80 81       	ld	r24, Z
     eb0:	88 23       	and	r24, r24
     eb2:	09 f0       	breq	.+2      	; 0xeb6 <prvCheckDelayedList+0x130>
     eb4:	a9 cf       	rjmp	.-174    	; 0xe08 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     eb6:	80 91 75 00 	lds	r24, 0x0075
     eba:	90 91 76 00 	lds	r25, 0x0076
     ebe:	00 97       	sbiw	r24, 0x00	; 0
     ec0:	09 f0       	breq	.+2      	; 0xec4 <prvCheckDelayedList+0x13e>
     ec2:	74 cf       	rjmp	.-280    	; 0xdac <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     ec4:	80 91 71 00 	lds	r24, 0x0071
     ec8:	90 91 72 00 	lds	r25, 0x0072
     ecc:	90 93 74 00 	sts	0x0074, r25
     ed0:	80 93 73 00 	sts	0x0073, r24
}
     ed4:	0f 90       	pop	r0
     ed6:	0f 90       	pop	r0
     ed8:	0f 90       	pop	r0
     eda:	0f 90       	pop	r0
     edc:	cf 91       	pop	r28
     ede:	df 91       	pop	r29
     ee0:	08 95       	ret

00000ee2 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     ee2:	df 93       	push	r29
     ee4:	cf 93       	push	r28
     ee6:	00 d0       	rcall	.+0      	; 0xee8 <vCoRoutineSchedule+0x6>
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     eec:	0e 94 79 06 	call	0xcf2	; 0xcf2 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     ef0:	0e 94 c3 06 	call	0xd86	; 0xd86 <prvCheckDelayedList>
     ef4:	0a c0       	rjmp	.+20     	; 0xf0a <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     ef6:	80 91 70 00 	lds	r24, 0x0070
     efa:	88 23       	and	r24, r24
     efc:	09 f4       	brne	.+2      	; 0xf00 <vCoRoutineSchedule+0x1e>
     efe:	66 c0       	rjmp	.+204    	; 0xfcc <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     f00:	80 91 70 00 	lds	r24, 0x0070
     f04:	81 50       	subi	r24, 0x01	; 1
     f06:	80 93 70 00 	sts	0x0070, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     f0a:	80 91 70 00 	lds	r24, 0x0070
     f0e:	28 2f       	mov	r18, r24
     f10:	30 e0       	ldi	r19, 0x00	; 0
     f12:	c9 01       	movw	r24, r18
     f14:	88 0f       	add	r24, r24
     f16:	99 1f       	adc	r25, r25
     f18:	88 0f       	add	r24, r24
     f1a:	99 1f       	adc	r25, r25
     f1c:	88 0f       	add	r24, r24
     f1e:	99 1f       	adc	r25, r25
     f20:	82 0f       	add	r24, r18
     f22:	93 1f       	adc	r25, r19
     f24:	fc 01       	movw	r30, r24
     f26:	e9 58       	subi	r30, 0x89	; 137
     f28:	ff 4f       	sbci	r31, 0xFF	; 255
     f2a:	80 81       	ld	r24, Z
     f2c:	88 23       	and	r24, r24
     f2e:	19 f3       	breq	.-58     	; 0xef6 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     f30:	80 91 70 00 	lds	r24, 0x0070
     f34:	28 2f       	mov	r18, r24
     f36:	30 e0       	ldi	r19, 0x00	; 0
     f38:	c9 01       	movw	r24, r18
     f3a:	88 0f       	add	r24, r24
     f3c:	99 1f       	adc	r25, r25
     f3e:	88 0f       	add	r24, r24
     f40:	99 1f       	adc	r25, r25
     f42:	88 0f       	add	r24, r24
     f44:	99 1f       	adc	r25, r25
     f46:	82 0f       	add	r24, r18
     f48:	93 1f       	adc	r25, r19
     f4a:	89 58       	subi	r24, 0x89	; 137
     f4c:	9f 4f       	sbci	r25, 0xFF	; 255
     f4e:	9a 83       	std	Y+2, r25	; 0x02
     f50:	89 83       	std	Y+1, r24	; 0x01
     f52:	e9 81       	ldd	r30, Y+1	; 0x01
     f54:	fa 81       	ldd	r31, Y+2	; 0x02
     f56:	01 80       	ldd	r0, Z+1	; 0x01
     f58:	f2 81       	ldd	r31, Z+2	; 0x02
     f5a:	e0 2d       	mov	r30, r0
     f5c:	82 81       	ldd	r24, Z+2	; 0x02
     f5e:	93 81       	ldd	r25, Z+3	; 0x03
     f60:	e9 81       	ldd	r30, Y+1	; 0x01
     f62:	fa 81       	ldd	r31, Y+2	; 0x02
     f64:	92 83       	std	Z+2, r25	; 0x02
     f66:	81 83       	std	Z+1, r24	; 0x01
     f68:	e9 81       	ldd	r30, Y+1	; 0x01
     f6a:	fa 81       	ldd	r31, Y+2	; 0x02
     f6c:	21 81       	ldd	r18, Z+1	; 0x01
     f6e:	32 81       	ldd	r19, Z+2	; 0x02
     f70:	89 81       	ldd	r24, Y+1	; 0x01
     f72:	9a 81       	ldd	r25, Y+2	; 0x02
     f74:	03 96       	adiw	r24, 0x03	; 3
     f76:	28 17       	cp	r18, r24
     f78:	39 07       	cpc	r19, r25
     f7a:	59 f4       	brne	.+22     	; 0xf92 <vCoRoutineSchedule+0xb0>
     f7c:	e9 81       	ldd	r30, Y+1	; 0x01
     f7e:	fa 81       	ldd	r31, Y+2	; 0x02
     f80:	01 80       	ldd	r0, Z+1	; 0x01
     f82:	f2 81       	ldd	r31, Z+2	; 0x02
     f84:	e0 2d       	mov	r30, r0
     f86:	82 81       	ldd	r24, Z+2	; 0x02
     f88:	93 81       	ldd	r25, Z+3	; 0x03
     f8a:	e9 81       	ldd	r30, Y+1	; 0x01
     f8c:	fa 81       	ldd	r31, Y+2	; 0x02
     f8e:	92 83       	std	Z+2, r25	; 0x02
     f90:	81 83       	std	Z+1, r24	; 0x01
     f92:	e9 81       	ldd	r30, Y+1	; 0x01
     f94:	fa 81       	ldd	r31, Y+2	; 0x02
     f96:	01 80       	ldd	r0, Z+1	; 0x01
     f98:	f2 81       	ldd	r31, Z+2	; 0x02
     f9a:	e0 2d       	mov	r30, r0
     f9c:	86 81       	ldd	r24, Z+6	; 0x06
     f9e:	97 81       	ldd	r25, Z+7	; 0x07
     fa0:	90 93 6f 00 	sts	0x006F, r25
     fa4:	80 93 6e 00 	sts	0x006E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     fa8:	e0 91 6e 00 	lds	r30, 0x006E
     fac:	f0 91 6f 00 	lds	r31, 0x006F
     fb0:	40 81       	ld	r20, Z
     fb2:	51 81       	ldd	r21, Z+1	; 0x01
     fb4:	80 91 6e 00 	lds	r24, 0x006E
     fb8:	90 91 6f 00 	lds	r25, 0x006F
     fbc:	e0 91 6e 00 	lds	r30, 0x006E
     fc0:	f0 91 6f 00 	lds	r31, 0x006F
     fc4:	27 89       	ldd	r18, Z+23	; 0x17
     fc6:	62 2f       	mov	r22, r18
     fc8:	fa 01       	movw	r30, r20
     fca:	09 95       	icall

	return;
}
     fcc:	0f 90       	pop	r0
     fce:	0f 90       	pop	r0
     fd0:	cf 91       	pop	r28
     fd2:	df 91       	pop	r29
     fd4:	08 95       	ret

00000fd6 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     fd6:	df 93       	push	r29
     fd8:	cf 93       	push	r28
     fda:	0f 92       	push	r0
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     fe0:	19 82       	std	Y+1, r1	; 0x01
     fe2:	13 c0       	rjmp	.+38     	; 0x100a <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     fe4:	89 81       	ldd	r24, Y+1	; 0x01
     fe6:	28 2f       	mov	r18, r24
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	c9 01       	movw	r24, r18
     fec:	88 0f       	add	r24, r24
     fee:	99 1f       	adc	r25, r25
     ff0:	88 0f       	add	r24, r24
     ff2:	99 1f       	adc	r25, r25
     ff4:	88 0f       	add	r24, r24
     ff6:	99 1f       	adc	r25, r25
     ff8:	82 0f       	add	r24, r18
     ffa:	93 1f       	adc	r25, r19
     ffc:	89 58       	subi	r24, 0x89	; 137
     ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    1000:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1004:	89 81       	ldd	r24, Y+1	; 0x01
    1006:	8f 5f       	subi	r24, 0xFF	; 255
    1008:	89 83       	std	Y+1, r24	; 0x01
    100a:	89 81       	ldd	r24, Y+1	; 0x01
    100c:	82 30       	cpi	r24, 0x02	; 2
    100e:	50 f3       	brcs	.-44     	; 0xfe4 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1010:	89 e8       	ldi	r24, 0x89	; 137
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1018:	82 e9       	ldi	r24, 0x92	; 146
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1020:	8f e9       	ldi	r24, 0x9F	; 159
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1028:	89 e8       	ldi	r24, 0x89	; 137
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	90 93 9c 00 	sts	0x009C, r25
    1030:	80 93 9b 00 	sts	0x009B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1034:	82 e9       	ldi	r24, 0x92	; 146
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	90 93 9e 00 	sts	0x009E, r25
    103c:	80 93 9d 00 	sts	0x009D, r24
}
    1040:	0f 90       	pop	r0
    1042:	cf 91       	pop	r28
    1044:	df 91       	pop	r29
    1046:	08 95       	ret

00001048 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1048:	df 93       	push	r29
    104a:	cf 93       	push	r28
    104c:	00 d0       	rcall	.+0      	; 0x104e <xCoRoutineRemoveFromEventList+0x6>
    104e:	00 d0       	rcall	.+0      	; 0x1050 <xCoRoutineRemoveFromEventList+0x8>
    1050:	0f 92       	push	r0
    1052:	cd b7       	in	r28, 0x3d	; 61
    1054:	de b7       	in	r29, 0x3e	; 62
    1056:	9d 83       	std	Y+5, r25	; 0x05
    1058:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    105a:	ec 81       	ldd	r30, Y+4	; 0x04
    105c:	fd 81       	ldd	r31, Y+5	; 0x05
    105e:	05 80       	ldd	r0, Z+5	; 0x05
    1060:	f6 81       	ldd	r31, Z+6	; 0x06
    1062:	e0 2d       	mov	r30, r0
    1064:	86 81       	ldd	r24, Z+6	; 0x06
    1066:	97 81       	ldd	r25, Z+7	; 0x07
    1068:	9b 83       	std	Y+3, r25	; 0x03
    106a:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    106c:	8a 81       	ldd	r24, Y+2	; 0x02
    106e:	9b 81       	ldd	r25, Y+3	; 0x03
    1070:	0c 96       	adiw	r24, 0x0c	; 12
    1072:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1076:	8a 81       	ldd	r24, Y+2	; 0x02
    1078:	9b 81       	ldd	r25, Y+3	; 0x03
    107a:	9c 01       	movw	r18, r24
    107c:	24 5f       	subi	r18, 0xF4	; 244
    107e:	3f 4f       	sbci	r19, 0xFF	; 255
    1080:	8f e9       	ldi	r24, 0x9F	; 159
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	b9 01       	movw	r22, r18
    1086:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    108a:	ea 81       	ldd	r30, Y+2	; 0x02
    108c:	fb 81       	ldd	r31, Y+3	; 0x03
    108e:	96 89       	ldd	r25, Z+22	; 0x16
    1090:	e0 91 6e 00 	lds	r30, 0x006E
    1094:	f0 91 6f 00 	lds	r31, 0x006F
    1098:	86 89       	ldd	r24, Z+22	; 0x16
    109a:	98 17       	cp	r25, r24
    109c:	18 f0       	brcs	.+6      	; 0x10a4 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    109e:	81 e0       	ldi	r24, 0x01	; 1
    10a0:	89 83       	std	Y+1, r24	; 0x01
    10a2:	01 c0       	rjmp	.+2      	; 0x10a6 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    10a4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    10a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    10a8:	0f 90       	pop	r0
    10aa:	0f 90       	pop	r0
    10ac:	0f 90       	pop	r0
    10ae:	0f 90       	pop	r0
    10b0:	0f 90       	pop	r0
    10b2:	cf 91       	pop	r28
    10b4:	df 91       	pop	r29
    10b6:	08 95       	ret

000010b8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10b8:	df 93       	push	r29
    10ba:	cf 93       	push	r28
    10bc:	00 d0       	rcall	.+0      	; 0x10be <pvPortMalloc+0x6>
    10be:	00 d0       	rcall	.+0      	; 0x10c0 <pvPortMalloc+0x8>
    10c0:	cd b7       	in	r28, 0x3d	; 61
    10c2:	de b7       	in	r29, 0x3e	; 62
    10c4:	9c 83       	std	Y+4, r25	; 0x04
    10c6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    10c8:	1a 82       	std	Y+2, r1	; 0x02
    10ca:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    10cc:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    10d0:	80 91 a8 00 	lds	r24, 0x00A8
    10d4:	90 91 a9 00 	lds	r25, 0x00A9
    10d8:	2b 81       	ldd	r18, Y+3	; 0x03
    10da:	3c 81       	ldd	r19, Y+4	; 0x04
    10dc:	82 0f       	add	r24, r18
    10de:	93 1f       	adc	r25, r19
    10e0:	22 e0       	ldi	r18, 0x02	; 2
    10e2:	88 35       	cpi	r24, 0x58	; 88
    10e4:	92 07       	cpc	r25, r18
    10e6:	18 f5       	brcc	.+70     	; 0x112e <pvPortMalloc+0x76>
    10e8:	20 91 a8 00 	lds	r18, 0x00A8
    10ec:	30 91 a9 00 	lds	r19, 0x00A9
    10f0:	8b 81       	ldd	r24, Y+3	; 0x03
    10f2:	9c 81       	ldd	r25, Y+4	; 0x04
    10f4:	28 0f       	add	r18, r24
    10f6:	39 1f       	adc	r19, r25
    10f8:	80 91 a8 00 	lds	r24, 0x00A8
    10fc:	90 91 a9 00 	lds	r25, 0x00A9
    1100:	82 17       	cp	r24, r18
    1102:	93 07       	cpc	r25, r19
    1104:	a0 f4       	brcc	.+40     	; 0x112e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1106:	80 91 a8 00 	lds	r24, 0x00A8
    110a:	90 91 a9 00 	lds	r25, 0x00A9
    110e:	86 55       	subi	r24, 0x56	; 86
    1110:	9f 4f       	sbci	r25, 0xFF	; 255
    1112:	9a 83       	std	Y+2, r25	; 0x02
    1114:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    1116:	20 91 a8 00 	lds	r18, 0x00A8
    111a:	30 91 a9 00 	lds	r19, 0x00A9
    111e:	8b 81       	ldd	r24, Y+3	; 0x03
    1120:	9c 81       	ldd	r25, Y+4	; 0x04
    1122:	82 0f       	add	r24, r18
    1124:	93 1f       	adc	r25, r19
    1126:	90 93 a9 00 	sts	0x00A9, r25
    112a:	80 93 a8 00 	sts	0x00A8, r24
		}	
	}
	xTaskResumeAll();
    112e:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1132:	89 81       	ldd	r24, Y+1	; 0x01
    1134:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1136:	0f 90       	pop	r0
    1138:	0f 90       	pop	r0
    113a:	0f 90       	pop	r0
    113c:	0f 90       	pop	r0
    113e:	cf 91       	pop	r28
    1140:	df 91       	pop	r29
    1142:	08 95       	ret

00001144 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1144:	df 93       	push	r29
    1146:	cf 93       	push	r28
    1148:	00 d0       	rcall	.+0      	; 0x114a <vPortFree+0x6>
    114a:	cd b7       	in	r28, 0x3d	; 61
    114c:	de b7       	in	r29, 0x3e	; 62
    114e:	9a 83       	std	Y+2, r25	; 0x02
    1150:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1152:	0f 90       	pop	r0
    1154:	0f 90       	pop	r0
    1156:	cf 91       	pop	r28
    1158:	df 91       	pop	r29
    115a:	08 95       	ret

0000115c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    115c:	df 93       	push	r29
    115e:	cf 93       	push	r28
    1160:	cd b7       	in	r28, 0x3d	; 61
    1162:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1164:	10 92 a9 00 	sts	0x00A9, r1
    1168:	10 92 a8 00 	sts	0x00A8, r1
}
    116c:	cf 91       	pop	r28
    116e:	df 91       	pop	r29
    1170:	08 95       	ret

00001172 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1172:	df 93       	push	r29
    1174:	cf 93       	push	r28
    1176:	cd b7       	in	r28, 0x3d	; 61
    1178:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    117a:	20 91 a8 00 	lds	r18, 0x00A8
    117e:	30 91 a9 00 	lds	r19, 0x00A9
    1182:	88 e5       	ldi	r24, 0x58	; 88
    1184:	92 e0       	ldi	r25, 0x02	; 2
    1186:	82 1b       	sub	r24, r18
    1188:	93 0b       	sbc	r25, r19
}
    118a:	cf 91       	pop	r28
    118c:	df 91       	pop	r29
    118e:	08 95       	ret

00001190 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1190:	df 93       	push	r29
    1192:	cf 93       	push	r28
    1194:	00 d0       	rcall	.+0      	; 0x1196 <vListInitialise+0x6>
    1196:	cd b7       	in	r28, 0x3d	; 61
    1198:	de b7       	in	r29, 0x3e	; 62
    119a:	9a 83       	std	Y+2, r25	; 0x02
    119c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    119e:	89 81       	ldd	r24, Y+1	; 0x01
    11a0:	9a 81       	ldd	r25, Y+2	; 0x02
    11a2:	03 96       	adiw	r24, 0x03	; 3
    11a4:	e9 81       	ldd	r30, Y+1	; 0x01
    11a6:	fa 81       	ldd	r31, Y+2	; 0x02
    11a8:	92 83       	std	Z+2, r25	; 0x02
    11aa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    11ac:	e9 81       	ldd	r30, Y+1	; 0x01
    11ae:	fa 81       	ldd	r31, Y+2	; 0x02
    11b0:	8f ef       	ldi	r24, 0xFF	; 255
    11b2:	9f ef       	ldi	r25, 0xFF	; 255
    11b4:	94 83       	std	Z+4, r25	; 0x04
    11b6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    11b8:	89 81       	ldd	r24, Y+1	; 0x01
    11ba:	9a 81       	ldd	r25, Y+2	; 0x02
    11bc:	03 96       	adiw	r24, 0x03	; 3
    11be:	e9 81       	ldd	r30, Y+1	; 0x01
    11c0:	fa 81       	ldd	r31, Y+2	; 0x02
    11c2:	96 83       	std	Z+6, r25	; 0x06
    11c4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    11c6:	89 81       	ldd	r24, Y+1	; 0x01
    11c8:	9a 81       	ldd	r25, Y+2	; 0x02
    11ca:	03 96       	adiw	r24, 0x03	; 3
    11cc:	e9 81       	ldd	r30, Y+1	; 0x01
    11ce:	fa 81       	ldd	r31, Y+2	; 0x02
    11d0:	90 87       	std	Z+8, r25	; 0x08
    11d2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    11d4:	e9 81       	ldd	r30, Y+1	; 0x01
    11d6:	fa 81       	ldd	r31, Y+2	; 0x02
    11d8:	10 82       	st	Z, r1
}
    11da:	0f 90       	pop	r0
    11dc:	0f 90       	pop	r0
    11de:	cf 91       	pop	r28
    11e0:	df 91       	pop	r29
    11e2:	08 95       	ret

000011e4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    11e4:	df 93       	push	r29
    11e6:	cf 93       	push	r28
    11e8:	00 d0       	rcall	.+0      	; 0x11ea <vListInitialiseItem+0x6>
    11ea:	cd b7       	in	r28, 0x3d	; 61
    11ec:	de b7       	in	r29, 0x3e	; 62
    11ee:	9a 83       	std	Y+2, r25	; 0x02
    11f0:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    11f2:	e9 81       	ldd	r30, Y+1	; 0x01
    11f4:	fa 81       	ldd	r31, Y+2	; 0x02
    11f6:	11 86       	std	Z+9, r1	; 0x09
    11f8:	10 86       	std	Z+8, r1	; 0x08
}
    11fa:	0f 90       	pop	r0
    11fc:	0f 90       	pop	r0
    11fe:	cf 91       	pop	r28
    1200:	df 91       	pop	r29
    1202:	08 95       	ret

00001204 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1204:	df 93       	push	r29
    1206:	cf 93       	push	r28
    1208:	00 d0       	rcall	.+0      	; 0x120a <vListInsertEnd+0x6>
    120a:	00 d0       	rcall	.+0      	; 0x120c <vListInsertEnd+0x8>
    120c:	00 d0       	rcall	.+0      	; 0x120e <vListInsertEnd+0xa>
    120e:	cd b7       	in	r28, 0x3d	; 61
    1210:	de b7       	in	r29, 0x3e	; 62
    1212:	9c 83       	std	Y+4, r25	; 0x04
    1214:	8b 83       	std	Y+3, r24	; 0x03
    1216:	7e 83       	std	Y+6, r23	; 0x06
    1218:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    121a:	eb 81       	ldd	r30, Y+3	; 0x03
    121c:	fc 81       	ldd	r31, Y+4	; 0x04
    121e:	81 81       	ldd	r24, Z+1	; 0x01
    1220:	92 81       	ldd	r25, Z+2	; 0x02
    1222:	9a 83       	std	Y+2, r25	; 0x02
    1224:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    1226:	e9 81       	ldd	r30, Y+1	; 0x01
    1228:	fa 81       	ldd	r31, Y+2	; 0x02
    122a:	82 81       	ldd	r24, Z+2	; 0x02
    122c:	93 81       	ldd	r25, Z+3	; 0x03
    122e:	ed 81       	ldd	r30, Y+5	; 0x05
    1230:	fe 81       	ldd	r31, Y+6	; 0x06
    1232:	93 83       	std	Z+3, r25	; 0x03
    1234:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1236:	eb 81       	ldd	r30, Y+3	; 0x03
    1238:	fc 81       	ldd	r31, Y+4	; 0x04
    123a:	81 81       	ldd	r24, Z+1	; 0x01
    123c:	92 81       	ldd	r25, Z+2	; 0x02
    123e:	ed 81       	ldd	r30, Y+5	; 0x05
    1240:	fe 81       	ldd	r31, Y+6	; 0x06
    1242:	95 83       	std	Z+5, r25	; 0x05
    1244:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1246:	e9 81       	ldd	r30, Y+1	; 0x01
    1248:	fa 81       	ldd	r31, Y+2	; 0x02
    124a:	02 80       	ldd	r0, Z+2	; 0x02
    124c:	f3 81       	ldd	r31, Z+3	; 0x03
    124e:	e0 2d       	mov	r30, r0
    1250:	8d 81       	ldd	r24, Y+5	; 0x05
    1252:	9e 81       	ldd	r25, Y+6	; 0x06
    1254:	95 83       	std	Z+5, r25	; 0x05
    1256:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1258:	8d 81       	ldd	r24, Y+5	; 0x05
    125a:	9e 81       	ldd	r25, Y+6	; 0x06
    125c:	e9 81       	ldd	r30, Y+1	; 0x01
    125e:	fa 81       	ldd	r31, Y+2	; 0x02
    1260:	93 83       	std	Z+3, r25	; 0x03
    1262:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1264:	8d 81       	ldd	r24, Y+5	; 0x05
    1266:	9e 81       	ldd	r25, Y+6	; 0x06
    1268:	eb 81       	ldd	r30, Y+3	; 0x03
    126a:	fc 81       	ldd	r31, Y+4	; 0x04
    126c:	92 83       	std	Z+2, r25	; 0x02
    126e:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1270:	ed 81       	ldd	r30, Y+5	; 0x05
    1272:	fe 81       	ldd	r31, Y+6	; 0x06
    1274:	8b 81       	ldd	r24, Y+3	; 0x03
    1276:	9c 81       	ldd	r25, Y+4	; 0x04
    1278:	91 87       	std	Z+9, r25	; 0x09
    127a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    127c:	eb 81       	ldd	r30, Y+3	; 0x03
    127e:	fc 81       	ldd	r31, Y+4	; 0x04
    1280:	80 81       	ld	r24, Z
    1282:	8f 5f       	subi	r24, 0xFF	; 255
    1284:	eb 81       	ldd	r30, Y+3	; 0x03
    1286:	fc 81       	ldd	r31, Y+4	; 0x04
    1288:	80 83       	st	Z, r24
}
    128a:	26 96       	adiw	r28, 0x06	; 6
    128c:	0f b6       	in	r0, 0x3f	; 63
    128e:	f8 94       	cli
    1290:	de bf       	out	0x3e, r29	; 62
    1292:	0f be       	out	0x3f, r0	; 63
    1294:	cd bf       	out	0x3d, r28	; 61
    1296:	cf 91       	pop	r28
    1298:	df 91       	pop	r29
    129a:	08 95       	ret

0000129c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    129c:	df 93       	push	r29
    129e:	cf 93       	push	r28
    12a0:	cd b7       	in	r28, 0x3d	; 61
    12a2:	de b7       	in	r29, 0x3e	; 62
    12a4:	28 97       	sbiw	r28, 0x08	; 8
    12a6:	0f b6       	in	r0, 0x3f	; 63
    12a8:	f8 94       	cli
    12aa:	de bf       	out	0x3e, r29	; 62
    12ac:	0f be       	out	0x3f, r0	; 63
    12ae:	cd bf       	out	0x3d, r28	; 61
    12b0:	9e 83       	std	Y+6, r25	; 0x06
    12b2:	8d 83       	std	Y+5, r24	; 0x05
    12b4:	78 87       	std	Y+8, r23	; 0x08
    12b6:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    12b8:	ef 81       	ldd	r30, Y+7	; 0x07
    12ba:	f8 85       	ldd	r31, Y+8	; 0x08
    12bc:	80 81       	ld	r24, Z
    12be:	91 81       	ldd	r25, Z+1	; 0x01
    12c0:	9a 83       	std	Y+2, r25	; 0x02
    12c2:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    12c4:	89 81       	ldd	r24, Y+1	; 0x01
    12c6:	9a 81       	ldd	r25, Y+2	; 0x02
    12c8:	2f ef       	ldi	r18, 0xFF	; 255
    12ca:	8f 3f       	cpi	r24, 0xFF	; 255
    12cc:	92 07       	cpc	r25, r18
    12ce:	39 f4       	brne	.+14     	; 0x12de <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    12d0:	ed 81       	ldd	r30, Y+5	; 0x05
    12d2:	fe 81       	ldd	r31, Y+6	; 0x06
    12d4:	87 81       	ldd	r24, Z+7	; 0x07
    12d6:	90 85       	ldd	r25, Z+8	; 0x08
    12d8:	9c 83       	std	Y+4, r25	; 0x04
    12da:	8b 83       	std	Y+3, r24	; 0x03
    12dc:	18 c0       	rjmp	.+48     	; 0x130e <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    12de:	8d 81       	ldd	r24, Y+5	; 0x05
    12e0:	9e 81       	ldd	r25, Y+6	; 0x06
    12e2:	03 96       	adiw	r24, 0x03	; 3
    12e4:	9c 83       	std	Y+4, r25	; 0x04
    12e6:	8b 83       	std	Y+3, r24	; 0x03
    12e8:	06 c0       	rjmp	.+12     	; 0x12f6 <vListInsert+0x5a>
    12ea:	eb 81       	ldd	r30, Y+3	; 0x03
    12ec:	fc 81       	ldd	r31, Y+4	; 0x04
    12ee:	82 81       	ldd	r24, Z+2	; 0x02
    12f0:	93 81       	ldd	r25, Z+3	; 0x03
    12f2:	9c 83       	std	Y+4, r25	; 0x04
    12f4:	8b 83       	std	Y+3, r24	; 0x03
    12f6:	eb 81       	ldd	r30, Y+3	; 0x03
    12f8:	fc 81       	ldd	r31, Y+4	; 0x04
    12fa:	02 80       	ldd	r0, Z+2	; 0x02
    12fc:	f3 81       	ldd	r31, Z+3	; 0x03
    12fe:	e0 2d       	mov	r30, r0
    1300:	20 81       	ld	r18, Z
    1302:	31 81       	ldd	r19, Z+1	; 0x01
    1304:	89 81       	ldd	r24, Y+1	; 0x01
    1306:	9a 81       	ldd	r25, Y+2	; 0x02
    1308:	82 17       	cp	r24, r18
    130a:	93 07       	cpc	r25, r19
    130c:	70 f7       	brcc	.-36     	; 0x12ea <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    130e:	eb 81       	ldd	r30, Y+3	; 0x03
    1310:	fc 81       	ldd	r31, Y+4	; 0x04
    1312:	82 81       	ldd	r24, Z+2	; 0x02
    1314:	93 81       	ldd	r25, Z+3	; 0x03
    1316:	ef 81       	ldd	r30, Y+7	; 0x07
    1318:	f8 85       	ldd	r31, Y+8	; 0x08
    131a:	93 83       	std	Z+3, r25	; 0x03
    131c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    131e:	ef 81       	ldd	r30, Y+7	; 0x07
    1320:	f8 85       	ldd	r31, Y+8	; 0x08
    1322:	02 80       	ldd	r0, Z+2	; 0x02
    1324:	f3 81       	ldd	r31, Z+3	; 0x03
    1326:	e0 2d       	mov	r30, r0
    1328:	8f 81       	ldd	r24, Y+7	; 0x07
    132a:	98 85       	ldd	r25, Y+8	; 0x08
    132c:	95 83       	std	Z+5, r25	; 0x05
    132e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1330:	ef 81       	ldd	r30, Y+7	; 0x07
    1332:	f8 85       	ldd	r31, Y+8	; 0x08
    1334:	8b 81       	ldd	r24, Y+3	; 0x03
    1336:	9c 81       	ldd	r25, Y+4	; 0x04
    1338:	95 83       	std	Z+5, r25	; 0x05
    133a:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    133c:	8f 81       	ldd	r24, Y+7	; 0x07
    133e:	98 85       	ldd	r25, Y+8	; 0x08
    1340:	eb 81       	ldd	r30, Y+3	; 0x03
    1342:	fc 81       	ldd	r31, Y+4	; 0x04
    1344:	93 83       	std	Z+3, r25	; 0x03
    1346:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1348:	ef 81       	ldd	r30, Y+7	; 0x07
    134a:	f8 85       	ldd	r31, Y+8	; 0x08
    134c:	8d 81       	ldd	r24, Y+5	; 0x05
    134e:	9e 81       	ldd	r25, Y+6	; 0x06
    1350:	91 87       	std	Z+9, r25	; 0x09
    1352:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1354:	ed 81       	ldd	r30, Y+5	; 0x05
    1356:	fe 81       	ldd	r31, Y+6	; 0x06
    1358:	80 81       	ld	r24, Z
    135a:	8f 5f       	subi	r24, 0xFF	; 255
    135c:	ed 81       	ldd	r30, Y+5	; 0x05
    135e:	fe 81       	ldd	r31, Y+6	; 0x06
    1360:	80 83       	st	Z, r24
}
    1362:	28 96       	adiw	r28, 0x08	; 8
    1364:	0f b6       	in	r0, 0x3f	; 63
    1366:	f8 94       	cli
    1368:	de bf       	out	0x3e, r29	; 62
    136a:	0f be       	out	0x3f, r0	; 63
    136c:	cd bf       	out	0x3d, r28	; 61
    136e:	cf 91       	pop	r28
    1370:	df 91       	pop	r29
    1372:	08 95       	ret

00001374 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1374:	df 93       	push	r29
    1376:	cf 93       	push	r28
    1378:	00 d0       	rcall	.+0      	; 0x137a <vListRemove+0x6>
    137a:	00 d0       	rcall	.+0      	; 0x137c <vListRemove+0x8>
    137c:	cd b7       	in	r28, 0x3d	; 61
    137e:	de b7       	in	r29, 0x3e	; 62
    1380:	9c 83       	std	Y+4, r25	; 0x04
    1382:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1384:	eb 81       	ldd	r30, Y+3	; 0x03
    1386:	fc 81       	ldd	r31, Y+4	; 0x04
    1388:	a2 81       	ldd	r26, Z+2	; 0x02
    138a:	b3 81       	ldd	r27, Z+3	; 0x03
    138c:	eb 81       	ldd	r30, Y+3	; 0x03
    138e:	fc 81       	ldd	r31, Y+4	; 0x04
    1390:	84 81       	ldd	r24, Z+4	; 0x04
    1392:	95 81       	ldd	r25, Z+5	; 0x05
    1394:	15 96       	adiw	r26, 0x05	; 5
    1396:	9c 93       	st	X, r25
    1398:	8e 93       	st	-X, r24
    139a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    139c:	eb 81       	ldd	r30, Y+3	; 0x03
    139e:	fc 81       	ldd	r31, Y+4	; 0x04
    13a0:	a4 81       	ldd	r26, Z+4	; 0x04
    13a2:	b5 81       	ldd	r27, Z+5	; 0x05
    13a4:	eb 81       	ldd	r30, Y+3	; 0x03
    13a6:	fc 81       	ldd	r31, Y+4	; 0x04
    13a8:	82 81       	ldd	r24, Z+2	; 0x02
    13aa:	93 81       	ldd	r25, Z+3	; 0x03
    13ac:	13 96       	adiw	r26, 0x03	; 3
    13ae:	9c 93       	st	X, r25
    13b0:	8e 93       	st	-X, r24
    13b2:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    13b4:	eb 81       	ldd	r30, Y+3	; 0x03
    13b6:	fc 81       	ldd	r31, Y+4	; 0x04
    13b8:	80 85       	ldd	r24, Z+8	; 0x08
    13ba:	91 85       	ldd	r25, Z+9	; 0x09
    13bc:	9a 83       	std	Y+2, r25	; 0x02
    13be:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    13c0:	e9 81       	ldd	r30, Y+1	; 0x01
    13c2:	fa 81       	ldd	r31, Y+2	; 0x02
    13c4:	21 81       	ldd	r18, Z+1	; 0x01
    13c6:	32 81       	ldd	r19, Z+2	; 0x02
    13c8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ca:	9c 81       	ldd	r25, Y+4	; 0x04
    13cc:	28 17       	cp	r18, r24
    13ce:	39 07       	cpc	r19, r25
    13d0:	41 f4       	brne	.+16     	; 0x13e2 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    13d2:	eb 81       	ldd	r30, Y+3	; 0x03
    13d4:	fc 81       	ldd	r31, Y+4	; 0x04
    13d6:	84 81       	ldd	r24, Z+4	; 0x04
    13d8:	95 81       	ldd	r25, Z+5	; 0x05
    13da:	e9 81       	ldd	r30, Y+1	; 0x01
    13dc:	fa 81       	ldd	r31, Y+2	; 0x02
    13de:	92 83       	std	Z+2, r25	; 0x02
    13e0:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    13e2:	eb 81       	ldd	r30, Y+3	; 0x03
    13e4:	fc 81       	ldd	r31, Y+4	; 0x04
    13e6:	11 86       	std	Z+9, r1	; 0x09
    13e8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    13ea:	e9 81       	ldd	r30, Y+1	; 0x01
    13ec:	fa 81       	ldd	r31, Y+2	; 0x02
    13ee:	80 81       	ld	r24, Z
    13f0:	81 50       	subi	r24, 0x01	; 1
    13f2:	e9 81       	ldd	r30, Y+1	; 0x01
    13f4:	fa 81       	ldd	r31, Y+2	; 0x02
    13f6:	80 83       	st	Z, r24
}
    13f8:	0f 90       	pop	r0
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	cf 91       	pop	r28
    1402:	df 91       	pop	r29
    1404:	08 95       	ret

00001406 <led1>:
#include "task.h"
#include "GIE_int.h"
#include "EXTI_int.h"

void led1(void *ptr)
{
    1406:	df 93       	push	r29
    1408:	cf 93       	push	r28
    140a:	00 d0       	rcall	.+0      	; 0x140c <led1+0x6>
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	9a 83       	std	Y+2, r25	; 0x02
    1412:	89 83       	std	Y+1, r24	; 0x01
	static u8 i=0;
	while(1)
	{
		if(i==0)
    1414:	80 91 02 03 	lds	r24, 0x0302
    1418:	88 23       	and	r24, r24
    141a:	49 f4       	brne	.+18     	; 0x142e <led1+0x28>
		{
			DIO_SetPinValue(0,PIN_0,HIGH);
    141c:	80 e0       	ldi	r24, 0x00	; 0
    141e:	60 e0       	ldi	r22, 0x00	; 0
    1420:	41 e0       	ldi	r20, 0x01	; 1
    1422:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=1;
    1426:	81 e0       	ldi	r24, 0x01	; 1
    1428:	80 93 02 03 	sts	0x0302, r24
    142c:	07 c0       	rjmp	.+14     	; 0x143c <led1+0x36>
		}
		else
		{
			DIO_SetPinValue(0,PIN_0,LOW);
    142e:	80 e0       	ldi	r24, 0x00	; 0
    1430:	60 e0       	ldi	r22, 0x00	; 0
    1432:	40 e0       	ldi	r20, 0x00	; 0
    1434:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=0;
    1438:	10 92 02 03 	sts	0x0302, r1
		}
		vTaskDelay(1000);
    143c:	88 ee       	ldi	r24, 0xE8	; 232
    143e:	93 e0       	ldi	r25, 0x03	; 3
    1440:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <vTaskDelay>
    1444:	e7 cf       	rjmp	.-50     	; 0x1414 <led1+0xe>

00001446 <led2>:
	}
}

void led2(void *ptr)
{
    1446:	df 93       	push	r29
    1448:	cf 93       	push	r28
    144a:	00 d0       	rcall	.+0      	; 0x144c <led2+0x6>
    144c:	cd b7       	in	r28, 0x3d	; 61
    144e:	de b7       	in	r29, 0x3e	; 62
    1450:	9a 83       	std	Y+2, r25	; 0x02
    1452:	89 83       	std	Y+1, r24	; 0x01
	static u8 i=0;
	while(1)
	{
		if(i==0)
    1454:	80 91 03 03 	lds	r24, 0x0303
    1458:	88 23       	and	r24, r24
    145a:	49 f4       	brne	.+18     	; 0x146e <led2+0x28>
		{
			DIO_SetPinValue(0,PIN_1,HIGH);
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	61 e0       	ldi	r22, 0x01	; 1
    1460:	41 e0       	ldi	r20, 0x01	; 1
    1462:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=1;
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	80 93 03 03 	sts	0x0303, r24
    146c:	07 c0       	rjmp	.+14     	; 0x147c <led2+0x36>
		}
		else
		{
			DIO_SetPinValue(0,PIN_1,LOW);
    146e:	80 e0       	ldi	r24, 0x00	; 0
    1470:	61 e0       	ldi	r22, 0x01	; 1
    1472:	40 e0       	ldi	r20, 0x00	; 0
    1474:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=0;
    1478:	10 92 03 03 	sts	0x0303, r1
		}
		vTaskDelay(3000);
    147c:	88 eb       	ldi	r24, 0xB8	; 184
    147e:	9b e0       	ldi	r25, 0x0B	; 11
    1480:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <vTaskDelay>
    1484:	e7 cf       	rjmp	.-50     	; 0x1454 <led2+0xe>

00001486 <led3>:
	}
}

void led3(void *ptr)
{
    1486:	df 93       	push	r29
    1488:	cf 93       	push	r28
    148a:	00 d0       	rcall	.+0      	; 0x148c <led3+0x6>
    148c:	cd b7       	in	r28, 0x3d	; 61
    148e:	de b7       	in	r29, 0x3e	; 62
    1490:	9a 83       	std	Y+2, r25	; 0x02
    1492:	89 83       	std	Y+1, r24	; 0x01
	static u8 i=0;
	while(1)
	{
		if(i==0)
    1494:	80 91 04 03 	lds	r24, 0x0304
    1498:	88 23       	and	r24, r24
    149a:	49 f4       	brne	.+18     	; 0x14ae <led3+0x28>
		{
			DIO_SetPinValue(0,PIN_2,HIGH);
    149c:	80 e0       	ldi	r24, 0x00	; 0
    149e:	62 e0       	ldi	r22, 0x02	; 2
    14a0:	41 e0       	ldi	r20, 0x01	; 1
    14a2:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=1;
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	80 93 04 03 	sts	0x0304, r24
    14ac:	07 c0       	rjmp	.+14     	; 0x14bc <led3+0x36>
		}
		else
		{
			DIO_SetPinValue(0,PIN_2,LOW);
    14ae:	80 e0       	ldi	r24, 0x00	; 0
    14b0:	62 e0       	ldi	r22, 0x02	; 2
    14b2:	40 e0       	ldi	r20, 0x00	; 0
    14b4:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
			i=0;
    14b8:	10 92 04 03 	sts	0x0304, r1
		}
		vTaskDelay(5000);
    14bc:	88 e8       	ldi	r24, 0x88	; 136
    14be:	93 e1       	ldi	r25, 0x13	; 19
    14c0:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <vTaskDelay>
    14c4:	e7 cf       	rjmp	.-50     	; 0x1494 <led3+0xe>

000014c6 <main>:
}

void func(void);

void main(void)
{
    14c6:	af 92       	push	r10
    14c8:	bf 92       	push	r11
    14ca:	cf 92       	push	r12
    14cc:	df 92       	push	r13
    14ce:	ef 92       	push	r14
    14d0:	ff 92       	push	r15
    14d2:	0f 93       	push	r16
    14d4:	df 93       	push	r29
    14d6:	cf 93       	push	r28
    14d8:	0f 92       	push	r0
    14da:	cd b7       	in	r28, 0x3d	; 61
    14dc:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPortDirection(0,PortOut);
    14de:	80 e0       	ldi	r24, 0x00	; 0
    14e0:	6f ef       	ldi	r22, 0xFF	; 255
    14e2:	0e 94 2a 03 	call	0x654	; 0x654 <DIO_SetPortDirection>

	xTaskCreate(led1,NULL,configMINIMAL_STACK_SIZE,NULL,0,NULL);
    14e6:	83 e0       	ldi	r24, 0x03	; 3
    14e8:	9a e0       	ldi	r25, 0x0A	; 10
    14ea:	60 e0       	ldi	r22, 0x00	; 0
    14ec:	70 e0       	ldi	r23, 0x00	; 0
    14ee:	44 e6       	ldi	r20, 0x64	; 100
    14f0:	50 e0       	ldi	r21, 0x00	; 0
    14f2:	20 e0       	ldi	r18, 0x00	; 0
    14f4:	30 e0       	ldi	r19, 0x00	; 0
    14f6:	00 e0       	ldi	r16, 0x00	; 0
    14f8:	ee 24       	eor	r14, r14
    14fa:	ff 24       	eor	r15, r15
    14fc:	cc 24       	eor	r12, r12
    14fe:	dd 24       	eor	r13, r13
    1500:	aa 24       	eor	r10, r10
    1502:	bb 24       	eor	r11, r11
    1504:	0e 94 34 12 	call	0x2468	; 0x2468 <xTaskGenericCreate>
	xTaskCreate(led2,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL);
    1508:	83 e2       	ldi	r24, 0x23	; 35
    150a:	9a e0       	ldi	r25, 0x0A	; 10
    150c:	60 e0       	ldi	r22, 0x00	; 0
    150e:	70 e0       	ldi	r23, 0x00	; 0
    1510:	44 e6       	ldi	r20, 0x64	; 100
    1512:	50 e0       	ldi	r21, 0x00	; 0
    1514:	20 e0       	ldi	r18, 0x00	; 0
    1516:	30 e0       	ldi	r19, 0x00	; 0
    1518:	01 e0       	ldi	r16, 0x01	; 1
    151a:	ee 24       	eor	r14, r14
    151c:	ff 24       	eor	r15, r15
    151e:	cc 24       	eor	r12, r12
    1520:	dd 24       	eor	r13, r13
    1522:	aa 24       	eor	r10, r10
    1524:	bb 24       	eor	r11, r11
    1526:	0e 94 34 12 	call	0x2468	; 0x2468 <xTaskGenericCreate>
	xTaskCreate(led3,NULL,configMINIMAL_STACK_SIZE,NULL,2,NULL);
    152a:	83 e4       	ldi	r24, 0x43	; 67
    152c:	9a e0       	ldi	r25, 0x0A	; 10
    152e:	60 e0       	ldi	r22, 0x00	; 0
    1530:	70 e0       	ldi	r23, 0x00	; 0
    1532:	44 e6       	ldi	r20, 0x64	; 100
    1534:	50 e0       	ldi	r21, 0x00	; 0
    1536:	20 e0       	ldi	r18, 0x00	; 0
    1538:	30 e0       	ldi	r19, 0x00	; 0
    153a:	02 e0       	ldi	r16, 0x02	; 2
    153c:	ee 24       	eor	r14, r14
    153e:	ff 24       	eor	r15, r15
    1540:	cc 24       	eor	r12, r12
    1542:	dd 24       	eor	r13, r13
    1544:	aa 24       	eor	r10, r10
    1546:	bb 24       	eor	r11, r11
    1548:	0e 94 34 12 	call	0x2468	; 0x2468 <xTaskGenericCreate>

	vTaskStartScheduler();
    154c:	0e 94 2d 14 	call	0x285a	; 0x285a <vTaskStartScheduler>

	GIE_Enable();
    1550:	0e 94 68 05 	call	0xad0	; 0xad0 <GIE_Enable>

	EXTI_Enable(EXTI0);
    1554:	80 e0       	ldi	r24, 0x00	; 0
    1556:	0e 94 3d 04 	call	0x87a	; 0x87a <EXTI_Enable>
	EXTI_SetTriggerMode();
    155a:	0e 94 ac 03 	call	0x758	; 0x758 <EXTI_SetTriggerMode>

	DIO_SetPinDirection(PORTD,PIN_2,Input);
    155e:	e2 e3       	ldi	r30, 0x32	; 50
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	80 81       	ld	r24, Z
    1564:	62 e0       	ldi	r22, 0x02	; 2
    1566:	40 e0       	ldi	r20, 0x00	; 0
    1568:	0e 94 49 00 	call	0x92	; 0x92 <DIO_SetPinDirection>
	DIO_SetPinValue(PORTD,PIN_2,HIGH);
    156c:	e2 e3       	ldi	r30, 0x32	; 50
    156e:	f0 e0       	ldi	r31, 0x00	; 0
    1570:	80 81       	ld	r24, Z
    1572:	62 e0       	ldi	r22, 0x02	; 2
    1574:	41 e0       	ldi	r20, 0x01	; 1
    1576:	0e 94 3b 01 	call	0x276	; 0x276 <DIO_SetPinValue>
	u8 button = 0;
    157a:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		button = DIO_GetPinValue(PORTD,PIN_2);
    157c:	e2 e3       	ldi	r30, 0x32	; 50
    157e:	f0 e0       	ldi	r31, 0x00	; 0
    1580:	80 81       	ld	r24, Z
    1582:	62 e0       	ldi	r22, 0x02	; 2
    1584:	0e 94 2d 02 	call	0x45a	; 0x45a <DIO_GetPinValue>
    1588:	89 83       	std	Y+1, r24	; 0x01
		if (button ==0)
    158a:	89 81       	ldd	r24, Y+1	; 0x01
    158c:	88 23       	and	r24, r24
    158e:	b1 f7       	brne	.-20     	; 0x157c <main+0xb6>
		{
			EXTI0_CallBackFunc(func);
    1590:	8d ec       	ldi	r24, 0xCD	; 205
    1592:	9a e0       	ldi	r25, 0x0A	; 10
    1594:	0e 94 ab 04 	call	0x956	; 0x956 <EXTI0_CallBackFunc>
    1598:	f1 cf       	rjmp	.-30     	; 0x157c <main+0xb6>

0000159a <func>:
		}
	}
}

void func(void)
{
    159a:	df 93       	push	r29
    159c:	cf 93       	push	r28
    159e:	0f 92       	push	r0
    15a0:	cd b7       	in	r28, 0x3d	; 61
    15a2:	de b7       	in	r29, 0x3e	; 62
	u8 button = 0;
    15a4:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		button = DIO_GetPinValue(PORTD,PIN_2);
    15a6:	e2 e3       	ldi	r30, 0x32	; 50
    15a8:	f0 e0       	ldi	r31, 0x00	; 0
    15aa:	80 81       	ld	r24, Z
    15ac:	62 e0       	ldi	r22, 0x02	; 2
    15ae:	0e 94 2d 02 	call	0x45a	; 0x45a <DIO_GetPinValue>
    15b2:	89 83       	std	Y+1, r24	; 0x01
		if (button ==1)
    15b4:	89 81       	ldd	r24, Y+1	; 0x01
    15b6:	81 30       	cpi	r24, 0x01	; 1
    15b8:	b1 f7       	brne	.-20     	; 0x15a6 <func+0xc>
		{
			break;
		}
	}
}
    15ba:	0f 90       	pop	r0
    15bc:	cf 91       	pop	r28
    15be:	df 91       	pop	r29
    15c0:	08 95       	ret

000015c2 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    15c2:	df 93       	push	r29
    15c4:	cf 93       	push	r28
    15c6:	cd b7       	in	r28, 0x3d	; 61
    15c8:	de b7       	in	r29, 0x3e	; 62
    15ca:	28 97       	sbiw	r28, 0x08	; 8
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	de bf       	out	0x3e, r29	; 62
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	cd bf       	out	0x3d, r28	; 61
    15d6:	9c 83       	std	Y+4, r25	; 0x04
    15d8:	8b 83       	std	Y+3, r24	; 0x03
    15da:	7e 83       	std	Y+6, r23	; 0x06
    15dc:	6d 83       	std	Y+5, r22	; 0x05
    15de:	58 87       	std	Y+8, r21	; 0x08
    15e0:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    15e2:	eb 81       	ldd	r30, Y+3	; 0x03
    15e4:	fc 81       	ldd	r31, Y+4	; 0x04
    15e6:	81 e1       	ldi	r24, 0x11	; 17
    15e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ea:	8b 81       	ldd	r24, Y+3	; 0x03
    15ec:	9c 81       	ldd	r25, Y+4	; 0x04
    15ee:	01 97       	sbiw	r24, 0x01	; 1
    15f0:	9c 83       	std	Y+4, r25	; 0x04
    15f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    15f4:	eb 81       	ldd	r30, Y+3	; 0x03
    15f6:	fc 81       	ldd	r31, Y+4	; 0x04
    15f8:	82 e2       	ldi	r24, 0x22	; 34
    15fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    15fc:	8b 81       	ldd	r24, Y+3	; 0x03
    15fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1600:	01 97       	sbiw	r24, 0x01	; 1
    1602:	9c 83       	std	Y+4, r25	; 0x04
    1604:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1606:	eb 81       	ldd	r30, Y+3	; 0x03
    1608:	fc 81       	ldd	r31, Y+4	; 0x04
    160a:	83 e3       	ldi	r24, 0x33	; 51
    160c:	80 83       	st	Z, r24
	pxTopOfStack--;
    160e:	8b 81       	ldd	r24, Y+3	; 0x03
    1610:	9c 81       	ldd	r25, Y+4	; 0x04
    1612:	01 97       	sbiw	r24, 0x01	; 1
    1614:	9c 83       	std	Y+4, r25	; 0x04
    1616:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1618:	8d 81       	ldd	r24, Y+5	; 0x05
    161a:	9e 81       	ldd	r25, Y+6	; 0x06
    161c:	9a 83       	std	Y+2, r25	; 0x02
    161e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1620:	89 81       	ldd	r24, Y+1	; 0x01
    1622:	eb 81       	ldd	r30, Y+3	; 0x03
    1624:	fc 81       	ldd	r31, Y+4	; 0x04
    1626:	80 83       	st	Z, r24
	pxTopOfStack--;
    1628:	8b 81       	ldd	r24, Y+3	; 0x03
    162a:	9c 81       	ldd	r25, Y+4	; 0x04
    162c:	01 97       	sbiw	r24, 0x01	; 1
    162e:	9c 83       	std	Y+4, r25	; 0x04
    1630:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1632:	89 81       	ldd	r24, Y+1	; 0x01
    1634:	9a 81       	ldd	r25, Y+2	; 0x02
    1636:	89 2f       	mov	r24, r25
    1638:	99 27       	eor	r25, r25
    163a:	9a 83       	std	Y+2, r25	; 0x02
    163c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    163e:	89 81       	ldd	r24, Y+1	; 0x01
    1640:	eb 81       	ldd	r30, Y+3	; 0x03
    1642:	fc 81       	ldd	r31, Y+4	; 0x04
    1644:	80 83       	st	Z, r24
	pxTopOfStack--;
    1646:	8b 81       	ldd	r24, Y+3	; 0x03
    1648:	9c 81       	ldd	r25, Y+4	; 0x04
    164a:	01 97       	sbiw	r24, 0x01	; 1
    164c:	9c 83       	std	Y+4, r25	; 0x04
    164e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1650:	eb 81       	ldd	r30, Y+3	; 0x03
    1652:	fc 81       	ldd	r31, Y+4	; 0x04
    1654:	10 82       	st	Z, r1
	pxTopOfStack--;
    1656:	8b 81       	ldd	r24, Y+3	; 0x03
    1658:	9c 81       	ldd	r25, Y+4	; 0x04
    165a:	01 97       	sbiw	r24, 0x01	; 1
    165c:	9c 83       	std	Y+4, r25	; 0x04
    165e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1660:	eb 81       	ldd	r30, Y+3	; 0x03
    1662:	fc 81       	ldd	r31, Y+4	; 0x04
    1664:	80 e8       	ldi	r24, 0x80	; 128
    1666:	80 83       	st	Z, r24
	pxTopOfStack--;
    1668:	8b 81       	ldd	r24, Y+3	; 0x03
    166a:	9c 81       	ldd	r25, Y+4	; 0x04
    166c:	01 97       	sbiw	r24, 0x01	; 1
    166e:	9c 83       	std	Y+4, r25	; 0x04
    1670:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1672:	eb 81       	ldd	r30, Y+3	; 0x03
    1674:	fc 81       	ldd	r31, Y+4	; 0x04
    1676:	10 82       	st	Z, r1
	pxTopOfStack--;
    1678:	8b 81       	ldd	r24, Y+3	; 0x03
    167a:	9c 81       	ldd	r25, Y+4	; 0x04
    167c:	01 97       	sbiw	r24, 0x01	; 1
    167e:	9c 83       	std	Y+4, r25	; 0x04
    1680:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1682:	eb 81       	ldd	r30, Y+3	; 0x03
    1684:	fc 81       	ldd	r31, Y+4	; 0x04
    1686:	82 e0       	ldi	r24, 0x02	; 2
    1688:	80 83       	st	Z, r24
	pxTopOfStack--;
    168a:	8b 81       	ldd	r24, Y+3	; 0x03
    168c:	9c 81       	ldd	r25, Y+4	; 0x04
    168e:	01 97       	sbiw	r24, 0x01	; 1
    1690:	9c 83       	std	Y+4, r25	; 0x04
    1692:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1694:	eb 81       	ldd	r30, Y+3	; 0x03
    1696:	fc 81       	ldd	r31, Y+4	; 0x04
    1698:	83 e0       	ldi	r24, 0x03	; 3
    169a:	80 83       	st	Z, r24
	pxTopOfStack--;
    169c:	8b 81       	ldd	r24, Y+3	; 0x03
    169e:	9c 81       	ldd	r25, Y+4	; 0x04
    16a0:	01 97       	sbiw	r24, 0x01	; 1
    16a2:	9c 83       	std	Y+4, r25	; 0x04
    16a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    16a6:	eb 81       	ldd	r30, Y+3	; 0x03
    16a8:	fc 81       	ldd	r31, Y+4	; 0x04
    16aa:	84 e0       	ldi	r24, 0x04	; 4
    16ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    16ae:	8b 81       	ldd	r24, Y+3	; 0x03
    16b0:	9c 81       	ldd	r25, Y+4	; 0x04
    16b2:	01 97       	sbiw	r24, 0x01	; 1
    16b4:	9c 83       	std	Y+4, r25	; 0x04
    16b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    16b8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ba:	fc 81       	ldd	r31, Y+4	; 0x04
    16bc:	85 e0       	ldi	r24, 0x05	; 5
    16be:	80 83       	st	Z, r24
	pxTopOfStack--;
    16c0:	8b 81       	ldd	r24, Y+3	; 0x03
    16c2:	9c 81       	ldd	r25, Y+4	; 0x04
    16c4:	01 97       	sbiw	r24, 0x01	; 1
    16c6:	9c 83       	std	Y+4, r25	; 0x04
    16c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    16ca:	eb 81       	ldd	r30, Y+3	; 0x03
    16cc:	fc 81       	ldd	r31, Y+4	; 0x04
    16ce:	86 e0       	ldi	r24, 0x06	; 6
    16d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d2:	8b 81       	ldd	r24, Y+3	; 0x03
    16d4:	9c 81       	ldd	r25, Y+4	; 0x04
    16d6:	01 97       	sbiw	r24, 0x01	; 1
    16d8:	9c 83       	std	Y+4, r25	; 0x04
    16da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    16dc:	eb 81       	ldd	r30, Y+3	; 0x03
    16de:	fc 81       	ldd	r31, Y+4	; 0x04
    16e0:	87 e0       	ldi	r24, 0x07	; 7
    16e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16e4:	8b 81       	ldd	r24, Y+3	; 0x03
    16e6:	9c 81       	ldd	r25, Y+4	; 0x04
    16e8:	01 97       	sbiw	r24, 0x01	; 1
    16ea:	9c 83       	std	Y+4, r25	; 0x04
    16ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    16ee:	eb 81       	ldd	r30, Y+3	; 0x03
    16f0:	fc 81       	ldd	r31, Y+4	; 0x04
    16f2:	88 e0       	ldi	r24, 0x08	; 8
    16f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    16f6:	8b 81       	ldd	r24, Y+3	; 0x03
    16f8:	9c 81       	ldd	r25, Y+4	; 0x04
    16fa:	01 97       	sbiw	r24, 0x01	; 1
    16fc:	9c 83       	std	Y+4, r25	; 0x04
    16fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1700:	eb 81       	ldd	r30, Y+3	; 0x03
    1702:	fc 81       	ldd	r31, Y+4	; 0x04
    1704:	89 e0       	ldi	r24, 0x09	; 9
    1706:	80 83       	st	Z, r24
	pxTopOfStack--;
    1708:	8b 81       	ldd	r24, Y+3	; 0x03
    170a:	9c 81       	ldd	r25, Y+4	; 0x04
    170c:	01 97       	sbiw	r24, 0x01	; 1
    170e:	9c 83       	std	Y+4, r25	; 0x04
    1710:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1712:	eb 81       	ldd	r30, Y+3	; 0x03
    1714:	fc 81       	ldd	r31, Y+4	; 0x04
    1716:	80 e1       	ldi	r24, 0x10	; 16
    1718:	80 83       	st	Z, r24
	pxTopOfStack--;
    171a:	8b 81       	ldd	r24, Y+3	; 0x03
    171c:	9c 81       	ldd	r25, Y+4	; 0x04
    171e:	01 97       	sbiw	r24, 0x01	; 1
    1720:	9c 83       	std	Y+4, r25	; 0x04
    1722:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1724:	eb 81       	ldd	r30, Y+3	; 0x03
    1726:	fc 81       	ldd	r31, Y+4	; 0x04
    1728:	81 e1       	ldi	r24, 0x11	; 17
    172a:	80 83       	st	Z, r24
	pxTopOfStack--;
    172c:	8b 81       	ldd	r24, Y+3	; 0x03
    172e:	9c 81       	ldd	r25, Y+4	; 0x04
    1730:	01 97       	sbiw	r24, 0x01	; 1
    1732:	9c 83       	std	Y+4, r25	; 0x04
    1734:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1736:	eb 81       	ldd	r30, Y+3	; 0x03
    1738:	fc 81       	ldd	r31, Y+4	; 0x04
    173a:	82 e1       	ldi	r24, 0x12	; 18
    173c:	80 83       	st	Z, r24
	pxTopOfStack--;
    173e:	8b 81       	ldd	r24, Y+3	; 0x03
    1740:	9c 81       	ldd	r25, Y+4	; 0x04
    1742:	01 97       	sbiw	r24, 0x01	; 1
    1744:	9c 83       	std	Y+4, r25	; 0x04
    1746:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1748:	eb 81       	ldd	r30, Y+3	; 0x03
    174a:	fc 81       	ldd	r31, Y+4	; 0x04
    174c:	83 e1       	ldi	r24, 0x13	; 19
    174e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1750:	8b 81       	ldd	r24, Y+3	; 0x03
    1752:	9c 81       	ldd	r25, Y+4	; 0x04
    1754:	01 97       	sbiw	r24, 0x01	; 1
    1756:	9c 83       	std	Y+4, r25	; 0x04
    1758:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    175a:	eb 81       	ldd	r30, Y+3	; 0x03
    175c:	fc 81       	ldd	r31, Y+4	; 0x04
    175e:	84 e1       	ldi	r24, 0x14	; 20
    1760:	80 83       	st	Z, r24
	pxTopOfStack--;
    1762:	8b 81       	ldd	r24, Y+3	; 0x03
    1764:	9c 81       	ldd	r25, Y+4	; 0x04
    1766:	01 97       	sbiw	r24, 0x01	; 1
    1768:	9c 83       	std	Y+4, r25	; 0x04
    176a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    176c:	eb 81       	ldd	r30, Y+3	; 0x03
    176e:	fc 81       	ldd	r31, Y+4	; 0x04
    1770:	85 e1       	ldi	r24, 0x15	; 21
    1772:	80 83       	st	Z, r24
	pxTopOfStack--;
    1774:	8b 81       	ldd	r24, Y+3	; 0x03
    1776:	9c 81       	ldd	r25, Y+4	; 0x04
    1778:	01 97       	sbiw	r24, 0x01	; 1
    177a:	9c 83       	std	Y+4, r25	; 0x04
    177c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    177e:	eb 81       	ldd	r30, Y+3	; 0x03
    1780:	fc 81       	ldd	r31, Y+4	; 0x04
    1782:	86 e1       	ldi	r24, 0x16	; 22
    1784:	80 83       	st	Z, r24
	pxTopOfStack--;
    1786:	8b 81       	ldd	r24, Y+3	; 0x03
    1788:	9c 81       	ldd	r25, Y+4	; 0x04
    178a:	01 97       	sbiw	r24, 0x01	; 1
    178c:	9c 83       	std	Y+4, r25	; 0x04
    178e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1790:	eb 81       	ldd	r30, Y+3	; 0x03
    1792:	fc 81       	ldd	r31, Y+4	; 0x04
    1794:	87 e1       	ldi	r24, 0x17	; 23
    1796:	80 83       	st	Z, r24
	pxTopOfStack--;
    1798:	8b 81       	ldd	r24, Y+3	; 0x03
    179a:	9c 81       	ldd	r25, Y+4	; 0x04
    179c:	01 97       	sbiw	r24, 0x01	; 1
    179e:	9c 83       	std	Y+4, r25	; 0x04
    17a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    17a2:	eb 81       	ldd	r30, Y+3	; 0x03
    17a4:	fc 81       	ldd	r31, Y+4	; 0x04
    17a6:	88 e1       	ldi	r24, 0x18	; 24
    17a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    17aa:	8b 81       	ldd	r24, Y+3	; 0x03
    17ac:	9c 81       	ldd	r25, Y+4	; 0x04
    17ae:	01 97       	sbiw	r24, 0x01	; 1
    17b0:	9c 83       	std	Y+4, r25	; 0x04
    17b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    17b4:	eb 81       	ldd	r30, Y+3	; 0x03
    17b6:	fc 81       	ldd	r31, Y+4	; 0x04
    17b8:	89 e1       	ldi	r24, 0x19	; 25
    17ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    17bc:	8b 81       	ldd	r24, Y+3	; 0x03
    17be:	9c 81       	ldd	r25, Y+4	; 0x04
    17c0:	01 97       	sbiw	r24, 0x01	; 1
    17c2:	9c 83       	std	Y+4, r25	; 0x04
    17c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    17c6:	eb 81       	ldd	r30, Y+3	; 0x03
    17c8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ca:	80 e2       	ldi	r24, 0x20	; 32
    17cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ce:	8b 81       	ldd	r24, Y+3	; 0x03
    17d0:	9c 81       	ldd	r25, Y+4	; 0x04
    17d2:	01 97       	sbiw	r24, 0x01	; 1
    17d4:	9c 83       	std	Y+4, r25	; 0x04
    17d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    17d8:	eb 81       	ldd	r30, Y+3	; 0x03
    17da:	fc 81       	ldd	r31, Y+4	; 0x04
    17dc:	81 e2       	ldi	r24, 0x21	; 33
    17de:	80 83       	st	Z, r24
	pxTopOfStack--;
    17e0:	8b 81       	ldd	r24, Y+3	; 0x03
    17e2:	9c 81       	ldd	r25, Y+4	; 0x04
    17e4:	01 97       	sbiw	r24, 0x01	; 1
    17e6:	9c 83       	std	Y+4, r25	; 0x04
    17e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    17ea:	eb 81       	ldd	r30, Y+3	; 0x03
    17ec:	fc 81       	ldd	r31, Y+4	; 0x04
    17ee:	82 e2       	ldi	r24, 0x22	; 34
    17f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f2:	8b 81       	ldd	r24, Y+3	; 0x03
    17f4:	9c 81       	ldd	r25, Y+4	; 0x04
    17f6:	01 97       	sbiw	r24, 0x01	; 1
    17f8:	9c 83       	std	Y+4, r25	; 0x04
    17fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    17fc:	eb 81       	ldd	r30, Y+3	; 0x03
    17fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1800:	83 e2       	ldi	r24, 0x23	; 35
    1802:	80 83       	st	Z, r24
	pxTopOfStack--;
    1804:	8b 81       	ldd	r24, Y+3	; 0x03
    1806:	9c 81       	ldd	r25, Y+4	; 0x04
    1808:	01 97       	sbiw	r24, 0x01	; 1
    180a:	9c 83       	std	Y+4, r25	; 0x04
    180c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    180e:	8f 81       	ldd	r24, Y+7	; 0x07
    1810:	98 85       	ldd	r25, Y+8	; 0x08
    1812:	9a 83       	std	Y+2, r25	; 0x02
    1814:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1816:	89 81       	ldd	r24, Y+1	; 0x01
    1818:	eb 81       	ldd	r30, Y+3	; 0x03
    181a:	fc 81       	ldd	r31, Y+4	; 0x04
    181c:	80 83       	st	Z, r24
	pxTopOfStack--;
    181e:	8b 81       	ldd	r24, Y+3	; 0x03
    1820:	9c 81       	ldd	r25, Y+4	; 0x04
    1822:	01 97       	sbiw	r24, 0x01	; 1
    1824:	9c 83       	std	Y+4, r25	; 0x04
    1826:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1828:	89 81       	ldd	r24, Y+1	; 0x01
    182a:	9a 81       	ldd	r25, Y+2	; 0x02
    182c:	89 2f       	mov	r24, r25
    182e:	99 27       	eor	r25, r25
    1830:	9a 83       	std	Y+2, r25	; 0x02
    1832:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1834:	89 81       	ldd	r24, Y+1	; 0x01
    1836:	eb 81       	ldd	r30, Y+3	; 0x03
    1838:	fc 81       	ldd	r31, Y+4	; 0x04
    183a:	80 83       	st	Z, r24
	pxTopOfStack--;
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	9c 81       	ldd	r25, Y+4	; 0x04
    1840:	01 97       	sbiw	r24, 0x01	; 1
    1842:	9c 83       	std	Y+4, r25	; 0x04
    1844:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1846:	eb 81       	ldd	r30, Y+3	; 0x03
    1848:	fc 81       	ldd	r31, Y+4	; 0x04
    184a:	86 e2       	ldi	r24, 0x26	; 38
    184c:	80 83       	st	Z, r24
	pxTopOfStack--;
    184e:	8b 81       	ldd	r24, Y+3	; 0x03
    1850:	9c 81       	ldd	r25, Y+4	; 0x04
    1852:	01 97       	sbiw	r24, 0x01	; 1
    1854:	9c 83       	std	Y+4, r25	; 0x04
    1856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1858:	eb 81       	ldd	r30, Y+3	; 0x03
    185a:	fc 81       	ldd	r31, Y+4	; 0x04
    185c:	87 e2       	ldi	r24, 0x27	; 39
    185e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1860:	8b 81       	ldd	r24, Y+3	; 0x03
    1862:	9c 81       	ldd	r25, Y+4	; 0x04
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	9c 83       	std	Y+4, r25	; 0x04
    1868:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    186a:	eb 81       	ldd	r30, Y+3	; 0x03
    186c:	fc 81       	ldd	r31, Y+4	; 0x04
    186e:	88 e2       	ldi	r24, 0x28	; 40
    1870:	80 83       	st	Z, r24
	pxTopOfStack--;
    1872:	8b 81       	ldd	r24, Y+3	; 0x03
    1874:	9c 81       	ldd	r25, Y+4	; 0x04
    1876:	01 97       	sbiw	r24, 0x01	; 1
    1878:	9c 83       	std	Y+4, r25	; 0x04
    187a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    187c:	eb 81       	ldd	r30, Y+3	; 0x03
    187e:	fc 81       	ldd	r31, Y+4	; 0x04
    1880:	89 e2       	ldi	r24, 0x29	; 41
    1882:	80 83       	st	Z, r24
	pxTopOfStack--;
    1884:	8b 81       	ldd	r24, Y+3	; 0x03
    1886:	9c 81       	ldd	r25, Y+4	; 0x04
    1888:	01 97       	sbiw	r24, 0x01	; 1
    188a:	9c 83       	std	Y+4, r25	; 0x04
    188c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    188e:	eb 81       	ldd	r30, Y+3	; 0x03
    1890:	fc 81       	ldd	r31, Y+4	; 0x04
    1892:	80 e3       	ldi	r24, 0x30	; 48
    1894:	80 83       	st	Z, r24
	pxTopOfStack--;
    1896:	8b 81       	ldd	r24, Y+3	; 0x03
    1898:	9c 81       	ldd	r25, Y+4	; 0x04
    189a:	01 97       	sbiw	r24, 0x01	; 1
    189c:	9c 83       	std	Y+4, r25	; 0x04
    189e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    18a0:	eb 81       	ldd	r30, Y+3	; 0x03
    18a2:	fc 81       	ldd	r31, Y+4	; 0x04
    18a4:	81 e3       	ldi	r24, 0x31	; 49
    18a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a8:	8b 81       	ldd	r24, Y+3	; 0x03
    18aa:	9c 81       	ldd	r25, Y+4	; 0x04
    18ac:	01 97       	sbiw	r24, 0x01	; 1
    18ae:	9c 83       	std	Y+4, r25	; 0x04
    18b0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    18b2:	8b 81       	ldd	r24, Y+3	; 0x03
    18b4:	9c 81       	ldd	r25, Y+4	; 0x04
}
    18b6:	28 96       	adiw	r28, 0x08	; 8
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	de bf       	out	0x3e, r29	; 62
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	cd bf       	out	0x3d, r28	; 61
    18c2:	cf 91       	pop	r28
    18c4:	df 91       	pop	r29
    18c6:	08 95       	ret

000018c8 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    18c8:	df 93       	push	r29
    18ca:	cf 93       	push	r28
    18cc:	cd b7       	in	r28, 0x3d	; 61
    18ce:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    18d0:	0e 94 54 0d 	call	0x1aa8	; 0x1aa8 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    18d4:	a0 91 05 03 	lds	r26, 0x0305
    18d8:	b0 91 06 03 	lds	r27, 0x0306
    18dc:	cd 91       	ld	r28, X+
    18de:	cd bf       	out	0x3d, r28	; 61
    18e0:	dd 91       	ld	r29, X+
    18e2:	de bf       	out	0x3e, r29	; 62
    18e4:	ff 91       	pop	r31
    18e6:	ef 91       	pop	r30
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	bf 91       	pop	r27
    18ee:	af 91       	pop	r26
    18f0:	9f 91       	pop	r25
    18f2:	8f 91       	pop	r24
    18f4:	7f 91       	pop	r23
    18f6:	6f 91       	pop	r22
    18f8:	5f 91       	pop	r21
    18fa:	4f 91       	pop	r20
    18fc:	3f 91       	pop	r19
    18fe:	2f 91       	pop	r18
    1900:	1f 91       	pop	r17
    1902:	0f 91       	pop	r16
    1904:	ff 90       	pop	r15
    1906:	ef 90       	pop	r14
    1908:	df 90       	pop	r13
    190a:	cf 90       	pop	r12
    190c:	bf 90       	pop	r11
    190e:	af 90       	pop	r10
    1910:	9f 90       	pop	r9
    1912:	8f 90       	pop	r8
    1914:	7f 90       	pop	r7
    1916:	6f 90       	pop	r6
    1918:	5f 90       	pop	r5
    191a:	4f 90       	pop	r4
    191c:	3f 90       	pop	r3
    191e:	2f 90       	pop	r2
    1920:	1f 90       	pop	r1
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1928:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    192a:	81 e0       	ldi	r24, 0x01	; 1
}
    192c:	cf 91       	pop	r28
    192e:	df 91       	pop	r29
    1930:	08 95       	ret

00001932 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1932:	df 93       	push	r29
    1934:	cf 93       	push	r28
    1936:	cd b7       	in	r28, 0x3d	; 61
    1938:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    193a:	cf 91       	pop	r28
    193c:	df 91       	pop	r29
    193e:	08 95       	ret

00001940 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1940:	0f 92       	push	r0
    1942:	0f b6       	in	r0, 0x3f	; 63
    1944:	f8 94       	cli
    1946:	0f 92       	push	r0
    1948:	1f 92       	push	r1
    194a:	11 24       	eor	r1, r1
    194c:	2f 92       	push	r2
    194e:	3f 92       	push	r3
    1950:	4f 92       	push	r4
    1952:	5f 92       	push	r5
    1954:	6f 92       	push	r6
    1956:	7f 92       	push	r7
    1958:	8f 92       	push	r8
    195a:	9f 92       	push	r9
    195c:	af 92       	push	r10
    195e:	bf 92       	push	r11
    1960:	cf 92       	push	r12
    1962:	df 92       	push	r13
    1964:	ef 92       	push	r14
    1966:	ff 92       	push	r15
    1968:	0f 93       	push	r16
    196a:	1f 93       	push	r17
    196c:	2f 93       	push	r18
    196e:	3f 93       	push	r19
    1970:	4f 93       	push	r20
    1972:	5f 93       	push	r21
    1974:	6f 93       	push	r22
    1976:	7f 93       	push	r23
    1978:	8f 93       	push	r24
    197a:	9f 93       	push	r25
    197c:	af 93       	push	r26
    197e:	bf 93       	push	r27
    1980:	cf 93       	push	r28
    1982:	df 93       	push	r29
    1984:	ef 93       	push	r30
    1986:	ff 93       	push	r31
    1988:	a0 91 05 03 	lds	r26, 0x0305
    198c:	b0 91 06 03 	lds	r27, 0x0306
    1990:	0d b6       	in	r0, 0x3d	; 61
    1992:	0d 92       	st	X+, r0
    1994:	0e b6       	in	r0, 0x3e	; 62
    1996:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1998:	0e 94 10 16 	call	0x2c20	; 0x2c20 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    199c:	a0 91 05 03 	lds	r26, 0x0305
    19a0:	b0 91 06 03 	lds	r27, 0x0306
    19a4:	cd 91       	ld	r28, X+
    19a6:	cd bf       	out	0x3d, r28	; 61
    19a8:	dd 91       	ld	r29, X+
    19aa:	de bf       	out	0x3e, r29	; 62
    19ac:	ff 91       	pop	r31
    19ae:	ef 91       	pop	r30
    19b0:	df 91       	pop	r29
    19b2:	cf 91       	pop	r28
    19b4:	bf 91       	pop	r27
    19b6:	af 91       	pop	r26
    19b8:	9f 91       	pop	r25
    19ba:	8f 91       	pop	r24
    19bc:	7f 91       	pop	r23
    19be:	6f 91       	pop	r22
    19c0:	5f 91       	pop	r21
    19c2:	4f 91       	pop	r20
    19c4:	3f 91       	pop	r19
    19c6:	2f 91       	pop	r18
    19c8:	1f 91       	pop	r17
    19ca:	0f 91       	pop	r16
    19cc:	ff 90       	pop	r15
    19ce:	ef 90       	pop	r14
    19d0:	df 90       	pop	r13
    19d2:	cf 90       	pop	r12
    19d4:	bf 90       	pop	r11
    19d6:	af 90       	pop	r10
    19d8:	9f 90       	pop	r9
    19da:	8f 90       	pop	r8
    19dc:	7f 90       	pop	r7
    19de:	6f 90       	pop	r6
    19e0:	5f 90       	pop	r5
    19e2:	4f 90       	pop	r4
    19e4:	3f 90       	pop	r3
    19e6:	2f 90       	pop	r2
    19e8:	1f 90       	pop	r1
    19ea:	0f 90       	pop	r0
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	0f 90       	pop	r0

	asm volatile ( "ret" );
    19f0:	08 95       	ret

000019f2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    19f2:	0f 92       	push	r0
    19f4:	0f b6       	in	r0, 0x3f	; 63
    19f6:	f8 94       	cli
    19f8:	0f 92       	push	r0
    19fa:	1f 92       	push	r1
    19fc:	11 24       	eor	r1, r1
    19fe:	2f 92       	push	r2
    1a00:	3f 92       	push	r3
    1a02:	4f 92       	push	r4
    1a04:	5f 92       	push	r5
    1a06:	6f 92       	push	r6
    1a08:	7f 92       	push	r7
    1a0a:	8f 92       	push	r8
    1a0c:	9f 92       	push	r9
    1a0e:	af 92       	push	r10
    1a10:	bf 92       	push	r11
    1a12:	cf 92       	push	r12
    1a14:	df 92       	push	r13
    1a16:	ef 92       	push	r14
    1a18:	ff 92       	push	r15
    1a1a:	0f 93       	push	r16
    1a1c:	1f 93       	push	r17
    1a1e:	2f 93       	push	r18
    1a20:	3f 93       	push	r19
    1a22:	4f 93       	push	r20
    1a24:	5f 93       	push	r21
    1a26:	6f 93       	push	r22
    1a28:	7f 93       	push	r23
    1a2a:	8f 93       	push	r24
    1a2c:	9f 93       	push	r25
    1a2e:	af 93       	push	r26
    1a30:	bf 93       	push	r27
    1a32:	cf 93       	push	r28
    1a34:	df 93       	push	r29
    1a36:	ef 93       	push	r30
    1a38:	ff 93       	push	r31
    1a3a:	a0 91 05 03 	lds	r26, 0x0305
    1a3e:	b0 91 06 03 	lds	r27, 0x0306
    1a42:	0d b6       	in	r0, 0x3d	; 61
    1a44:	0d 92       	st	X+, r0
    1a46:	0e b6       	in	r0, 0x3e	; 62
    1a48:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a4a:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vTaskIncrementTick>
	vTaskSwitchContext();
    1a4e:	0e 94 10 16 	call	0x2c20	; 0x2c20 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a52:	a0 91 05 03 	lds	r26, 0x0305
    1a56:	b0 91 06 03 	lds	r27, 0x0306
    1a5a:	cd 91       	ld	r28, X+
    1a5c:	cd bf       	out	0x3d, r28	; 61
    1a5e:	dd 91       	ld	r29, X+
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	ff 91       	pop	r31
    1a64:	ef 91       	pop	r30
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	bf 91       	pop	r27
    1a6c:	af 91       	pop	r26
    1a6e:	9f 91       	pop	r25
    1a70:	8f 91       	pop	r24
    1a72:	7f 91       	pop	r23
    1a74:	6f 91       	pop	r22
    1a76:	5f 91       	pop	r21
    1a78:	4f 91       	pop	r20
    1a7a:	3f 91       	pop	r19
    1a7c:	2f 91       	pop	r18
    1a7e:	1f 91       	pop	r17
    1a80:	0f 91       	pop	r16
    1a82:	ff 90       	pop	r15
    1a84:	ef 90       	pop	r14
    1a86:	df 90       	pop	r13
    1a88:	cf 90       	pop	r12
    1a8a:	bf 90       	pop	r11
    1a8c:	af 90       	pop	r10
    1a8e:	9f 90       	pop	r9
    1a90:	8f 90       	pop	r8
    1a92:	7f 90       	pop	r7
    1a94:	6f 90       	pop	r6
    1a96:	5f 90       	pop	r5
    1a98:	4f 90       	pop	r4
    1a9a:	3f 90       	pop	r3
    1a9c:	2f 90       	pop	r2
    1a9e:	1f 90       	pop	r1
    1aa0:	0f 90       	pop	r0
    1aa2:	0f be       	out	0x3f, r0	; 63
    1aa4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1aa6:	08 95       	ret

00001aa8 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1aa8:	df 93       	push	r29
    1aaa:	cf 93       	push	r28
    1aac:	00 d0       	rcall	.+0      	; 0x1aae <prvSetupTimerInterrupt+0x6>
    1aae:	00 d0       	rcall	.+0      	; 0x1ab0 <prvSetupTimerInterrupt+0x8>
    1ab0:	00 d0       	rcall	.+0      	; 0x1ab2 <prvSetupTimerInterrupt+0xa>
    1ab2:	cd b7       	in	r28, 0x3d	; 61
    1ab4:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1ab6:	80 e4       	ldi	r24, 0x40	; 64
    1ab8:	9f e1       	ldi	r25, 0x1F	; 31
    1aba:	a0 e0       	ldi	r26, 0x00	; 0
    1abc:	b0 e0       	ldi	r27, 0x00	; 0
    1abe:	8b 83       	std	Y+3, r24	; 0x03
    1ac0:	9c 83       	std	Y+4, r25	; 0x04
    1ac2:	ad 83       	std	Y+5, r26	; 0x05
    1ac4:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1ac6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aca:	ad 81       	ldd	r26, Y+5	; 0x05
    1acc:	be 81       	ldd	r27, Y+6	; 0x06
    1ace:	68 94       	set
    1ad0:	15 f8       	bld	r1, 5
    1ad2:	b6 95       	lsr	r27
    1ad4:	a7 95       	ror	r26
    1ad6:	97 95       	ror	r25
    1ad8:	87 95       	ror	r24
    1ada:	16 94       	lsr	r1
    1adc:	d1 f7       	brne	.-12     	; 0x1ad2 <prvSetupTimerInterrupt+0x2a>
    1ade:	8b 83       	std	Y+3, r24	; 0x03
    1ae0:	9c 83       	std	Y+4, r25	; 0x04
    1ae2:	ad 83       	std	Y+5, r26	; 0x05
    1ae4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aea:	ad 81       	ldd	r26, Y+5	; 0x05
    1aec:	be 81       	ldd	r27, Y+6	; 0x06
    1aee:	01 97       	sbiw	r24, 0x01	; 1
    1af0:	a1 09       	sbc	r26, r1
    1af2:	b1 09       	sbc	r27, r1
    1af4:	8b 83       	std	Y+3, r24	; 0x03
    1af6:	9c 83       	std	Y+4, r25	; 0x04
    1af8:	ad 83       	std	Y+5, r26	; 0x05
    1afa:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1afc:	8b 81       	ldd	r24, Y+3	; 0x03
    1afe:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1b00:	8b 81       	ldd	r24, Y+3	; 0x03
    1b02:	9c 81       	ldd	r25, Y+4	; 0x04
    1b04:	ad 81       	ldd	r26, Y+5	; 0x05
    1b06:	be 81       	ldd	r27, Y+6	; 0x06
    1b08:	89 2f       	mov	r24, r25
    1b0a:	9a 2f       	mov	r25, r26
    1b0c:	ab 2f       	mov	r26, r27
    1b0e:	bb 27       	eor	r27, r27
    1b10:	8b 83       	std	Y+3, r24	; 0x03
    1b12:	9c 83       	std	Y+4, r25	; 0x04
    1b14:	ad 83       	std	Y+5, r26	; 0x05
    1b16:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1b18:	8b 81       	ldd	r24, Y+3	; 0x03
    1b1a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1b1c:	eb e4       	ldi	r30, 0x4B	; 75
    1b1e:	f0 e0       	ldi	r31, 0x00	; 0
    1b20:	8a 81       	ldd	r24, Y+2	; 0x02
    1b22:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1b24:	ea e4       	ldi	r30, 0x4A	; 74
    1b26:	f0 e0       	ldi	r31, 0x00	; 0
    1b28:	89 81       	ldd	r24, Y+1	; 0x01
    1b2a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1b2c:	8b e0       	ldi	r24, 0x0B	; 11
    1b2e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1b30:	ee e4       	ldi	r30, 0x4E	; 78
    1b32:	f0 e0       	ldi	r31, 0x00	; 0
    1b34:	89 81       	ldd	r24, Y+1	; 0x01
    1b36:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1b38:	e9 e5       	ldi	r30, 0x59	; 89
    1b3a:	f0 e0       	ldi	r31, 0x00	; 0
    1b3c:	80 81       	ld	r24, Z
    1b3e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1b40:	89 81       	ldd	r24, Y+1	; 0x01
    1b42:	80 61       	ori	r24, 0x10	; 16
    1b44:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1b46:	e9 e5       	ldi	r30, 0x59	; 89
    1b48:	f0 e0       	ldi	r31, 0x00	; 0
    1b4a:	89 81       	ldd	r24, Y+1	; 0x01
    1b4c:	80 83       	st	Z, r24
}
    1b4e:	26 96       	adiw	r28, 0x06	; 6
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	de bf       	out	0x3e, r29	; 62
    1b56:	0f be       	out	0x3f, r0	; 63
    1b58:	cd bf       	out	0x3d, r28	; 61
    1b5a:	cf 91       	pop	r28
    1b5c:	df 91       	pop	r29
    1b5e:	08 95       	ret

00001b60 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1b60:	0e 94 f9 0c 	call	0x19f2	; 0x19f2 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1b64:	18 95       	reti

00001b66 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1b66:	df 93       	push	r29
    1b68:	cf 93       	push	r28
    1b6a:	cd b7       	in	r28, 0x3d	; 61
    1b6c:	de b7       	in	r29, 0x3e	; 62
    1b6e:	28 97       	sbiw	r28, 0x08	; 8
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	f8 94       	cli
    1b74:	de bf       	out	0x3e, r29	; 62
    1b76:	0f be       	out	0x3f, r0	; 63
    1b78:	cd bf       	out	0x3d, r28	; 61
    1b7a:	8f 83       	std	Y+7, r24	; 0x07
    1b7c:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1b7e:	1a 82       	std	Y+2, r1	; 0x02
    1b80:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1b82:	8f 81       	ldd	r24, Y+7	; 0x07
    1b84:	88 23       	and	r24, r24
    1b86:	09 f4       	brne	.+2      	; 0x1b8a <xQueueCreate+0x24>
    1b88:	8c c0       	rjmp	.+280    	; 0x1ca2 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1b8a:	8f e1       	ldi	r24, 0x1F	; 31
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    1b92:	9e 83       	std	Y+6, r25	; 0x06
    1b94:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1b96:	8d 81       	ldd	r24, Y+5	; 0x05
    1b98:	9e 81       	ldd	r25, Y+6	; 0x06
    1b9a:	00 97       	sbiw	r24, 0x00	; 0
    1b9c:	09 f4       	brne	.+2      	; 0x1ba0 <xQueueCreate+0x3a>
    1b9e:	81 c0       	rjmp	.+258    	; 0x1ca2 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1ba0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ba2:	28 2f       	mov	r18, r24
    1ba4:	30 e0       	ldi	r19, 0x00	; 0
    1ba6:	88 85       	ldd	r24, Y+8	; 0x08
    1ba8:	88 2f       	mov	r24, r24
    1baa:	90 e0       	ldi	r25, 0x00	; 0
    1bac:	ac 01       	movw	r20, r24
    1bae:	24 9f       	mul	r18, r20
    1bb0:	c0 01       	movw	r24, r0
    1bb2:	25 9f       	mul	r18, r21
    1bb4:	90 0d       	add	r25, r0
    1bb6:	34 9f       	mul	r19, r20
    1bb8:	90 0d       	add	r25, r0
    1bba:	11 24       	eor	r1, r1
    1bbc:	01 96       	adiw	r24, 0x01	; 1
    1bbe:	9c 83       	std	Y+4, r25	; 0x04
    1bc0:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc4:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc6:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    1bca:	ed 81       	ldd	r30, Y+5	; 0x05
    1bcc:	fe 81       	ldd	r31, Y+6	; 0x06
    1bce:	91 83       	std	Z+1, r25	; 0x01
    1bd0:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1bd2:	ed 81       	ldd	r30, Y+5	; 0x05
    1bd4:	fe 81       	ldd	r31, Y+6	; 0x06
    1bd6:	80 81       	ld	r24, Z
    1bd8:	91 81       	ldd	r25, Z+1	; 0x01
    1bda:	00 97       	sbiw	r24, 0x00	; 0
    1bdc:	09 f4       	brne	.+2      	; 0x1be0 <xQueueCreate+0x7a>
    1bde:	5d c0       	rjmp	.+186    	; 0x1c9a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1be0:	ed 81       	ldd	r30, Y+5	; 0x05
    1be2:	fe 81       	ldd	r31, Y+6	; 0x06
    1be4:	40 81       	ld	r20, Z
    1be6:	51 81       	ldd	r21, Z+1	; 0x01
    1be8:	8f 81       	ldd	r24, Y+7	; 0x07
    1bea:	28 2f       	mov	r18, r24
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	88 85       	ldd	r24, Y+8	; 0x08
    1bf0:	88 2f       	mov	r24, r24
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	bc 01       	movw	r22, r24
    1bf6:	26 9f       	mul	r18, r22
    1bf8:	c0 01       	movw	r24, r0
    1bfa:	27 9f       	mul	r18, r23
    1bfc:	90 0d       	add	r25, r0
    1bfe:	36 9f       	mul	r19, r22
    1c00:	90 0d       	add	r25, r0
    1c02:	11 24       	eor	r1, r1
    1c04:	84 0f       	add	r24, r20
    1c06:	95 1f       	adc	r25, r21
    1c08:	ed 81       	ldd	r30, Y+5	; 0x05
    1c0a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c0c:	93 83       	std	Z+3, r25	; 0x03
    1c0e:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1c10:	ed 81       	ldd	r30, Y+5	; 0x05
    1c12:	fe 81       	ldd	r31, Y+6	; 0x06
    1c14:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1c16:	ed 81       	ldd	r30, Y+5	; 0x05
    1c18:	fe 81       	ldd	r31, Y+6	; 0x06
    1c1a:	80 81       	ld	r24, Z
    1c1c:	91 81       	ldd	r25, Z+1	; 0x01
    1c1e:	ed 81       	ldd	r30, Y+5	; 0x05
    1c20:	fe 81       	ldd	r31, Y+6	; 0x06
    1c22:	95 83       	std	Z+5, r25	; 0x05
    1c24:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1c26:	ed 81       	ldd	r30, Y+5	; 0x05
    1c28:	fe 81       	ldd	r31, Y+6	; 0x06
    1c2a:	40 81       	ld	r20, Z
    1c2c:	51 81       	ldd	r21, Z+1	; 0x01
    1c2e:	8f 81       	ldd	r24, Y+7	; 0x07
    1c30:	88 2f       	mov	r24, r24
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	9c 01       	movw	r18, r24
    1c36:	21 50       	subi	r18, 0x01	; 1
    1c38:	30 40       	sbci	r19, 0x00	; 0
    1c3a:	88 85       	ldd	r24, Y+8	; 0x08
    1c3c:	88 2f       	mov	r24, r24
    1c3e:	90 e0       	ldi	r25, 0x00	; 0
    1c40:	bc 01       	movw	r22, r24
    1c42:	26 9f       	mul	r18, r22
    1c44:	c0 01       	movw	r24, r0
    1c46:	27 9f       	mul	r18, r23
    1c48:	90 0d       	add	r25, r0
    1c4a:	36 9f       	mul	r19, r22
    1c4c:	90 0d       	add	r25, r0
    1c4e:	11 24       	eor	r1, r1
    1c50:	84 0f       	add	r24, r20
    1c52:	95 1f       	adc	r25, r21
    1c54:	ed 81       	ldd	r30, Y+5	; 0x05
    1c56:	fe 81       	ldd	r31, Y+6	; 0x06
    1c58:	97 83       	std	Z+7, r25	; 0x07
    1c5a:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1c5c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c5e:	fe 81       	ldd	r31, Y+6	; 0x06
    1c60:	8f 81       	ldd	r24, Y+7	; 0x07
    1c62:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1c64:	ed 81       	ldd	r30, Y+5	; 0x05
    1c66:	fe 81       	ldd	r31, Y+6	; 0x06
    1c68:	88 85       	ldd	r24, Y+8	; 0x08
    1c6a:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1c6c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c6e:	fe 81       	ldd	r31, Y+6	; 0x06
    1c70:	8f ef       	ldi	r24, 0xFF	; 255
    1c72:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1c74:	ed 81       	ldd	r30, Y+5	; 0x05
    1c76:	fe 81       	ldd	r31, Y+6	; 0x06
    1c78:	8f ef       	ldi	r24, 0xFF	; 255
    1c7a:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1c7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c80:	08 96       	adiw	r24, 0x08	; 8
    1c82:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1c86:	8d 81       	ldd	r24, Y+5	; 0x05
    1c88:	9e 81       	ldd	r25, Y+6	; 0x06
    1c8a:	41 96       	adiw	r24, 0x11	; 17
    1c8c:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1c90:	8d 81       	ldd	r24, Y+5	; 0x05
    1c92:	9e 81       	ldd	r25, Y+6	; 0x06
    1c94:	9a 83       	std	Y+2, r25	; 0x02
    1c96:	89 83       	std	Y+1, r24	; 0x01
    1c98:	04 c0       	rjmp	.+8      	; 0x1ca2 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1c9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9e:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1ca2:	89 81       	ldd	r24, Y+1	; 0x01
    1ca4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1ca6:	28 96       	adiw	r28, 0x08	; 8
    1ca8:	0f b6       	in	r0, 0x3f	; 63
    1caa:	f8 94       	cli
    1cac:	de bf       	out	0x3e, r29	; 62
    1cae:	0f be       	out	0x3f, r0	; 63
    1cb0:	cd bf       	out	0x3d, r28	; 61
    1cb2:	cf 91       	pop	r28
    1cb4:	df 91       	pop	r29
    1cb6:	08 95       	ret

00001cb8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1cb8:	df 93       	push	r29
    1cba:	cf 93       	push	r28
    1cbc:	cd b7       	in	r28, 0x3d	; 61
    1cbe:	de b7       	in	r29, 0x3e	; 62
    1cc0:	2c 97       	sbiw	r28, 0x0c	; 12
    1cc2:	0f b6       	in	r0, 0x3f	; 63
    1cc4:	f8 94       	cli
    1cc6:	de bf       	out	0x3e, r29	; 62
    1cc8:	0f be       	out	0x3f, r0	; 63
    1cca:	cd bf       	out	0x3d, r28	; 61
    1ccc:	9e 83       	std	Y+6, r25	; 0x06
    1cce:	8d 83       	std	Y+5, r24	; 0x05
    1cd0:	78 87       	std	Y+8, r23	; 0x08
    1cd2:	6f 83       	std	Y+7, r22	; 0x07
    1cd4:	5a 87       	std	Y+10, r21	; 0x0a
    1cd6:	49 87       	std	Y+9, r20	; 0x09
    1cd8:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1cda:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1cdc:	0f b6       	in	r0, 0x3f	; 63
    1cde:	f8 94       	cli
    1ce0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1ce2:	ed 81       	ldd	r30, Y+5	; 0x05
    1ce4:	fe 81       	ldd	r31, Y+6	; 0x06
    1ce6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ce8:	ed 81       	ldd	r30, Y+5	; 0x05
    1cea:	fe 81       	ldd	r31, Y+6	; 0x06
    1cec:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cee:	98 17       	cp	r25, r24
    1cf0:	d8 f4       	brcc	.+54     	; 0x1d28 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1cf2:	8d 81       	ldd	r24, Y+5	; 0x05
    1cf4:	9e 81       	ldd	r25, Y+6	; 0x06
    1cf6:	2f 81       	ldd	r18, Y+7	; 0x07
    1cf8:	38 85       	ldd	r19, Y+8	; 0x08
    1cfa:	b9 01       	movw	r22, r18
    1cfc:	4b 85       	ldd	r20, Y+11	; 0x0b
    1cfe:	0e 94 97 10 	call	0x212e	; 0x212e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d02:	ed 81       	ldd	r30, Y+5	; 0x05
    1d04:	fe 81       	ldd	r31, Y+6	; 0x06
    1d06:	81 89       	ldd	r24, Z+17	; 0x11
    1d08:	88 23       	and	r24, r24
    1d0a:	49 f0       	breq	.+18     	; 0x1d1e <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1d0c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d0e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d10:	41 96       	adiw	r24, 0x11	; 17
    1d12:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <xTaskRemoveFromEventList>
    1d16:	81 30       	cpi	r24, 0x01	; 1
    1d18:	11 f4       	brne	.+4      	; 0x1d1e <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1d1a:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1d1e:	0f 90       	pop	r0
    1d20:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1d22:	81 e0       	ldi	r24, 0x01	; 1
    1d24:	8c 87       	std	Y+12, r24	; 0x0c
    1d26:	5c c0       	rjmp	.+184    	; 0x1de0 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1d28:	89 85       	ldd	r24, Y+9	; 0x09
    1d2a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d2c:	00 97       	sbiw	r24, 0x00	; 0
    1d2e:	21 f4       	brne	.+8      	; 0x1d38 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d30:	0f 90       	pop	r0
    1d32:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1d34:	1c 86       	std	Y+12, r1	; 0x0c
    1d36:	54 c0       	rjmp	.+168    	; 0x1de0 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1d38:	89 81       	ldd	r24, Y+1	; 0x01
    1d3a:	88 23       	and	r24, r24
    1d3c:	31 f4       	brne	.+12     	; 0x1d4a <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d3e:	ce 01       	movw	r24, r28
    1d40:	02 96       	adiw	r24, 0x02	; 2
    1d42:	0e 94 14 17 	call	0x2e28	; 0x2e28 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1d46:	81 e0       	ldi	r24, 0x01	; 1
    1d48:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1d4a:	0f 90       	pop	r0
    1d4c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d4e:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d52:	0f b6       	in	r0, 0x3f	; 63
    1d54:	f8 94       	cli
    1d56:	0f 92       	push	r0
    1d58:	ed 81       	ldd	r30, Y+5	; 0x05
    1d5a:	fe 81       	ldd	r31, Y+6	; 0x06
    1d5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d60:	19 f4       	brne	.+6      	; 0x1d68 <xQueueGenericSend+0xb0>
    1d62:	ed 81       	ldd	r30, Y+5	; 0x05
    1d64:	fe 81       	ldd	r31, Y+6	; 0x06
    1d66:	15 8e       	std	Z+29, r1	; 0x1d
    1d68:	ed 81       	ldd	r30, Y+5	; 0x05
    1d6a:	fe 81       	ldd	r31, Y+6	; 0x06
    1d6c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d6e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d70:	19 f4       	brne	.+6      	; 0x1d78 <xQueueGenericSend+0xc0>
    1d72:	ed 81       	ldd	r30, Y+5	; 0x05
    1d74:	fe 81       	ldd	r31, Y+6	; 0x06
    1d76:	16 8e       	std	Z+30, r1	; 0x1e
    1d78:	0f 90       	pop	r0
    1d7a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d7c:	ce 01       	movw	r24, r28
    1d7e:	02 96       	adiw	r24, 0x02	; 2
    1d80:	9e 01       	movw	r18, r28
    1d82:	27 5f       	subi	r18, 0xF7	; 247
    1d84:	3f 4f       	sbci	r19, 0xFF	; 255
    1d86:	b9 01       	movw	r22, r18
    1d88:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <xTaskCheckForTimeOut>
    1d8c:	88 23       	and	r24, r24
    1d8e:	09 f5       	brne	.+66     	; 0x1dd2 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d90:	8d 81       	ldd	r24, Y+5	; 0x05
    1d92:	9e 81       	ldd	r25, Y+6	; 0x06
    1d94:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <prvIsQueueFull>
    1d98:	88 23       	and	r24, r24
    1d9a:	a1 f0       	breq	.+40     	; 0x1dc4 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d9e:	9e 81       	ldd	r25, Y+6	; 0x06
    1da0:	08 96       	adiw	r24, 0x08	; 8
    1da2:	29 85       	ldd	r18, Y+9	; 0x09
    1da4:	3a 85       	ldd	r19, Y+10	; 0x0a
    1da6:	b9 01       	movw	r22, r18
    1da8:	0e 94 76 16 	call	0x2cec	; 0x2cec <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1dac:	8d 81       	ldd	r24, Y+5	; 0x05
    1dae:	9e 81       	ldd	r25, Y+6	; 0x06
    1db0:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1db4:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
    1db8:	88 23       	and	r24, r24
    1dba:	09 f0       	breq	.+2      	; 0x1dbe <xQueueGenericSend+0x106>
    1dbc:	8f cf       	rjmp	.-226    	; 0x1cdc <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1dbe:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
    1dc2:	8c cf       	rjmp	.-232    	; 0x1cdc <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1dc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc6:	9e 81       	ldd	r25, Y+6	; 0x06
    1dc8:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1dcc:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
    1dd0:	85 cf       	rjmp	.-246    	; 0x1cdc <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1dd2:	8d 81       	ldd	r24, Y+5	; 0x05
    1dd4:	9e 81       	ldd	r25, Y+6	; 0x06
    1dd6:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1dda:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1dde:	1c 86       	std	Y+12, r1	; 0x0c
    1de0:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1de2:	2c 96       	adiw	r28, 0x0c	; 12
    1de4:	0f b6       	in	r0, 0x3f	; 63
    1de6:	f8 94       	cli
    1de8:	de bf       	out	0x3e, r29	; 62
    1dea:	0f be       	out	0x3f, r0	; 63
    1dec:	cd bf       	out	0x3d, r28	; 61
    1dee:	cf 91       	pop	r28
    1df0:	df 91       	pop	r29
    1df2:	08 95       	ret

00001df4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1df4:	df 93       	push	r29
    1df6:	cf 93       	push	r28
    1df8:	cd b7       	in	r28, 0x3d	; 61
    1dfa:	de b7       	in	r29, 0x3e	; 62
    1dfc:	29 97       	sbiw	r28, 0x09	; 9
    1dfe:	0f b6       	in	r0, 0x3f	; 63
    1e00:	f8 94       	cli
    1e02:	de bf       	out	0x3e, r29	; 62
    1e04:	0f be       	out	0x3f, r0	; 63
    1e06:	cd bf       	out	0x3d, r28	; 61
    1e08:	9c 83       	std	Y+4, r25	; 0x04
    1e0a:	8b 83       	std	Y+3, r24	; 0x03
    1e0c:	7e 83       	std	Y+6, r23	; 0x06
    1e0e:	6d 83       	std	Y+5, r22	; 0x05
    1e10:	58 87       	std	Y+8, r21	; 0x08
    1e12:	4f 83       	std	Y+7, r20	; 0x07
    1e14:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e16:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e18:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e20:	fc 81       	ldd	r31, Y+4	; 0x04
    1e22:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e24:	98 17       	cp	r25, r24
    1e26:	40 f5       	brcc	.+80     	; 0x1e78 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e28:	8b 81       	ldd	r24, Y+3	; 0x03
    1e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2c:	2d 81       	ldd	r18, Y+5	; 0x05
    1e2e:	3e 81       	ldd	r19, Y+6	; 0x06
    1e30:	b9 01       	movw	r22, r18
    1e32:	49 85       	ldd	r20, Y+9	; 0x09
    1e34:	0e 94 97 10 	call	0x212e	; 0x212e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e38:	eb 81       	ldd	r30, Y+3	; 0x03
    1e3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e40:	89 f4       	brne	.+34     	; 0x1e64 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e42:	eb 81       	ldd	r30, Y+3	; 0x03
    1e44:	fc 81       	ldd	r31, Y+4	; 0x04
    1e46:	81 89       	ldd	r24, Z+17	; 0x11
    1e48:	88 23       	and	r24, r24
    1e4a:	99 f0       	breq	.+38     	; 0x1e72 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e50:	41 96       	adiw	r24, 0x11	; 17
    1e52:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <xTaskRemoveFromEventList>
    1e56:	88 23       	and	r24, r24
    1e58:	61 f0       	breq	.+24     	; 0x1e72 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1e5a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e5c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e5e:	81 e0       	ldi	r24, 0x01	; 1
    1e60:	80 83       	st	Z, r24
    1e62:	07 c0       	rjmp	.+14     	; 0x1e72 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e64:	eb 81       	ldd	r30, Y+3	; 0x03
    1e66:	fc 81       	ldd	r31, Y+4	; 0x04
    1e68:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e6a:	8f 5f       	subi	r24, 0xFF	; 255
    1e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e70:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	8a 83       	std	Y+2, r24	; 0x02
    1e76:	01 c0       	rjmp	.+2      	; 0x1e7a <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e78:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e7a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1e7c:	29 96       	adiw	r28, 0x09	; 9
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	de bf       	out	0x3e, r29	; 62
    1e84:	0f be       	out	0x3f, r0	; 63
    1e86:	cd bf       	out	0x3d, r28	; 61
    1e88:	cf 91       	pop	r28
    1e8a:	df 91       	pop	r29
    1e8c:	08 95       	ret

00001e8e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1e8e:	df 93       	push	r29
    1e90:	cf 93       	push	r28
    1e92:	cd b7       	in	r28, 0x3d	; 61
    1e94:	de b7       	in	r29, 0x3e	; 62
    1e96:	2e 97       	sbiw	r28, 0x0e	; 14
    1e98:	0f b6       	in	r0, 0x3f	; 63
    1e9a:	f8 94       	cli
    1e9c:	de bf       	out	0x3e, r29	; 62
    1e9e:	0f be       	out	0x3f, r0	; 63
    1ea0:	cd bf       	out	0x3d, r28	; 61
    1ea2:	98 87       	std	Y+8, r25	; 0x08
    1ea4:	8f 83       	std	Y+7, r24	; 0x07
    1ea6:	7a 87       	std	Y+10, r23	; 0x0a
    1ea8:	69 87       	std	Y+9, r22	; 0x09
    1eaa:	5c 87       	std	Y+12, r21	; 0x0c
    1eac:	4b 87       	std	Y+11, r20	; 0x0b
    1eae:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1eb0:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1eb2:	0f b6       	in	r0, 0x3f	; 63
    1eb4:	f8 94       	cli
    1eb6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1eb8:	ef 81       	ldd	r30, Y+7	; 0x07
    1eba:	f8 85       	ldd	r31, Y+8	; 0x08
    1ebc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ebe:	88 23       	and	r24, r24
    1ec0:	09 f4       	brne	.+2      	; 0x1ec4 <xQueueGenericReceive+0x36>
    1ec2:	3f c0       	rjmp	.+126    	; 0x1f42 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1ec4:	ef 81       	ldd	r30, Y+7	; 0x07
    1ec6:	f8 85       	ldd	r31, Y+8	; 0x08
    1ec8:	86 81       	ldd	r24, Z+6	; 0x06
    1eca:	97 81       	ldd	r25, Z+7	; 0x07
    1ecc:	9a 83       	std	Y+2, r25	; 0x02
    1ece:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ed0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed2:	98 85       	ldd	r25, Y+8	; 0x08
    1ed4:	29 85       	ldd	r18, Y+9	; 0x09
    1ed6:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ed8:	b9 01       	movw	r22, r18
    1eda:	0e 94 2c 11 	call	0x2258	; 0x2258 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1ede:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ee0:	88 23       	and	r24, r24
    1ee2:	b1 f4       	brne	.+44     	; 0x1f10 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1ee4:	ef 81       	ldd	r30, Y+7	; 0x07
    1ee6:	f8 85       	ldd	r31, Y+8	; 0x08
    1ee8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eea:	81 50       	subi	r24, 0x01	; 1
    1eec:	ef 81       	ldd	r30, Y+7	; 0x07
    1eee:	f8 85       	ldd	r31, Y+8	; 0x08
    1ef0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ef2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ef4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ef6:	80 85       	ldd	r24, Z+8	; 0x08
    1ef8:	88 23       	and	r24, r24
    1efa:	f1 f0       	breq	.+60     	; 0x1f38 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1efc:	8f 81       	ldd	r24, Y+7	; 0x07
    1efe:	98 85       	ldd	r25, Y+8	; 0x08
    1f00:	08 96       	adiw	r24, 0x08	; 8
    1f02:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <xTaskRemoveFromEventList>
    1f06:	81 30       	cpi	r24, 0x01	; 1
    1f08:	b9 f4       	brne	.+46     	; 0x1f38 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1f0a:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
    1f0e:	14 c0       	rjmp	.+40     	; 0x1f38 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1f10:	ef 81       	ldd	r30, Y+7	; 0x07
    1f12:	f8 85       	ldd	r31, Y+8	; 0x08
    1f14:	89 81       	ldd	r24, Y+1	; 0x01
    1f16:	9a 81       	ldd	r25, Y+2	; 0x02
    1f18:	97 83       	std	Z+7, r25	; 0x07
    1f1a:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f1c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f1e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f20:	81 89       	ldd	r24, Z+17	; 0x11
    1f22:	88 23       	and	r24, r24
    1f24:	49 f0       	breq	.+18     	; 0x1f38 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f26:	8f 81       	ldd	r24, Y+7	; 0x07
    1f28:	98 85       	ldd	r25, Y+8	; 0x08
    1f2a:	41 96       	adiw	r24, 0x11	; 17
    1f2c:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <xTaskRemoveFromEventList>
    1f30:	88 23       	and	r24, r24
    1f32:	11 f0       	breq	.+4      	; 0x1f38 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1f34:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1f38:	0f 90       	pop	r0
    1f3a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f3c:	81 e0       	ldi	r24, 0x01	; 1
    1f3e:	8e 87       	std	Y+14, r24	; 0x0e
    1f40:	5c c0       	rjmp	.+184    	; 0x1ffa <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1f42:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f44:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f46:	00 97       	sbiw	r24, 0x00	; 0
    1f48:	21 f4       	brne	.+8      	; 0x1f52 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f4a:	0f 90       	pop	r0
    1f4c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f4e:	1e 86       	std	Y+14, r1	; 0x0e
    1f50:	54 c0       	rjmp	.+168    	; 0x1ffa <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f52:	8b 81       	ldd	r24, Y+3	; 0x03
    1f54:	88 23       	and	r24, r24
    1f56:	31 f4       	brne	.+12     	; 0x1f64 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f58:	ce 01       	movw	r24, r28
    1f5a:	04 96       	adiw	r24, 0x04	; 4
    1f5c:	0e 94 14 17 	call	0x2e28	; 0x2e28 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1f64:	0f 90       	pop	r0
    1f66:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f68:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f6c:	0f b6       	in	r0, 0x3f	; 63
    1f6e:	f8 94       	cli
    1f70:	0f 92       	push	r0
    1f72:	ef 81       	ldd	r30, Y+7	; 0x07
    1f74:	f8 85       	ldd	r31, Y+8	; 0x08
    1f76:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f78:	8f 3f       	cpi	r24, 0xFF	; 255
    1f7a:	19 f4       	brne	.+6      	; 0x1f82 <xQueueGenericReceive+0xf4>
    1f7c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f7e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f80:	15 8e       	std	Z+29, r1	; 0x1d
    1f82:	ef 81       	ldd	r30, Y+7	; 0x07
    1f84:	f8 85       	ldd	r31, Y+8	; 0x08
    1f86:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f88:	8f 3f       	cpi	r24, 0xFF	; 255
    1f8a:	19 f4       	brne	.+6      	; 0x1f92 <xQueueGenericReceive+0x104>
    1f8c:	ef 81       	ldd	r30, Y+7	; 0x07
    1f8e:	f8 85       	ldd	r31, Y+8	; 0x08
    1f90:	16 8e       	std	Z+30, r1	; 0x1e
    1f92:	0f 90       	pop	r0
    1f94:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f96:	ce 01       	movw	r24, r28
    1f98:	04 96       	adiw	r24, 0x04	; 4
    1f9a:	9e 01       	movw	r18, r28
    1f9c:	25 5f       	subi	r18, 0xF5	; 245
    1f9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1fa0:	b9 01       	movw	r22, r18
    1fa2:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <xTaskCheckForTimeOut>
    1fa6:	88 23       	and	r24, r24
    1fa8:	09 f5       	brne	.+66     	; 0x1fec <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1faa:	8f 81       	ldd	r24, Y+7	; 0x07
    1fac:	98 85       	ldd	r25, Y+8	; 0x08
    1fae:	0e 94 c8 11 	call	0x2390	; 0x2390 <prvIsQueueEmpty>
    1fb2:	88 23       	and	r24, r24
    1fb4:	a1 f0       	breq	.+40     	; 0x1fde <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fb6:	8f 81       	ldd	r24, Y+7	; 0x07
    1fb8:	98 85       	ldd	r25, Y+8	; 0x08
    1fba:	41 96       	adiw	r24, 0x11	; 17
    1fbc:	2b 85       	ldd	r18, Y+11	; 0x0b
    1fbe:	3c 85       	ldd	r19, Y+12	; 0x0c
    1fc0:	b9 01       	movw	r22, r18
    1fc2:	0e 94 76 16 	call	0x2cec	; 0x2cec <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1fc6:	8f 81       	ldd	r24, Y+7	; 0x07
    1fc8:	98 85       	ldd	r25, Y+8	; 0x08
    1fca:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1fce:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
    1fd2:	88 23       	and	r24, r24
    1fd4:	09 f0       	breq	.+2      	; 0x1fd8 <xQueueGenericReceive+0x14a>
    1fd6:	6d cf       	rjmp	.-294    	; 0x1eb2 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1fd8:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
    1fdc:	6a cf       	rjmp	.-300    	; 0x1eb2 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1fde:	8f 81       	ldd	r24, Y+7	; 0x07
    1fe0:	98 85       	ldd	r25, Y+8	; 0x08
    1fe2:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1fe6:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
    1fea:	63 cf       	rjmp	.-314    	; 0x1eb2 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1fec:	8f 81       	ldd	r24, Y+7	; 0x07
    1fee:	98 85       	ldd	r25, Y+8	; 0x08
    1ff0:	0e 94 74 11 	call	0x22e8	; 0x22e8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ff4:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1ff8:	1e 86       	std	Y+14, r1	; 0x0e
    1ffa:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1ffc:	2e 96       	adiw	r28, 0x0e	; 14
    1ffe:	0f b6       	in	r0, 0x3f	; 63
    2000:	f8 94       	cli
    2002:	de bf       	out	0x3e, r29	; 62
    2004:	0f be       	out	0x3f, r0	; 63
    2006:	cd bf       	out	0x3d, r28	; 61
    2008:	cf 91       	pop	r28
    200a:	df 91       	pop	r29
    200c:	08 95       	ret

0000200e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    200e:	df 93       	push	r29
    2010:	cf 93       	push	r28
    2012:	cd b7       	in	r28, 0x3d	; 61
    2014:	de b7       	in	r29, 0x3e	; 62
    2016:	28 97       	sbiw	r28, 0x08	; 8
    2018:	0f b6       	in	r0, 0x3f	; 63
    201a:	f8 94       	cli
    201c:	de bf       	out	0x3e, r29	; 62
    201e:	0f be       	out	0x3f, r0	; 63
    2020:	cd bf       	out	0x3d, r28	; 61
    2022:	9c 83       	std	Y+4, r25	; 0x04
    2024:	8b 83       	std	Y+3, r24	; 0x03
    2026:	7e 83       	std	Y+6, r23	; 0x06
    2028:	6d 83       	std	Y+5, r22	; 0x05
    202a:	58 87       	std	Y+8, r21	; 0x08
    202c:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    202e:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2030:	eb 81       	ldd	r30, Y+3	; 0x03
    2032:	fc 81       	ldd	r31, Y+4	; 0x04
    2034:	82 8d       	ldd	r24, Z+26	; 0x1a
    2036:	88 23       	and	r24, r24
    2038:	71 f1       	breq	.+92     	; 0x2096 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    203a:	8b 81       	ldd	r24, Y+3	; 0x03
    203c:	9c 81       	ldd	r25, Y+4	; 0x04
    203e:	2d 81       	ldd	r18, Y+5	; 0x05
    2040:	3e 81       	ldd	r19, Y+6	; 0x06
    2042:	b9 01       	movw	r22, r18
    2044:	0e 94 2c 11 	call	0x2258	; 0x2258 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2048:	eb 81       	ldd	r30, Y+3	; 0x03
    204a:	fc 81       	ldd	r31, Y+4	; 0x04
    204c:	82 8d       	ldd	r24, Z+26	; 0x1a
    204e:	81 50       	subi	r24, 0x01	; 1
    2050:	eb 81       	ldd	r30, Y+3	; 0x03
    2052:	fc 81       	ldd	r31, Y+4	; 0x04
    2054:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2056:	eb 81       	ldd	r30, Y+3	; 0x03
    2058:	fc 81       	ldd	r31, Y+4	; 0x04
    205a:	85 8d       	ldd	r24, Z+29	; 0x1d
    205c:	8f 3f       	cpi	r24, 0xFF	; 255
    205e:	89 f4       	brne	.+34     	; 0x2082 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2060:	eb 81       	ldd	r30, Y+3	; 0x03
    2062:	fc 81       	ldd	r31, Y+4	; 0x04
    2064:	80 85       	ldd	r24, Z+8	; 0x08
    2066:	88 23       	and	r24, r24
    2068:	99 f0       	breq	.+38     	; 0x2090 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    206a:	8b 81       	ldd	r24, Y+3	; 0x03
    206c:	9c 81       	ldd	r25, Y+4	; 0x04
    206e:	08 96       	adiw	r24, 0x08	; 8
    2070:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <xTaskRemoveFromEventList>
    2074:	88 23       	and	r24, r24
    2076:	61 f0       	breq	.+24     	; 0x2090 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2078:	ef 81       	ldd	r30, Y+7	; 0x07
    207a:	f8 85       	ldd	r31, Y+8	; 0x08
    207c:	81 e0       	ldi	r24, 0x01	; 1
    207e:	80 83       	st	Z, r24
    2080:	07 c0       	rjmp	.+14     	; 0x2090 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2082:	eb 81       	ldd	r30, Y+3	; 0x03
    2084:	fc 81       	ldd	r31, Y+4	; 0x04
    2086:	85 8d       	ldd	r24, Z+29	; 0x1d
    2088:	8f 5f       	subi	r24, 0xFF	; 255
    208a:	eb 81       	ldd	r30, Y+3	; 0x03
    208c:	fc 81       	ldd	r31, Y+4	; 0x04
    208e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2090:	81 e0       	ldi	r24, 0x01	; 1
    2092:	8a 83       	std	Y+2, r24	; 0x02
    2094:	01 c0       	rjmp	.+2      	; 0x2098 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    2096:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2098:	8a 81       	ldd	r24, Y+2	; 0x02
}
    209a:	28 96       	adiw	r28, 0x08	; 8
    209c:	0f b6       	in	r0, 0x3f	; 63
    209e:	f8 94       	cli
    20a0:	de bf       	out	0x3e, r29	; 62
    20a2:	0f be       	out	0x3f, r0	; 63
    20a4:	cd bf       	out	0x3d, r28	; 61
    20a6:	cf 91       	pop	r28
    20a8:	df 91       	pop	r29
    20aa:	08 95       	ret

000020ac <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    20ac:	df 93       	push	r29
    20ae:	cf 93       	push	r28
    20b0:	00 d0       	rcall	.+0      	; 0x20b2 <uxQueueMessagesWaiting+0x6>
    20b2:	0f 92       	push	r0
    20b4:	cd b7       	in	r28, 0x3d	; 61
    20b6:	de b7       	in	r29, 0x3e	; 62
    20b8:	9b 83       	std	Y+3, r25	; 0x03
    20ba:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    20bc:	0f b6       	in	r0, 0x3f	; 63
    20be:	f8 94       	cli
    20c0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    20c2:	ea 81       	ldd	r30, Y+2	; 0x02
    20c4:	fb 81       	ldd	r31, Y+3	; 0x03
    20c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    20c8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    20ca:	0f 90       	pop	r0
    20cc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    20ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    20d0:	0f 90       	pop	r0
    20d2:	0f 90       	pop	r0
    20d4:	0f 90       	pop	r0
    20d6:	cf 91       	pop	r28
    20d8:	df 91       	pop	r29
    20da:	08 95       	ret

000020dc <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    20dc:	df 93       	push	r29
    20de:	cf 93       	push	r28
    20e0:	00 d0       	rcall	.+0      	; 0x20e2 <uxQueueMessagesWaitingFromISR+0x6>
    20e2:	0f 92       	push	r0
    20e4:	cd b7       	in	r28, 0x3d	; 61
    20e6:	de b7       	in	r29, 0x3e	; 62
    20e8:	9b 83       	std	Y+3, r25	; 0x03
    20ea:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    20ec:	ea 81       	ldd	r30, Y+2	; 0x02
    20ee:	fb 81       	ldd	r31, Y+3	; 0x03
    20f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20f2:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    20f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    20f6:	0f 90       	pop	r0
    20f8:	0f 90       	pop	r0
    20fa:	0f 90       	pop	r0
    20fc:	cf 91       	pop	r28
    20fe:	df 91       	pop	r29
    2100:	08 95       	ret

00002102 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2102:	df 93       	push	r29
    2104:	cf 93       	push	r28
    2106:	00 d0       	rcall	.+0      	; 0x2108 <vQueueDelete+0x6>
    2108:	cd b7       	in	r28, 0x3d	; 61
    210a:	de b7       	in	r29, 0x3e	; 62
    210c:	9a 83       	std	Y+2, r25	; 0x02
    210e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2110:	e9 81       	ldd	r30, Y+1	; 0x01
    2112:	fa 81       	ldd	r31, Y+2	; 0x02
    2114:	80 81       	ld	r24, Z
    2116:	91 81       	ldd	r25, Z+1	; 0x01
    2118:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
	vPortFree( pxQueue );
    211c:	89 81       	ldd	r24, Y+1	; 0x01
    211e:	9a 81       	ldd	r25, Y+2	; 0x02
    2120:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
}
    2124:	0f 90       	pop	r0
    2126:	0f 90       	pop	r0
    2128:	cf 91       	pop	r28
    212a:	df 91       	pop	r29
    212c:	08 95       	ret

0000212e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    212e:	df 93       	push	r29
    2130:	cf 93       	push	r28
    2132:	00 d0       	rcall	.+0      	; 0x2134 <prvCopyDataToQueue+0x6>
    2134:	00 d0       	rcall	.+0      	; 0x2136 <prvCopyDataToQueue+0x8>
    2136:	0f 92       	push	r0
    2138:	cd b7       	in	r28, 0x3d	; 61
    213a:	de b7       	in	r29, 0x3e	; 62
    213c:	9a 83       	std	Y+2, r25	; 0x02
    213e:	89 83       	std	Y+1, r24	; 0x01
    2140:	7c 83       	std	Y+4, r23	; 0x04
    2142:	6b 83       	std	Y+3, r22	; 0x03
    2144:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2146:	e9 81       	ldd	r30, Y+1	; 0x01
    2148:	fa 81       	ldd	r31, Y+2	; 0x02
    214a:	84 8d       	ldd	r24, Z+28	; 0x1c
    214c:	88 23       	and	r24, r24
    214e:	09 f4       	brne	.+2      	; 0x2152 <prvCopyDataToQueue+0x24>
    2150:	74 c0       	rjmp	.+232    	; 0x223a <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2152:	8d 81       	ldd	r24, Y+5	; 0x05
    2154:	88 23       	and	r24, r24
    2156:	99 f5       	brne	.+102    	; 0x21be <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2158:	e9 81       	ldd	r30, Y+1	; 0x01
    215a:	fa 81       	ldd	r31, Y+2	; 0x02
    215c:	64 81       	ldd	r22, Z+4	; 0x04
    215e:	75 81       	ldd	r23, Z+5	; 0x05
    2160:	e9 81       	ldd	r30, Y+1	; 0x01
    2162:	fa 81       	ldd	r31, Y+2	; 0x02
    2164:	84 8d       	ldd	r24, Z+28	; 0x1c
    2166:	48 2f       	mov	r20, r24
    2168:	50 e0       	ldi	r21, 0x00	; 0
    216a:	2b 81       	ldd	r18, Y+3	; 0x03
    216c:	3c 81       	ldd	r19, Y+4	; 0x04
    216e:	cb 01       	movw	r24, r22
    2170:	b9 01       	movw	r22, r18
    2172:	0e 94 1f 19 	call	0x323e	; 0x323e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2176:	e9 81       	ldd	r30, Y+1	; 0x01
    2178:	fa 81       	ldd	r31, Y+2	; 0x02
    217a:	24 81       	ldd	r18, Z+4	; 0x04
    217c:	35 81       	ldd	r19, Z+5	; 0x05
    217e:	e9 81       	ldd	r30, Y+1	; 0x01
    2180:	fa 81       	ldd	r31, Y+2	; 0x02
    2182:	84 8d       	ldd	r24, Z+28	; 0x1c
    2184:	88 2f       	mov	r24, r24
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	82 0f       	add	r24, r18
    218a:	93 1f       	adc	r25, r19
    218c:	e9 81       	ldd	r30, Y+1	; 0x01
    218e:	fa 81       	ldd	r31, Y+2	; 0x02
    2190:	95 83       	std	Z+5, r25	; 0x05
    2192:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2194:	e9 81       	ldd	r30, Y+1	; 0x01
    2196:	fa 81       	ldd	r31, Y+2	; 0x02
    2198:	24 81       	ldd	r18, Z+4	; 0x04
    219a:	35 81       	ldd	r19, Z+5	; 0x05
    219c:	e9 81       	ldd	r30, Y+1	; 0x01
    219e:	fa 81       	ldd	r31, Y+2	; 0x02
    21a0:	82 81       	ldd	r24, Z+2	; 0x02
    21a2:	93 81       	ldd	r25, Z+3	; 0x03
    21a4:	28 17       	cp	r18, r24
    21a6:	39 07       	cpc	r19, r25
    21a8:	08 f4       	brcc	.+2      	; 0x21ac <prvCopyDataToQueue+0x7e>
    21aa:	47 c0       	rjmp	.+142    	; 0x223a <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    21ac:	e9 81       	ldd	r30, Y+1	; 0x01
    21ae:	fa 81       	ldd	r31, Y+2	; 0x02
    21b0:	80 81       	ld	r24, Z
    21b2:	91 81       	ldd	r25, Z+1	; 0x01
    21b4:	e9 81       	ldd	r30, Y+1	; 0x01
    21b6:	fa 81       	ldd	r31, Y+2	; 0x02
    21b8:	95 83       	std	Z+5, r25	; 0x05
    21ba:	84 83       	std	Z+4, r24	; 0x04
    21bc:	3e c0       	rjmp	.+124    	; 0x223a <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    21be:	e9 81       	ldd	r30, Y+1	; 0x01
    21c0:	fa 81       	ldd	r31, Y+2	; 0x02
    21c2:	66 81       	ldd	r22, Z+6	; 0x06
    21c4:	77 81       	ldd	r23, Z+7	; 0x07
    21c6:	e9 81       	ldd	r30, Y+1	; 0x01
    21c8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    21cc:	48 2f       	mov	r20, r24
    21ce:	50 e0       	ldi	r21, 0x00	; 0
    21d0:	2b 81       	ldd	r18, Y+3	; 0x03
    21d2:	3c 81       	ldd	r19, Y+4	; 0x04
    21d4:	cb 01       	movw	r24, r22
    21d6:	b9 01       	movw	r22, r18
    21d8:	0e 94 1f 19 	call	0x323e	; 0x323e <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    21dc:	e9 81       	ldd	r30, Y+1	; 0x01
    21de:	fa 81       	ldd	r31, Y+2	; 0x02
    21e0:	26 81       	ldd	r18, Z+6	; 0x06
    21e2:	37 81       	ldd	r19, Z+7	; 0x07
    21e4:	e9 81       	ldd	r30, Y+1	; 0x01
    21e6:	fa 81       	ldd	r31, Y+2	; 0x02
    21e8:	84 8d       	ldd	r24, Z+28	; 0x1c
    21ea:	88 2f       	mov	r24, r24
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	90 95       	com	r25
    21f0:	81 95       	neg	r24
    21f2:	9f 4f       	sbci	r25, 0xFF	; 255
    21f4:	82 0f       	add	r24, r18
    21f6:	93 1f       	adc	r25, r19
    21f8:	e9 81       	ldd	r30, Y+1	; 0x01
    21fa:	fa 81       	ldd	r31, Y+2	; 0x02
    21fc:	97 83       	std	Z+7, r25	; 0x07
    21fe:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2200:	e9 81       	ldd	r30, Y+1	; 0x01
    2202:	fa 81       	ldd	r31, Y+2	; 0x02
    2204:	26 81       	ldd	r18, Z+6	; 0x06
    2206:	37 81       	ldd	r19, Z+7	; 0x07
    2208:	e9 81       	ldd	r30, Y+1	; 0x01
    220a:	fa 81       	ldd	r31, Y+2	; 0x02
    220c:	80 81       	ld	r24, Z
    220e:	91 81       	ldd	r25, Z+1	; 0x01
    2210:	28 17       	cp	r18, r24
    2212:	39 07       	cpc	r19, r25
    2214:	90 f4       	brcc	.+36     	; 0x223a <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2216:	e9 81       	ldd	r30, Y+1	; 0x01
    2218:	fa 81       	ldd	r31, Y+2	; 0x02
    221a:	22 81       	ldd	r18, Z+2	; 0x02
    221c:	33 81       	ldd	r19, Z+3	; 0x03
    221e:	e9 81       	ldd	r30, Y+1	; 0x01
    2220:	fa 81       	ldd	r31, Y+2	; 0x02
    2222:	84 8d       	ldd	r24, Z+28	; 0x1c
    2224:	88 2f       	mov	r24, r24
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	90 95       	com	r25
    222a:	81 95       	neg	r24
    222c:	9f 4f       	sbci	r25, 0xFF	; 255
    222e:	82 0f       	add	r24, r18
    2230:	93 1f       	adc	r25, r19
    2232:	e9 81       	ldd	r30, Y+1	; 0x01
    2234:	fa 81       	ldd	r31, Y+2	; 0x02
    2236:	97 83       	std	Z+7, r25	; 0x07
    2238:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    223a:	e9 81       	ldd	r30, Y+1	; 0x01
    223c:	fa 81       	ldd	r31, Y+2	; 0x02
    223e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2240:	8f 5f       	subi	r24, 0xFF	; 255
    2242:	e9 81       	ldd	r30, Y+1	; 0x01
    2244:	fa 81       	ldd	r31, Y+2	; 0x02
    2246:	82 8f       	std	Z+26, r24	; 0x1a
}
    2248:	0f 90       	pop	r0
    224a:	0f 90       	pop	r0
    224c:	0f 90       	pop	r0
    224e:	0f 90       	pop	r0
    2250:	0f 90       	pop	r0
    2252:	cf 91       	pop	r28
    2254:	df 91       	pop	r29
    2256:	08 95       	ret

00002258 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2258:	df 93       	push	r29
    225a:	cf 93       	push	r28
    225c:	00 d0       	rcall	.+0      	; 0x225e <prvCopyDataFromQueue+0x6>
    225e:	00 d0       	rcall	.+0      	; 0x2260 <prvCopyDataFromQueue+0x8>
    2260:	cd b7       	in	r28, 0x3d	; 61
    2262:	de b7       	in	r29, 0x3e	; 62
    2264:	9a 83       	std	Y+2, r25	; 0x02
    2266:	89 83       	std	Y+1, r24	; 0x01
    2268:	7c 83       	std	Y+4, r23	; 0x04
    226a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    226c:	e9 81       	ldd	r30, Y+1	; 0x01
    226e:	fa 81       	ldd	r31, Y+2	; 0x02
    2270:	80 81       	ld	r24, Z
    2272:	91 81       	ldd	r25, Z+1	; 0x01
    2274:	00 97       	sbiw	r24, 0x00	; 0
    2276:	89 f1       	breq	.+98     	; 0x22da <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2278:	e9 81       	ldd	r30, Y+1	; 0x01
    227a:	fa 81       	ldd	r31, Y+2	; 0x02
    227c:	26 81       	ldd	r18, Z+6	; 0x06
    227e:	37 81       	ldd	r19, Z+7	; 0x07
    2280:	e9 81       	ldd	r30, Y+1	; 0x01
    2282:	fa 81       	ldd	r31, Y+2	; 0x02
    2284:	84 8d       	ldd	r24, Z+28	; 0x1c
    2286:	88 2f       	mov	r24, r24
    2288:	90 e0       	ldi	r25, 0x00	; 0
    228a:	82 0f       	add	r24, r18
    228c:	93 1f       	adc	r25, r19
    228e:	e9 81       	ldd	r30, Y+1	; 0x01
    2290:	fa 81       	ldd	r31, Y+2	; 0x02
    2292:	97 83       	std	Z+7, r25	; 0x07
    2294:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2296:	e9 81       	ldd	r30, Y+1	; 0x01
    2298:	fa 81       	ldd	r31, Y+2	; 0x02
    229a:	26 81       	ldd	r18, Z+6	; 0x06
    229c:	37 81       	ldd	r19, Z+7	; 0x07
    229e:	e9 81       	ldd	r30, Y+1	; 0x01
    22a0:	fa 81       	ldd	r31, Y+2	; 0x02
    22a2:	82 81       	ldd	r24, Z+2	; 0x02
    22a4:	93 81       	ldd	r25, Z+3	; 0x03
    22a6:	28 17       	cp	r18, r24
    22a8:	39 07       	cpc	r19, r25
    22aa:	40 f0       	brcs	.+16     	; 0x22bc <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    22ac:	e9 81       	ldd	r30, Y+1	; 0x01
    22ae:	fa 81       	ldd	r31, Y+2	; 0x02
    22b0:	80 81       	ld	r24, Z
    22b2:	91 81       	ldd	r25, Z+1	; 0x01
    22b4:	e9 81       	ldd	r30, Y+1	; 0x01
    22b6:	fa 81       	ldd	r31, Y+2	; 0x02
    22b8:	97 83       	std	Z+7, r25	; 0x07
    22ba:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    22bc:	e9 81       	ldd	r30, Y+1	; 0x01
    22be:	fa 81       	ldd	r31, Y+2	; 0x02
    22c0:	46 81       	ldd	r20, Z+6	; 0x06
    22c2:	57 81       	ldd	r21, Z+7	; 0x07
    22c4:	e9 81       	ldd	r30, Y+1	; 0x01
    22c6:	fa 81       	ldd	r31, Y+2	; 0x02
    22c8:	84 8d       	ldd	r24, Z+28	; 0x1c
    22ca:	28 2f       	mov	r18, r24
    22cc:	30 e0       	ldi	r19, 0x00	; 0
    22ce:	8b 81       	ldd	r24, Y+3	; 0x03
    22d0:	9c 81       	ldd	r25, Y+4	; 0x04
    22d2:	ba 01       	movw	r22, r20
    22d4:	a9 01       	movw	r20, r18
    22d6:	0e 94 1f 19 	call	0x323e	; 0x323e <memcpy>
	}
}
    22da:	0f 90       	pop	r0
    22dc:	0f 90       	pop	r0
    22de:	0f 90       	pop	r0
    22e0:	0f 90       	pop	r0
    22e2:	cf 91       	pop	r28
    22e4:	df 91       	pop	r29
    22e6:	08 95       	ret

000022e8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    22e8:	df 93       	push	r29
    22ea:	cf 93       	push	r28
    22ec:	00 d0       	rcall	.+0      	; 0x22ee <prvUnlockQueue+0x6>
    22ee:	cd b7       	in	r28, 0x3d	; 61
    22f0:	de b7       	in	r29, 0x3e	; 62
    22f2:	9a 83       	std	Y+2, r25	; 0x02
    22f4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    22f6:	0f b6       	in	r0, 0x3f	; 63
    22f8:	f8 94       	cli
    22fa:	0f 92       	push	r0
    22fc:	15 c0       	rjmp	.+42     	; 0x2328 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2300:	fa 81       	ldd	r31, Y+2	; 0x02
    2302:	81 89       	ldd	r24, Z+17	; 0x11
    2304:	88 23       	and	r24, r24
    2306:	a9 f0       	breq	.+42     	; 0x2332 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2308:	89 81       	ldd	r24, Y+1	; 0x01
    230a:	9a 81       	ldd	r25, Y+2	; 0x02
    230c:	41 96       	adiw	r24, 0x11	; 17
    230e:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <xTaskRemoveFromEventList>
    2312:	88 23       	and	r24, r24
    2314:	11 f0       	breq	.+4      	; 0x231a <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    2316:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    231a:	e9 81       	ldd	r30, Y+1	; 0x01
    231c:	fa 81       	ldd	r31, Y+2	; 0x02
    231e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2320:	81 50       	subi	r24, 0x01	; 1
    2322:	e9 81       	ldd	r30, Y+1	; 0x01
    2324:	fa 81       	ldd	r31, Y+2	; 0x02
    2326:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2328:	e9 81       	ldd	r30, Y+1	; 0x01
    232a:	fa 81       	ldd	r31, Y+2	; 0x02
    232c:	86 8d       	ldd	r24, Z+30	; 0x1e
    232e:	18 16       	cp	r1, r24
    2330:	34 f3       	brlt	.-52     	; 0x22fe <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2332:	e9 81       	ldd	r30, Y+1	; 0x01
    2334:	fa 81       	ldd	r31, Y+2	; 0x02
    2336:	8f ef       	ldi	r24, 0xFF	; 255
    2338:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    233a:	0f 90       	pop	r0
    233c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	0f 92       	push	r0
    2344:	15 c0       	rjmp	.+42     	; 0x2370 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2346:	e9 81       	ldd	r30, Y+1	; 0x01
    2348:	fa 81       	ldd	r31, Y+2	; 0x02
    234a:	80 85       	ldd	r24, Z+8	; 0x08
    234c:	88 23       	and	r24, r24
    234e:	a9 f0       	breq	.+42     	; 0x237a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2350:	89 81       	ldd	r24, Y+1	; 0x01
    2352:	9a 81       	ldd	r25, Y+2	; 0x02
    2354:	08 96       	adiw	r24, 0x08	; 8
    2356:	0e 94 ac 16 	call	0x2d58	; 0x2d58 <xTaskRemoveFromEventList>
    235a:	88 23       	and	r24, r24
    235c:	11 f0       	breq	.+4      	; 0x2362 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    235e:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2362:	e9 81       	ldd	r30, Y+1	; 0x01
    2364:	fa 81       	ldd	r31, Y+2	; 0x02
    2366:	85 8d       	ldd	r24, Z+29	; 0x1d
    2368:	81 50       	subi	r24, 0x01	; 1
    236a:	e9 81       	ldd	r30, Y+1	; 0x01
    236c:	fa 81       	ldd	r31, Y+2	; 0x02
    236e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2370:	e9 81       	ldd	r30, Y+1	; 0x01
    2372:	fa 81       	ldd	r31, Y+2	; 0x02
    2374:	85 8d       	ldd	r24, Z+29	; 0x1d
    2376:	18 16       	cp	r1, r24
    2378:	34 f3       	brlt	.-52     	; 0x2346 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    237a:	e9 81       	ldd	r30, Y+1	; 0x01
    237c:	fa 81       	ldd	r31, Y+2	; 0x02
    237e:	8f ef       	ldi	r24, 0xFF	; 255
    2380:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2382:	0f 90       	pop	r0
    2384:	0f be       	out	0x3f, r0	; 63
}
    2386:	0f 90       	pop	r0
    2388:	0f 90       	pop	r0
    238a:	cf 91       	pop	r28
    238c:	df 91       	pop	r29
    238e:	08 95       	ret

00002390 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2390:	df 93       	push	r29
    2392:	cf 93       	push	r28
    2394:	00 d0       	rcall	.+0      	; 0x2396 <prvIsQueueEmpty+0x6>
    2396:	0f 92       	push	r0
    2398:	cd b7       	in	r28, 0x3d	; 61
    239a:	de b7       	in	r29, 0x3e	; 62
    239c:	9b 83       	std	Y+3, r25	; 0x03
    239e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    23a0:	0f b6       	in	r0, 0x3f	; 63
    23a2:	f8 94       	cli
    23a4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    23a6:	ea 81       	ldd	r30, Y+2	; 0x02
    23a8:	fb 81       	ldd	r31, Y+3	; 0x03
    23aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    23ac:	19 82       	std	Y+1, r1	; 0x01
    23ae:	88 23       	and	r24, r24
    23b0:	11 f4       	brne	.+4      	; 0x23b6 <prvIsQueueEmpty+0x26>
    23b2:	81 e0       	ldi	r24, 0x01	; 1
    23b4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    23b6:	0f 90       	pop	r0
    23b8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    23bc:	0f 90       	pop	r0
    23be:	0f 90       	pop	r0
    23c0:	0f 90       	pop	r0
    23c2:	cf 91       	pop	r28
    23c4:	df 91       	pop	r29
    23c6:	08 95       	ret

000023c8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    23c8:	df 93       	push	r29
    23ca:	cf 93       	push	r28
    23cc:	00 d0       	rcall	.+0      	; 0x23ce <xQueueIsQueueEmptyFromISR+0x6>
    23ce:	0f 92       	push	r0
    23d0:	cd b7       	in	r28, 0x3d	; 61
    23d2:	de b7       	in	r29, 0x3e	; 62
    23d4:	9b 83       	std	Y+3, r25	; 0x03
    23d6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    23d8:	ea 81       	ldd	r30, Y+2	; 0x02
    23da:	fb 81       	ldd	r31, Y+3	; 0x03
    23dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    23de:	19 82       	std	Y+1, r1	; 0x01
    23e0:	88 23       	and	r24, r24
    23e2:	11 f4       	brne	.+4      	; 0x23e8 <xQueueIsQueueEmptyFromISR+0x20>
    23e4:	81 e0       	ldi	r24, 0x01	; 1
    23e6:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    23e8:	89 81       	ldd	r24, Y+1	; 0x01
}
    23ea:	0f 90       	pop	r0
    23ec:	0f 90       	pop	r0
    23ee:	0f 90       	pop	r0
    23f0:	cf 91       	pop	r28
    23f2:	df 91       	pop	r29
    23f4:	08 95       	ret

000023f6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    23f6:	df 93       	push	r29
    23f8:	cf 93       	push	r28
    23fa:	00 d0       	rcall	.+0      	; 0x23fc <prvIsQueueFull+0x6>
    23fc:	0f 92       	push	r0
    23fe:	cd b7       	in	r28, 0x3d	; 61
    2400:	de b7       	in	r29, 0x3e	; 62
    2402:	9b 83       	std	Y+3, r25	; 0x03
    2404:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2406:	0f b6       	in	r0, 0x3f	; 63
    2408:	f8 94       	cli
    240a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    240c:	ea 81       	ldd	r30, Y+2	; 0x02
    240e:	fb 81       	ldd	r31, Y+3	; 0x03
    2410:	92 8d       	ldd	r25, Z+26	; 0x1a
    2412:	ea 81       	ldd	r30, Y+2	; 0x02
    2414:	fb 81       	ldd	r31, Y+3	; 0x03
    2416:	83 8d       	ldd	r24, Z+27	; 0x1b
    2418:	19 82       	std	Y+1, r1	; 0x01
    241a:	98 17       	cp	r25, r24
    241c:	11 f4       	brne	.+4      	; 0x2422 <prvIsQueueFull+0x2c>
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2422:	0f 90       	pop	r0
    2424:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2426:	89 81       	ldd	r24, Y+1	; 0x01
}
    2428:	0f 90       	pop	r0
    242a:	0f 90       	pop	r0
    242c:	0f 90       	pop	r0
    242e:	cf 91       	pop	r28
    2430:	df 91       	pop	r29
    2432:	08 95       	ret

00002434 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2434:	df 93       	push	r29
    2436:	cf 93       	push	r28
    2438:	00 d0       	rcall	.+0      	; 0x243a <xQueueIsQueueFullFromISR+0x6>
    243a:	0f 92       	push	r0
    243c:	cd b7       	in	r28, 0x3d	; 61
    243e:	de b7       	in	r29, 0x3e	; 62
    2440:	9b 83       	std	Y+3, r25	; 0x03
    2442:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2444:	ea 81       	ldd	r30, Y+2	; 0x02
    2446:	fb 81       	ldd	r31, Y+3	; 0x03
    2448:	92 8d       	ldd	r25, Z+26	; 0x1a
    244a:	ea 81       	ldd	r30, Y+2	; 0x02
    244c:	fb 81       	ldd	r31, Y+3	; 0x03
    244e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2450:	19 82       	std	Y+1, r1	; 0x01
    2452:	98 17       	cp	r25, r24
    2454:	11 f4       	brne	.+4      	; 0x245a <xQueueIsQueueFullFromISR+0x26>
    2456:	81 e0       	ldi	r24, 0x01	; 1
    2458:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    245a:	89 81       	ldd	r24, Y+1	; 0x01
}
    245c:	0f 90       	pop	r0
    245e:	0f 90       	pop	r0
    2460:	0f 90       	pop	r0
    2462:	cf 91       	pop	r28
    2464:	df 91       	pop	r29
    2466:	08 95       	ret

00002468 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2468:	af 92       	push	r10
    246a:	bf 92       	push	r11
    246c:	cf 92       	push	r12
    246e:	df 92       	push	r13
    2470:	ef 92       	push	r14
    2472:	ff 92       	push	r15
    2474:	0f 93       	push	r16
    2476:	1f 93       	push	r17
    2478:	df 93       	push	r29
    247a:	cf 93       	push	r28
    247c:	cd b7       	in	r28, 0x3d	; 61
    247e:	de b7       	in	r29, 0x3e	; 62
    2480:	64 97       	sbiw	r28, 0x14	; 20
    2482:	0f b6       	in	r0, 0x3f	; 63
    2484:	f8 94       	cli
    2486:	de bf       	out	0x3e, r29	; 62
    2488:	0f be       	out	0x3f, r0	; 63
    248a:	cd bf       	out	0x3d, r28	; 61
    248c:	9f 83       	std	Y+7, r25	; 0x07
    248e:	8e 83       	std	Y+6, r24	; 0x06
    2490:	79 87       	std	Y+9, r23	; 0x09
    2492:	68 87       	std	Y+8, r22	; 0x08
    2494:	5b 87       	std	Y+11, r21	; 0x0b
    2496:	4a 87       	std	Y+10, r20	; 0x0a
    2498:	3d 87       	std	Y+13, r19	; 0x0d
    249a:	2c 87       	std	Y+12, r18	; 0x0c
    249c:	0e 87       	std	Y+14, r16	; 0x0e
    249e:	f8 8a       	std	Y+16, r15	; 0x10
    24a0:	ef 86       	std	Y+15, r14	; 0x0f
    24a2:	da 8a       	std	Y+18, r13	; 0x12
    24a4:	c9 8a       	std	Y+17, r12	; 0x11
    24a6:	bc 8a       	std	Y+20, r11	; 0x14
    24a8:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    24aa:	8a 85       	ldd	r24, Y+10	; 0x0a
    24ac:	9b 85       	ldd	r25, Y+11	; 0x0b
    24ae:	29 89       	ldd	r18, Y+17	; 0x11
    24b0:	3a 89       	ldd	r19, Y+18	; 0x12
    24b2:	b9 01       	movw	r22, r18
    24b4:	0e 94 b9 18 	call	0x3172	; 0x3172 <prvAllocateTCBAndStack>
    24b8:	9c 83       	std	Y+4, r25	; 0x04
    24ba:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    24bc:	8b 81       	ldd	r24, Y+3	; 0x03
    24be:	9c 81       	ldd	r25, Y+4	; 0x04
    24c0:	00 97       	sbiw	r24, 0x00	; 0
    24c2:	09 f4       	brne	.+2      	; 0x24c6 <xTaskGenericCreate+0x5e>
    24c4:	99 c0       	rjmp	.+306    	; 0x25f8 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    24c6:	eb 81       	ldd	r30, Y+3	; 0x03
    24c8:	fc 81       	ldd	r31, Y+4	; 0x04
    24ca:	27 89       	ldd	r18, Z+23	; 0x17
    24cc:	30 8d       	ldd	r19, Z+24	; 0x18
    24ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    24d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    24d2:	01 97       	sbiw	r24, 0x01	; 1
    24d4:	82 0f       	add	r24, r18
    24d6:	93 1f       	adc	r25, r19
    24d8:	9a 83       	std	Y+2, r25	; 0x02
    24da:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    24dc:	8b 81       	ldd	r24, Y+3	; 0x03
    24de:	9c 81       	ldd	r25, Y+4	; 0x04
    24e0:	28 85       	ldd	r18, Y+8	; 0x08
    24e2:	39 85       	ldd	r19, Y+9	; 0x09
    24e4:	eb 89       	ldd	r30, Y+19	; 0x13
    24e6:	fc 89       	ldd	r31, Y+20	; 0x14
    24e8:	aa 85       	ldd	r26, Y+10	; 0x0a
    24ea:	bb 85       	ldd	r27, Y+11	; 0x0b
    24ec:	b9 01       	movw	r22, r18
    24ee:	4e 85       	ldd	r20, Y+14	; 0x0e
    24f0:	9f 01       	movw	r18, r30
    24f2:	8d 01       	movw	r16, r26
    24f4:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    24f8:	89 81       	ldd	r24, Y+1	; 0x01
    24fa:	9a 81       	ldd	r25, Y+2	; 0x02
    24fc:	2e 81       	ldd	r18, Y+6	; 0x06
    24fe:	3f 81       	ldd	r19, Y+7	; 0x07
    2500:	4c 85       	ldd	r20, Y+12	; 0x0c
    2502:	5d 85       	ldd	r21, Y+13	; 0x0d
    2504:	b9 01       	movw	r22, r18
    2506:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <pxPortInitialiseStack>
    250a:	eb 81       	ldd	r30, Y+3	; 0x03
    250c:	fc 81       	ldd	r31, Y+4	; 0x04
    250e:	91 83       	std	Z+1, r25	; 0x01
    2510:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2512:	8f 85       	ldd	r24, Y+15	; 0x0f
    2514:	98 89       	ldd	r25, Y+16	; 0x10
    2516:	00 97       	sbiw	r24, 0x00	; 0
    2518:	31 f0       	breq	.+12     	; 0x2526 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    251a:	ef 85       	ldd	r30, Y+15	; 0x0f
    251c:	f8 89       	ldd	r31, Y+16	; 0x10
    251e:	8b 81       	ldd	r24, Y+3	; 0x03
    2520:	9c 81       	ldd	r25, Y+4	; 0x04
    2522:	91 83       	std	Z+1, r25	; 0x01
    2524:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	f8 94       	cli
    252a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    252c:	80 91 08 03 	lds	r24, 0x0308
    2530:	8f 5f       	subi	r24, 0xFF	; 255
    2532:	80 93 08 03 	sts	0x0308, r24
			if( pxCurrentTCB == NULL )
    2536:	80 91 05 03 	lds	r24, 0x0305
    253a:	90 91 06 03 	lds	r25, 0x0306
    253e:	00 97       	sbiw	r24, 0x00	; 0
    2540:	69 f4       	brne	.+26     	; 0x255c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2542:	8b 81       	ldd	r24, Y+3	; 0x03
    2544:	9c 81       	ldd	r25, Y+4	; 0x04
    2546:	90 93 06 03 	sts	0x0306, r25
    254a:	80 93 05 03 	sts	0x0305, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    254e:	80 91 08 03 	lds	r24, 0x0308
    2552:	81 30       	cpi	r24, 0x01	; 1
    2554:	a9 f4       	brne	.+42     	; 0x2580 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2556:	0e 94 f5 17 	call	0x2fea	; 0x2fea <prvInitialiseTaskLists>
    255a:	12 c0       	rjmp	.+36     	; 0x2580 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    255c:	80 91 0d 03 	lds	r24, 0x030D
    2560:	88 23       	and	r24, r24
    2562:	71 f4       	brne	.+28     	; 0x2580 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2564:	e0 91 05 03 	lds	r30, 0x0305
    2568:	f0 91 06 03 	lds	r31, 0x0306
    256c:	96 89       	ldd	r25, Z+22	; 0x16
    256e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2570:	89 17       	cp	r24, r25
    2572:	30 f0       	brcs	.+12     	; 0x2580 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2574:	8b 81       	ldd	r24, Y+3	; 0x03
    2576:	9c 81       	ldd	r25, Y+4	; 0x04
    2578:	90 93 06 03 	sts	0x0306, r25
    257c:	80 93 05 03 	sts	0x0305, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2580:	eb 81       	ldd	r30, Y+3	; 0x03
    2582:	fc 81       	ldd	r31, Y+4	; 0x04
    2584:	96 89       	ldd	r25, Z+22	; 0x16
    2586:	80 91 0b 03 	lds	r24, 0x030B
    258a:	89 17       	cp	r24, r25
    258c:	28 f4       	brcc	.+10     	; 0x2598 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    258e:	eb 81       	ldd	r30, Y+3	; 0x03
    2590:	fc 81       	ldd	r31, Y+4	; 0x04
    2592:	86 89       	ldd	r24, Z+22	; 0x16
    2594:	80 93 0b 03 	sts	0x030B, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2598:	80 91 12 03 	lds	r24, 0x0312
    259c:	8f 5f       	subi	r24, 0xFF	; 255
    259e:	80 93 12 03 	sts	0x0312, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    25a2:	eb 81       	ldd	r30, Y+3	; 0x03
    25a4:	fc 81       	ldd	r31, Y+4	; 0x04
    25a6:	96 89       	ldd	r25, Z+22	; 0x16
    25a8:	80 91 0c 03 	lds	r24, 0x030C
    25ac:	89 17       	cp	r24, r25
    25ae:	28 f4       	brcc	.+10     	; 0x25ba <xTaskGenericCreate+0x152>
    25b0:	eb 81       	ldd	r30, Y+3	; 0x03
    25b2:	fc 81       	ldd	r31, Y+4	; 0x04
    25b4:	86 89       	ldd	r24, Z+22	; 0x16
    25b6:	80 93 0c 03 	sts	0x030C, r24
    25ba:	eb 81       	ldd	r30, Y+3	; 0x03
    25bc:	fc 81       	ldd	r31, Y+4	; 0x04
    25be:	86 89       	ldd	r24, Z+22	; 0x16
    25c0:	28 2f       	mov	r18, r24
    25c2:	30 e0       	ldi	r19, 0x00	; 0
    25c4:	c9 01       	movw	r24, r18
    25c6:	88 0f       	add	r24, r24
    25c8:	99 1f       	adc	r25, r25
    25ca:	88 0f       	add	r24, r24
    25cc:	99 1f       	adc	r25, r25
    25ce:	88 0f       	add	r24, r24
    25d0:	99 1f       	adc	r25, r25
    25d2:	82 0f       	add	r24, r18
    25d4:	93 1f       	adc	r25, r19
    25d6:	ac 01       	movw	r20, r24
    25d8:	4d 5e       	subi	r20, 0xED	; 237
    25da:	5c 4f       	sbci	r21, 0xFC	; 252
    25dc:	8b 81       	ldd	r24, Y+3	; 0x03
    25de:	9c 81       	ldd	r25, Y+4	; 0x04
    25e0:	9c 01       	movw	r18, r24
    25e2:	2e 5f       	subi	r18, 0xFE	; 254
    25e4:	3f 4f       	sbci	r19, 0xFF	; 255
    25e6:	ca 01       	movw	r24, r20
    25e8:	b9 01       	movw	r22, r18
    25ea:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

			xReturn = pdPASS;
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    25f2:	0f 90       	pop	r0
    25f4:	0f be       	out	0x3f, r0	; 63
    25f6:	02 c0       	rjmp	.+4      	; 0x25fc <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    25f8:	8f ef       	ldi	r24, 0xFF	; 255
    25fa:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    25fc:	8d 81       	ldd	r24, Y+5	; 0x05
    25fe:	81 30       	cpi	r24, 0x01	; 1
    2600:	71 f4       	brne	.+28     	; 0x261e <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2602:	80 91 0d 03 	lds	r24, 0x030D
    2606:	88 23       	and	r24, r24
    2608:	51 f0       	breq	.+20     	; 0x261e <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    260a:	e0 91 05 03 	lds	r30, 0x0305
    260e:	f0 91 06 03 	lds	r31, 0x0306
    2612:	96 89       	ldd	r25, Z+22	; 0x16
    2614:	8e 85       	ldd	r24, Y+14	; 0x0e
    2616:	98 17       	cp	r25, r24
    2618:	10 f4       	brcc	.+4      	; 0x261e <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    261a:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
			}
		}
	}

	return xReturn;
    261e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2620:	64 96       	adiw	r28, 0x14	; 20
    2622:	0f b6       	in	r0, 0x3f	; 63
    2624:	f8 94       	cli
    2626:	de bf       	out	0x3e, r29	; 62
    2628:	0f be       	out	0x3f, r0	; 63
    262a:	cd bf       	out	0x3d, r28	; 61
    262c:	cf 91       	pop	r28
    262e:	df 91       	pop	r29
    2630:	1f 91       	pop	r17
    2632:	0f 91       	pop	r16
    2634:	ff 90       	pop	r15
    2636:	ef 90       	pop	r14
    2638:	df 90       	pop	r13
    263a:	cf 90       	pop	r12
    263c:	bf 90       	pop	r11
    263e:	af 90       	pop	r10
    2640:	08 95       	ret

00002642 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2642:	df 93       	push	r29
    2644:	cf 93       	push	r28
    2646:	00 d0       	rcall	.+0      	; 0x2648 <vTaskDelete+0x6>
    2648:	00 d0       	rcall	.+0      	; 0x264a <vTaskDelete+0x8>
    264a:	00 d0       	rcall	.+0      	; 0x264c <vTaskDelete+0xa>
    264c:	cd b7       	in	r28, 0x3d	; 61
    264e:	de b7       	in	r29, 0x3e	; 62
    2650:	9c 83       	std	Y+4, r25	; 0x04
    2652:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2654:	0f b6       	in	r0, 0x3f	; 63
    2656:	f8 94       	cli
    2658:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    265a:	20 91 05 03 	lds	r18, 0x0305
    265e:	30 91 06 03 	lds	r19, 0x0306
    2662:	8b 81       	ldd	r24, Y+3	; 0x03
    2664:	9c 81       	ldd	r25, Y+4	; 0x04
    2666:	82 17       	cp	r24, r18
    2668:	93 07       	cpc	r25, r19
    266a:	11 f4       	brne	.+4      	; 0x2670 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    266c:	1c 82       	std	Y+4, r1	; 0x04
    266e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2670:	8b 81       	ldd	r24, Y+3	; 0x03
    2672:	9c 81       	ldd	r25, Y+4	; 0x04
    2674:	00 97       	sbiw	r24, 0x00	; 0
    2676:	39 f4       	brne	.+14     	; 0x2686 <vTaskDelete+0x44>
    2678:	80 91 05 03 	lds	r24, 0x0305
    267c:	90 91 06 03 	lds	r25, 0x0306
    2680:	9e 83       	std	Y+6, r25	; 0x06
    2682:	8d 83       	std	Y+5, r24	; 0x05
    2684:	04 c0       	rjmp	.+8      	; 0x268e <vTaskDelete+0x4c>
    2686:	8b 81       	ldd	r24, Y+3	; 0x03
    2688:	9c 81       	ldd	r25, Y+4	; 0x04
    268a:	9e 83       	std	Y+6, r25	; 0x06
    268c:	8d 83       	std	Y+5, r24	; 0x05
    268e:	8d 81       	ldd	r24, Y+5	; 0x05
    2690:	9e 81       	ldd	r25, Y+6	; 0x06
    2692:	9a 83       	std	Y+2, r25	; 0x02
    2694:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2696:	89 81       	ldd	r24, Y+1	; 0x01
    2698:	9a 81       	ldd	r25, Y+2	; 0x02
    269a:	02 96       	adiw	r24, 0x02	; 2
    269c:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    26a0:	e9 81       	ldd	r30, Y+1	; 0x01
    26a2:	fa 81       	ldd	r31, Y+2	; 0x02
    26a4:	84 89       	ldd	r24, Z+20	; 0x14
    26a6:	95 89       	ldd	r25, Z+21	; 0x15
    26a8:	00 97       	sbiw	r24, 0x00	; 0
    26aa:	29 f0       	breq	.+10     	; 0x26b6 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    26ac:	89 81       	ldd	r24, Y+1	; 0x01
    26ae:	9a 81       	ldd	r25, Y+2	; 0x02
    26b0:	0c 96       	adiw	r24, 0x0c	; 12
    26b2:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    26b6:	89 81       	ldd	r24, Y+1	; 0x01
    26b8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ba:	9c 01       	movw	r18, r24
    26bc:	2e 5f       	subi	r18, 0xFE	; 254
    26be:	3f 4f       	sbci	r19, 0xFF	; 255
    26c0:	8f e5       	ldi	r24, 0x5F	; 95
    26c2:	93 e0       	ldi	r25, 0x03	; 3
    26c4:	b9 01       	movw	r22, r18
    26c6:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    26ca:	80 91 07 03 	lds	r24, 0x0307
    26ce:	8f 5f       	subi	r24, 0xFF	; 255
    26d0:	80 93 07 03 	sts	0x0307, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    26d4:	80 91 12 03 	lds	r24, 0x0312
    26d8:	8f 5f       	subi	r24, 0xFF	; 255
    26da:	80 93 12 03 	sts	0x0312, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    26de:	0f 90       	pop	r0
    26e0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    26e2:	80 91 0d 03 	lds	r24, 0x030D
    26e6:	88 23       	and	r24, r24
    26e8:	31 f0       	breq	.+12     	; 0x26f6 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    26ea:	8b 81       	ldd	r24, Y+3	; 0x03
    26ec:	9c 81       	ldd	r25, Y+4	; 0x04
    26ee:	00 97       	sbiw	r24, 0x00	; 0
    26f0:	11 f4       	brne	.+4      	; 0x26f6 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    26f2:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
			}
		}
	}
    26f6:	26 96       	adiw	r28, 0x06	; 6
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	de bf       	out	0x3e, r29	; 62
    26fe:	0f be       	out	0x3f, r0	; 63
    2700:	cd bf       	out	0x3d, r28	; 61
    2702:	cf 91       	pop	r28
    2704:	df 91       	pop	r29
    2706:	08 95       	ret

00002708 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2708:	df 93       	push	r29
    270a:	cf 93       	push	r28
    270c:	cd b7       	in	r28, 0x3d	; 61
    270e:	de b7       	in	r29, 0x3e	; 62
    2710:	28 97       	sbiw	r28, 0x08	; 8
    2712:	0f b6       	in	r0, 0x3f	; 63
    2714:	f8 94       	cli
    2716:	de bf       	out	0x3e, r29	; 62
    2718:	0f be       	out	0x3f, r0	; 63
    271a:	cd bf       	out	0x3d, r28	; 61
    271c:	9e 83       	std	Y+6, r25	; 0x06
    271e:	8d 83       	std	Y+5, r24	; 0x05
    2720:	78 87       	std	Y+8, r23	; 0x08
    2722:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2724:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2726:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    272a:	ed 81       	ldd	r30, Y+5	; 0x05
    272c:	fe 81       	ldd	r31, Y+6	; 0x06
    272e:	20 81       	ld	r18, Z
    2730:	31 81       	ldd	r19, Z+1	; 0x01
    2732:	8f 81       	ldd	r24, Y+7	; 0x07
    2734:	98 85       	ldd	r25, Y+8	; 0x08
    2736:	82 0f       	add	r24, r18
    2738:	93 1f       	adc	r25, r19
    273a:	9c 83       	std	Y+4, r25	; 0x04
    273c:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    273e:	ed 81       	ldd	r30, Y+5	; 0x05
    2740:	fe 81       	ldd	r31, Y+6	; 0x06
    2742:	20 81       	ld	r18, Z
    2744:	31 81       	ldd	r19, Z+1	; 0x01
    2746:	80 91 09 03 	lds	r24, 0x0309
    274a:	90 91 0a 03 	lds	r25, 0x030A
    274e:	82 17       	cp	r24, r18
    2750:	93 07       	cpc	r25, r19
    2752:	a8 f4       	brcc	.+42     	; 0x277e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2754:	ed 81       	ldd	r30, Y+5	; 0x05
    2756:	fe 81       	ldd	r31, Y+6	; 0x06
    2758:	20 81       	ld	r18, Z
    275a:	31 81       	ldd	r19, Z+1	; 0x01
    275c:	8b 81       	ldd	r24, Y+3	; 0x03
    275e:	9c 81       	ldd	r25, Y+4	; 0x04
    2760:	82 17       	cp	r24, r18
    2762:	93 07       	cpc	r25, r19
    2764:	00 f5       	brcc	.+64     	; 0x27a6 <vTaskDelayUntil+0x9e>
    2766:	20 91 09 03 	lds	r18, 0x0309
    276a:	30 91 0a 03 	lds	r19, 0x030A
    276e:	8b 81       	ldd	r24, Y+3	; 0x03
    2770:	9c 81       	ldd	r25, Y+4	; 0x04
    2772:	28 17       	cp	r18, r24
    2774:	39 07       	cpc	r19, r25
    2776:	b8 f4       	brcc	.+46     	; 0x27a6 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2778:	81 e0       	ldi	r24, 0x01	; 1
    277a:	89 83       	std	Y+1, r24	; 0x01
    277c:	14 c0       	rjmp	.+40     	; 0x27a6 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    277e:	ed 81       	ldd	r30, Y+5	; 0x05
    2780:	fe 81       	ldd	r31, Y+6	; 0x06
    2782:	20 81       	ld	r18, Z
    2784:	31 81       	ldd	r19, Z+1	; 0x01
    2786:	8b 81       	ldd	r24, Y+3	; 0x03
    2788:	9c 81       	ldd	r25, Y+4	; 0x04
    278a:	82 17       	cp	r24, r18
    278c:	93 07       	cpc	r25, r19
    278e:	48 f0       	brcs	.+18     	; 0x27a2 <vTaskDelayUntil+0x9a>
    2790:	20 91 09 03 	lds	r18, 0x0309
    2794:	30 91 0a 03 	lds	r19, 0x030A
    2798:	8b 81       	ldd	r24, Y+3	; 0x03
    279a:	9c 81       	ldd	r25, Y+4	; 0x04
    279c:	28 17       	cp	r18, r24
    279e:	39 07       	cpc	r19, r25
    27a0:	10 f4       	brcc	.+4      	; 0x27a6 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    27a6:	ed 81       	ldd	r30, Y+5	; 0x05
    27a8:	fe 81       	ldd	r31, Y+6	; 0x06
    27aa:	8b 81       	ldd	r24, Y+3	; 0x03
    27ac:	9c 81       	ldd	r25, Y+4	; 0x04
    27ae:	91 83       	std	Z+1, r25	; 0x01
    27b0:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    27b2:	89 81       	ldd	r24, Y+1	; 0x01
    27b4:	88 23       	and	r24, r24
    27b6:	59 f0       	breq	.+22     	; 0x27ce <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    27b8:	80 91 05 03 	lds	r24, 0x0305
    27bc:	90 91 06 03 	lds	r25, 0x0306
    27c0:	02 96       	adiw	r24, 0x02	; 2
    27c2:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    27c6:	8b 81       	ldd	r24, Y+3	; 0x03
    27c8:	9c 81       	ldd	r25, Y+4	; 0x04
    27ca:	0e 94 70 18 	call	0x30e0	; 0x30e0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    27ce:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
    27d2:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    27d4:	8a 81       	ldd	r24, Y+2	; 0x02
    27d6:	88 23       	and	r24, r24
    27d8:	11 f4       	brne	.+4      	; 0x27de <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    27da:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
		}
	}
    27de:	28 96       	adiw	r28, 0x08	; 8
    27e0:	0f b6       	in	r0, 0x3f	; 63
    27e2:	f8 94       	cli
    27e4:	de bf       	out	0x3e, r29	; 62
    27e6:	0f be       	out	0x3f, r0	; 63
    27e8:	cd bf       	out	0x3d, r28	; 61
    27ea:	cf 91       	pop	r28
    27ec:	df 91       	pop	r29
    27ee:	08 95       	ret

000027f0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    27f0:	df 93       	push	r29
    27f2:	cf 93       	push	r28
    27f4:	00 d0       	rcall	.+0      	; 0x27f6 <vTaskDelay+0x6>
    27f6:	00 d0       	rcall	.+0      	; 0x27f8 <vTaskDelay+0x8>
    27f8:	0f 92       	push	r0
    27fa:	cd b7       	in	r28, 0x3d	; 61
    27fc:	de b7       	in	r29, 0x3e	; 62
    27fe:	9d 83       	std	Y+5, r25	; 0x05
    2800:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2802:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2804:	8c 81       	ldd	r24, Y+4	; 0x04
    2806:	9d 81       	ldd	r25, Y+5	; 0x05
    2808:	00 97       	sbiw	r24, 0x00	; 0
    280a:	d1 f0       	breq	.+52     	; 0x2840 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    280c:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2810:	20 91 09 03 	lds	r18, 0x0309
    2814:	30 91 0a 03 	lds	r19, 0x030A
    2818:	8c 81       	ldd	r24, Y+4	; 0x04
    281a:	9d 81       	ldd	r25, Y+5	; 0x05
    281c:	82 0f       	add	r24, r18
    281e:	93 1f       	adc	r25, r19
    2820:	9b 83       	std	Y+3, r25	; 0x03
    2822:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2824:	80 91 05 03 	lds	r24, 0x0305
    2828:	90 91 06 03 	lds	r25, 0x0306
    282c:	02 96       	adiw	r24, 0x02	; 2
    282e:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2832:	8a 81       	ldd	r24, Y+2	; 0x02
    2834:	9b 81       	ldd	r25, Y+3	; 0x03
    2836:	0e 94 70 18 	call	0x30e0	; 0x30e0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    283a:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>
    283e:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2840:	89 81       	ldd	r24, Y+1	; 0x01
    2842:	88 23       	and	r24, r24
    2844:	11 f4       	brne	.+4      	; 0x284a <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2846:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
		}
	}
    284a:	0f 90       	pop	r0
    284c:	0f 90       	pop	r0
    284e:	0f 90       	pop	r0
    2850:	0f 90       	pop	r0
    2852:	0f 90       	pop	r0
    2854:	cf 91       	pop	r28
    2856:	df 91       	pop	r29
    2858:	08 95       	ret

0000285a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    285a:	af 92       	push	r10
    285c:	bf 92       	push	r11
    285e:	cf 92       	push	r12
    2860:	df 92       	push	r13
    2862:	ef 92       	push	r14
    2864:	ff 92       	push	r15
    2866:	0f 93       	push	r16
    2868:	df 93       	push	r29
    286a:	cf 93       	push	r28
    286c:	0f 92       	push	r0
    286e:	cd b7       	in	r28, 0x3d	; 61
    2870:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2872:	20 e6       	ldi	r18, 0x60	; 96
    2874:	30 e0       	ldi	r19, 0x00	; 0
    2876:	84 e9       	ldi	r24, 0x94	; 148
    2878:	97 e1       	ldi	r25, 0x17	; 23
    287a:	b9 01       	movw	r22, r18
    287c:	44 e6       	ldi	r20, 0x64	; 100
    287e:	50 e0       	ldi	r21, 0x00	; 0
    2880:	20 e0       	ldi	r18, 0x00	; 0
    2882:	30 e0       	ldi	r19, 0x00	; 0
    2884:	00 e0       	ldi	r16, 0x00	; 0
    2886:	ee 24       	eor	r14, r14
    2888:	ff 24       	eor	r15, r15
    288a:	cc 24       	eor	r12, r12
    288c:	dd 24       	eor	r13, r13
    288e:	aa 24       	eor	r10, r10
    2890:	bb 24       	eor	r11, r11
    2892:	0e 94 34 12 	call	0x2468	; 0x2468 <xTaskGenericCreate>
    2896:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2898:	89 81       	ldd	r24, Y+1	; 0x01
    289a:	81 30       	cpi	r24, 0x01	; 1
    289c:	51 f4       	brne	.+20     	; 0x28b2 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    289e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    28a0:	81 e0       	ldi	r24, 0x01	; 1
    28a2:	80 93 0d 03 	sts	0x030D, r24
		xTickCount = ( portTickType ) 0U;
    28a6:	10 92 0a 03 	sts	0x030A, r1
    28aa:	10 92 09 03 	sts	0x0309, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    28ae:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    28b2:	0f 90       	pop	r0
    28b4:	cf 91       	pop	r28
    28b6:	df 91       	pop	r29
    28b8:	0f 91       	pop	r16
    28ba:	ff 90       	pop	r15
    28bc:	ef 90       	pop	r14
    28be:	df 90       	pop	r13
    28c0:	cf 90       	pop	r12
    28c2:	bf 90       	pop	r11
    28c4:	af 90       	pop	r10
    28c6:	08 95       	ret

000028c8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    28c8:	df 93       	push	r29
    28ca:	cf 93       	push	r28
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    28d0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    28d2:	10 92 0d 03 	sts	0x030D, r1
	vPortEndScheduler();
    28d6:	0e 94 99 0c 	call	0x1932	; 0x1932 <vPortEndScheduler>
}
    28da:	cf 91       	pop	r28
    28dc:	df 91       	pop	r29
    28de:	08 95       	ret

000028e0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    28e0:	df 93       	push	r29
    28e2:	cf 93       	push	r28
    28e4:	cd b7       	in	r28, 0x3d	; 61
    28e6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    28e8:	80 91 0e 03 	lds	r24, 0x030E
    28ec:	8f 5f       	subi	r24, 0xFF	; 255
    28ee:	80 93 0e 03 	sts	0x030E, r24
}
    28f2:	cf 91       	pop	r28
    28f4:	df 91       	pop	r29
    28f6:	08 95       	ret

000028f8 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    28f8:	df 93       	push	r29
    28fa:	cf 93       	push	r28
    28fc:	00 d0       	rcall	.+0      	; 0x28fe <xTaskResumeAll+0x6>
    28fe:	00 d0       	rcall	.+0      	; 0x2900 <xTaskResumeAll+0x8>
    2900:	cd b7       	in	r28, 0x3d	; 61
    2902:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2904:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2906:	0f b6       	in	r0, 0x3f	; 63
    2908:	f8 94       	cli
    290a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    290c:	80 91 0e 03 	lds	r24, 0x030E
    2910:	81 50       	subi	r24, 0x01	; 1
    2912:	80 93 0e 03 	sts	0x030E, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2916:	80 91 0e 03 	lds	r24, 0x030E
    291a:	88 23       	and	r24, r24
    291c:	09 f0       	breq	.+2      	; 0x2920 <xTaskResumeAll+0x28>
    291e:	6c c0       	rjmp	.+216    	; 0x29f8 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2920:	80 91 08 03 	lds	r24, 0x0308
    2924:	88 23       	and	r24, r24
    2926:	09 f4       	brne	.+2      	; 0x292a <xTaskResumeAll+0x32>
    2928:	67 c0       	rjmp	.+206    	; 0x29f8 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    292a:	19 82       	std	Y+1, r1	; 0x01
    292c:	41 c0       	rjmp	.+130    	; 0x29b0 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    292e:	e0 91 5b 03 	lds	r30, 0x035B
    2932:	f0 91 5c 03 	lds	r31, 0x035C
    2936:	86 81       	ldd	r24, Z+6	; 0x06
    2938:	97 81       	ldd	r25, Z+7	; 0x07
    293a:	9c 83       	std	Y+4, r25	; 0x04
    293c:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    293e:	8b 81       	ldd	r24, Y+3	; 0x03
    2940:	9c 81       	ldd	r25, Y+4	; 0x04
    2942:	0c 96       	adiw	r24, 0x0c	; 12
    2944:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2948:	8b 81       	ldd	r24, Y+3	; 0x03
    294a:	9c 81       	ldd	r25, Y+4	; 0x04
    294c:	02 96       	adiw	r24, 0x02	; 2
    294e:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2952:	eb 81       	ldd	r30, Y+3	; 0x03
    2954:	fc 81       	ldd	r31, Y+4	; 0x04
    2956:	96 89       	ldd	r25, Z+22	; 0x16
    2958:	80 91 0c 03 	lds	r24, 0x030C
    295c:	89 17       	cp	r24, r25
    295e:	28 f4       	brcc	.+10     	; 0x296a <xTaskResumeAll+0x72>
    2960:	eb 81       	ldd	r30, Y+3	; 0x03
    2962:	fc 81       	ldd	r31, Y+4	; 0x04
    2964:	86 89       	ldd	r24, Z+22	; 0x16
    2966:	80 93 0c 03 	sts	0x030C, r24
    296a:	eb 81       	ldd	r30, Y+3	; 0x03
    296c:	fc 81       	ldd	r31, Y+4	; 0x04
    296e:	86 89       	ldd	r24, Z+22	; 0x16
    2970:	28 2f       	mov	r18, r24
    2972:	30 e0       	ldi	r19, 0x00	; 0
    2974:	c9 01       	movw	r24, r18
    2976:	88 0f       	add	r24, r24
    2978:	99 1f       	adc	r25, r25
    297a:	88 0f       	add	r24, r24
    297c:	99 1f       	adc	r25, r25
    297e:	88 0f       	add	r24, r24
    2980:	99 1f       	adc	r25, r25
    2982:	82 0f       	add	r24, r18
    2984:	93 1f       	adc	r25, r19
    2986:	8d 5e       	subi	r24, 0xED	; 237
    2988:	9c 4f       	sbci	r25, 0xFC	; 252
    298a:	2b 81       	ldd	r18, Y+3	; 0x03
    298c:	3c 81       	ldd	r19, Y+4	; 0x04
    298e:	2e 5f       	subi	r18, 0xFE	; 254
    2990:	3f 4f       	sbci	r19, 0xFF	; 255
    2992:	b9 01       	movw	r22, r18
    2994:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2998:	eb 81       	ldd	r30, Y+3	; 0x03
    299a:	fc 81       	ldd	r31, Y+4	; 0x04
    299c:	96 89       	ldd	r25, Z+22	; 0x16
    299e:	e0 91 05 03 	lds	r30, 0x0305
    29a2:	f0 91 06 03 	lds	r31, 0x0306
    29a6:	86 89       	ldd	r24, Z+22	; 0x16
    29a8:	98 17       	cp	r25, r24
    29aa:	10 f0       	brcs	.+4      	; 0x29b0 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    29b0:	80 91 56 03 	lds	r24, 0x0356
    29b4:	88 23       	and	r24, r24
    29b6:	09 f0       	breq	.+2      	; 0x29ba <xTaskResumeAll+0xc2>
    29b8:	ba cf       	rjmp	.-140    	; 0x292e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29ba:	80 91 0f 03 	lds	r24, 0x030F
    29be:	88 23       	and	r24, r24
    29c0:	71 f0       	breq	.+28     	; 0x29de <xTaskResumeAll+0xe6>
    29c2:	07 c0       	rjmp	.+14     	; 0x29d2 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    29c4:	0e 94 3b 15 	call	0x2a76	; 0x2a76 <vTaskIncrementTick>
						--uxMissedTicks;
    29c8:	80 91 0f 03 	lds	r24, 0x030F
    29cc:	81 50       	subi	r24, 0x01	; 1
    29ce:	80 93 0f 03 	sts	0x030F, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    29d2:	80 91 0f 03 	lds	r24, 0x030F
    29d6:	88 23       	and	r24, r24
    29d8:	a9 f7       	brne	.-22     	; 0x29c4 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    29da:	81 e0       	ldi	r24, 0x01	; 1
    29dc:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    29de:	89 81       	ldd	r24, Y+1	; 0x01
    29e0:	81 30       	cpi	r24, 0x01	; 1
    29e2:	21 f0       	breq	.+8      	; 0x29ec <xTaskResumeAll+0xf4>
    29e4:	80 91 10 03 	lds	r24, 0x0310
    29e8:	81 30       	cpi	r24, 0x01	; 1
    29ea:	31 f4       	brne	.+12     	; 0x29f8 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    29ec:	81 e0       	ldi	r24, 0x01	; 1
    29ee:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    29f0:	10 92 10 03 	sts	0x0310, r1
					portYIELD_WITHIN_API();
    29f4:	0e 94 a0 0c 	call	0x1940	; 0x1940 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    29f8:	0f 90       	pop	r0
    29fa:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    29fc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    29fe:	0f 90       	pop	r0
    2a00:	0f 90       	pop	r0
    2a02:	0f 90       	pop	r0
    2a04:	0f 90       	pop	r0
    2a06:	cf 91       	pop	r28
    2a08:	df 91       	pop	r29
    2a0a:	08 95       	ret

00002a0c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2a0c:	df 93       	push	r29
    2a0e:	cf 93       	push	r28
    2a10:	00 d0       	rcall	.+0      	; 0x2a12 <xTaskGetTickCount+0x6>
    2a12:	cd b7       	in	r28, 0x3d	; 61
    2a14:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2a16:	0f b6       	in	r0, 0x3f	; 63
    2a18:	f8 94       	cli
    2a1a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2a1c:	80 91 09 03 	lds	r24, 0x0309
    2a20:	90 91 0a 03 	lds	r25, 0x030A
    2a24:	9a 83       	std	Y+2, r25	; 0x02
    2a26:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2a28:	0f 90       	pop	r0
    2a2a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2a2c:	89 81       	ldd	r24, Y+1	; 0x01
    2a2e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2a30:	0f 90       	pop	r0
    2a32:	0f 90       	pop	r0
    2a34:	cf 91       	pop	r28
    2a36:	df 91       	pop	r29
    2a38:	08 95       	ret

00002a3a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2a3a:	df 93       	push	r29
    2a3c:	cf 93       	push	r28
    2a3e:	00 d0       	rcall	.+0      	; 0x2a40 <xTaskGetTickCountFromISR+0x6>
    2a40:	0f 92       	push	r0
    2a42:	cd b7       	in	r28, 0x3d	; 61
    2a44:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a46:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2a48:	80 91 09 03 	lds	r24, 0x0309
    2a4c:	90 91 0a 03 	lds	r25, 0x030A
    2a50:	9b 83       	std	Y+3, r25	; 0x03
    2a52:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a54:	8a 81       	ldd	r24, Y+2	; 0x02
    2a56:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2a58:	0f 90       	pop	r0
    2a5a:	0f 90       	pop	r0
    2a5c:	0f 90       	pop	r0
    2a5e:	cf 91       	pop	r28
    2a60:	df 91       	pop	r29
    2a62:	08 95       	ret

00002a64 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2a64:	df 93       	push	r29
    2a66:	cf 93       	push	r28
    2a68:	cd b7       	in	r28, 0x3d	; 61
    2a6a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2a6c:	80 91 08 03 	lds	r24, 0x0308
}
    2a70:	cf 91       	pop	r28
    2a72:	df 91       	pop	r29
    2a74:	08 95       	ret

00002a76 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2a76:	df 93       	push	r29
    2a78:	cf 93       	push	r28
    2a7a:	00 d0       	rcall	.+0      	; 0x2a7c <vTaskIncrementTick+0x6>
    2a7c:	00 d0       	rcall	.+0      	; 0x2a7e <vTaskIncrementTick+0x8>
    2a7e:	00 d0       	rcall	.+0      	; 0x2a80 <vTaskIncrementTick+0xa>
    2a80:	cd b7       	in	r28, 0x3d	; 61
    2a82:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2a84:	80 91 0e 03 	lds	r24, 0x030E
    2a88:	88 23       	and	r24, r24
    2a8a:	09 f0       	breq	.+2      	; 0x2a8e <vTaskIncrementTick+0x18>
    2a8c:	bb c0       	rjmp	.+374    	; 0x2c04 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2a8e:	80 91 09 03 	lds	r24, 0x0309
    2a92:	90 91 0a 03 	lds	r25, 0x030A
    2a96:	01 96       	adiw	r24, 0x01	; 1
    2a98:	90 93 0a 03 	sts	0x030A, r25
    2a9c:	80 93 09 03 	sts	0x0309, r24
		if( xTickCount == ( portTickType ) 0U )
    2aa0:	80 91 09 03 	lds	r24, 0x0309
    2aa4:	90 91 0a 03 	lds	r25, 0x030A
    2aa8:	00 97       	sbiw	r24, 0x00	; 0
    2aaa:	d1 f5       	brne	.+116    	; 0x2b20 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2aac:	80 91 52 03 	lds	r24, 0x0352
    2ab0:	90 91 53 03 	lds	r25, 0x0353
    2ab4:	9c 83       	std	Y+4, r25	; 0x04
    2ab6:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2ab8:	80 91 54 03 	lds	r24, 0x0354
    2abc:	90 91 55 03 	lds	r25, 0x0355
    2ac0:	90 93 53 03 	sts	0x0353, r25
    2ac4:	80 93 52 03 	sts	0x0352, r24
			pxOverflowDelayedTaskList = pxTemp;
    2ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aca:	9c 81       	ldd	r25, Y+4	; 0x04
    2acc:	90 93 55 03 	sts	0x0355, r25
    2ad0:	80 93 54 03 	sts	0x0354, r24
			xNumOfOverflows++;
    2ad4:	80 91 11 03 	lds	r24, 0x0311
    2ad8:	8f 5f       	subi	r24, 0xFF	; 255
    2ada:	80 93 11 03 	sts	0x0311, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2ade:	e0 91 52 03 	lds	r30, 0x0352
    2ae2:	f0 91 53 03 	lds	r31, 0x0353
    2ae6:	80 81       	ld	r24, Z
    2ae8:	88 23       	and	r24, r24
    2aea:	39 f4       	brne	.+14     	; 0x2afa <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2aec:	8f ef       	ldi	r24, 0xFF	; 255
    2aee:	9f ef       	ldi	r25, 0xFF	; 255
    2af0:	90 93 66 00 	sts	0x0066, r25
    2af4:	80 93 65 00 	sts	0x0065, r24
    2af8:	13 c0       	rjmp	.+38     	; 0x2b20 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2afa:	e0 91 52 03 	lds	r30, 0x0352
    2afe:	f0 91 53 03 	lds	r31, 0x0353
    2b02:	05 80       	ldd	r0, Z+5	; 0x05
    2b04:	f6 81       	ldd	r31, Z+6	; 0x06
    2b06:	e0 2d       	mov	r30, r0
    2b08:	86 81       	ldd	r24, Z+6	; 0x06
    2b0a:	97 81       	ldd	r25, Z+7	; 0x07
    2b0c:	9e 83       	std	Y+6, r25	; 0x06
    2b0e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2b10:	ed 81       	ldd	r30, Y+5	; 0x05
    2b12:	fe 81       	ldd	r31, Y+6	; 0x06
    2b14:	82 81       	ldd	r24, Z+2	; 0x02
    2b16:	93 81       	ldd	r25, Z+3	; 0x03
    2b18:	90 93 66 00 	sts	0x0066, r25
    2b1c:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2b20:	20 91 09 03 	lds	r18, 0x0309
    2b24:	30 91 0a 03 	lds	r19, 0x030A
    2b28:	80 91 65 00 	lds	r24, 0x0065
    2b2c:	90 91 66 00 	lds	r25, 0x0066
    2b30:	28 17       	cp	r18, r24
    2b32:	39 07       	cpc	r19, r25
    2b34:	08 f4       	brcc	.+2      	; 0x2b38 <vTaskIncrementTick+0xc2>
    2b36:	6b c0       	rjmp	.+214    	; 0x2c0e <vTaskIncrementTick+0x198>
    2b38:	e0 91 52 03 	lds	r30, 0x0352
    2b3c:	f0 91 53 03 	lds	r31, 0x0353
    2b40:	80 81       	ld	r24, Z
    2b42:	88 23       	and	r24, r24
    2b44:	39 f4       	brne	.+14     	; 0x2b54 <vTaskIncrementTick+0xde>
    2b46:	8f ef       	ldi	r24, 0xFF	; 255
    2b48:	9f ef       	ldi	r25, 0xFF	; 255
    2b4a:	90 93 66 00 	sts	0x0066, r25
    2b4e:	80 93 65 00 	sts	0x0065, r24
    2b52:	5d c0       	rjmp	.+186    	; 0x2c0e <vTaskIncrementTick+0x198>
    2b54:	e0 91 52 03 	lds	r30, 0x0352
    2b58:	f0 91 53 03 	lds	r31, 0x0353
    2b5c:	05 80       	ldd	r0, Z+5	; 0x05
    2b5e:	f6 81       	ldd	r31, Z+6	; 0x06
    2b60:	e0 2d       	mov	r30, r0
    2b62:	86 81       	ldd	r24, Z+6	; 0x06
    2b64:	97 81       	ldd	r25, Z+7	; 0x07
    2b66:	9e 83       	std	Y+6, r25	; 0x06
    2b68:	8d 83       	std	Y+5, r24	; 0x05
    2b6a:	ed 81       	ldd	r30, Y+5	; 0x05
    2b6c:	fe 81       	ldd	r31, Y+6	; 0x06
    2b6e:	82 81       	ldd	r24, Z+2	; 0x02
    2b70:	93 81       	ldd	r25, Z+3	; 0x03
    2b72:	9a 83       	std	Y+2, r25	; 0x02
    2b74:	89 83       	std	Y+1, r24	; 0x01
    2b76:	20 91 09 03 	lds	r18, 0x0309
    2b7a:	30 91 0a 03 	lds	r19, 0x030A
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
    2b80:	9a 81       	ldd	r25, Y+2	; 0x02
    2b82:	28 17       	cp	r18, r24
    2b84:	39 07       	cpc	r19, r25
    2b86:	38 f4       	brcc	.+14     	; 0x2b96 <vTaskIncrementTick+0x120>
    2b88:	89 81       	ldd	r24, Y+1	; 0x01
    2b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b8c:	90 93 66 00 	sts	0x0066, r25
    2b90:	80 93 65 00 	sts	0x0065, r24
    2b94:	3c c0       	rjmp	.+120    	; 0x2c0e <vTaskIncrementTick+0x198>
    2b96:	8d 81       	ldd	r24, Y+5	; 0x05
    2b98:	9e 81       	ldd	r25, Y+6	; 0x06
    2b9a:	02 96       	adiw	r24, 0x02	; 2
    2b9c:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
    2ba0:	ed 81       	ldd	r30, Y+5	; 0x05
    2ba2:	fe 81       	ldd	r31, Y+6	; 0x06
    2ba4:	84 89       	ldd	r24, Z+20	; 0x14
    2ba6:	95 89       	ldd	r25, Z+21	; 0x15
    2ba8:	00 97       	sbiw	r24, 0x00	; 0
    2baa:	29 f0       	breq	.+10     	; 0x2bb6 <vTaskIncrementTick+0x140>
    2bac:	8d 81       	ldd	r24, Y+5	; 0x05
    2bae:	9e 81       	ldd	r25, Y+6	; 0x06
    2bb0:	0c 96       	adiw	r24, 0x0c	; 12
    2bb2:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
    2bb6:	ed 81       	ldd	r30, Y+5	; 0x05
    2bb8:	fe 81       	ldd	r31, Y+6	; 0x06
    2bba:	96 89       	ldd	r25, Z+22	; 0x16
    2bbc:	80 91 0c 03 	lds	r24, 0x030C
    2bc0:	89 17       	cp	r24, r25
    2bc2:	28 f4       	brcc	.+10     	; 0x2bce <vTaskIncrementTick+0x158>
    2bc4:	ed 81       	ldd	r30, Y+5	; 0x05
    2bc6:	fe 81       	ldd	r31, Y+6	; 0x06
    2bc8:	86 89       	ldd	r24, Z+22	; 0x16
    2bca:	80 93 0c 03 	sts	0x030C, r24
    2bce:	ed 81       	ldd	r30, Y+5	; 0x05
    2bd0:	fe 81       	ldd	r31, Y+6	; 0x06
    2bd2:	86 89       	ldd	r24, Z+22	; 0x16
    2bd4:	28 2f       	mov	r18, r24
    2bd6:	30 e0       	ldi	r19, 0x00	; 0
    2bd8:	c9 01       	movw	r24, r18
    2bda:	88 0f       	add	r24, r24
    2bdc:	99 1f       	adc	r25, r25
    2bde:	88 0f       	add	r24, r24
    2be0:	99 1f       	adc	r25, r25
    2be2:	88 0f       	add	r24, r24
    2be4:	99 1f       	adc	r25, r25
    2be6:	82 0f       	add	r24, r18
    2be8:	93 1f       	adc	r25, r19
    2bea:	ac 01       	movw	r20, r24
    2bec:	4d 5e       	subi	r20, 0xED	; 237
    2bee:	5c 4f       	sbci	r21, 0xFC	; 252
    2bf0:	8d 81       	ldd	r24, Y+5	; 0x05
    2bf2:	9e 81       	ldd	r25, Y+6	; 0x06
    2bf4:	9c 01       	movw	r18, r24
    2bf6:	2e 5f       	subi	r18, 0xFE	; 254
    2bf8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bfa:	ca 01       	movw	r24, r20
    2bfc:	b9 01       	movw	r22, r18
    2bfe:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
    2c02:	9a cf       	rjmp	.-204    	; 0x2b38 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2c04:	80 91 0f 03 	lds	r24, 0x030F
    2c08:	8f 5f       	subi	r24, 0xFF	; 255
    2c0a:	80 93 0f 03 	sts	0x030F, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2c0e:	26 96       	adiw	r28, 0x06	; 6
    2c10:	0f b6       	in	r0, 0x3f	; 63
    2c12:	f8 94       	cli
    2c14:	de bf       	out	0x3e, r29	; 62
    2c16:	0f be       	out	0x3f, r0	; 63
    2c18:	cd bf       	out	0x3d, r28	; 61
    2c1a:	cf 91       	pop	r28
    2c1c:	df 91       	pop	r29
    2c1e:	08 95       	ret

00002c20 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2c20:	df 93       	push	r29
    2c22:	cf 93       	push	r28
    2c24:	00 d0       	rcall	.+0      	; 0x2c26 <vTaskSwitchContext+0x6>
    2c26:	cd b7       	in	r28, 0x3d	; 61
    2c28:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2c2a:	80 91 0e 03 	lds	r24, 0x030E
    2c2e:	88 23       	and	r24, r24
    2c30:	49 f0       	breq	.+18     	; 0x2c44 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2c32:	81 e0       	ldi	r24, 0x01	; 1
    2c34:	80 93 10 03 	sts	0x0310, r24
    2c38:	54 c0       	rjmp	.+168    	; 0x2ce2 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2c3a:	80 91 0c 03 	lds	r24, 0x030C
    2c3e:	81 50       	subi	r24, 0x01	; 1
    2c40:	80 93 0c 03 	sts	0x030C, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2c44:	80 91 0c 03 	lds	r24, 0x030C
    2c48:	28 2f       	mov	r18, r24
    2c4a:	30 e0       	ldi	r19, 0x00	; 0
    2c4c:	c9 01       	movw	r24, r18
    2c4e:	88 0f       	add	r24, r24
    2c50:	99 1f       	adc	r25, r25
    2c52:	88 0f       	add	r24, r24
    2c54:	99 1f       	adc	r25, r25
    2c56:	88 0f       	add	r24, r24
    2c58:	99 1f       	adc	r25, r25
    2c5a:	82 0f       	add	r24, r18
    2c5c:	93 1f       	adc	r25, r19
    2c5e:	fc 01       	movw	r30, r24
    2c60:	ed 5e       	subi	r30, 0xED	; 237
    2c62:	fc 4f       	sbci	r31, 0xFC	; 252
    2c64:	80 81       	ld	r24, Z
    2c66:	88 23       	and	r24, r24
    2c68:	41 f3       	breq	.-48     	; 0x2c3a <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2c6a:	80 91 0c 03 	lds	r24, 0x030C
    2c6e:	28 2f       	mov	r18, r24
    2c70:	30 e0       	ldi	r19, 0x00	; 0
    2c72:	c9 01       	movw	r24, r18
    2c74:	88 0f       	add	r24, r24
    2c76:	99 1f       	adc	r25, r25
    2c78:	88 0f       	add	r24, r24
    2c7a:	99 1f       	adc	r25, r25
    2c7c:	88 0f       	add	r24, r24
    2c7e:	99 1f       	adc	r25, r25
    2c80:	82 0f       	add	r24, r18
    2c82:	93 1f       	adc	r25, r19
    2c84:	8d 5e       	subi	r24, 0xED	; 237
    2c86:	9c 4f       	sbci	r25, 0xFC	; 252
    2c88:	9a 83       	std	Y+2, r25	; 0x02
    2c8a:	89 83       	std	Y+1, r24	; 0x01
    2c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c90:	01 80       	ldd	r0, Z+1	; 0x01
    2c92:	f2 81       	ldd	r31, Z+2	; 0x02
    2c94:	e0 2d       	mov	r30, r0
    2c96:	82 81       	ldd	r24, Z+2	; 0x02
    2c98:	93 81       	ldd	r25, Z+3	; 0x03
    2c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c9e:	92 83       	std	Z+2, r25	; 0x02
    2ca0:	81 83       	std	Z+1, r24	; 0x01
    2ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca6:	21 81       	ldd	r18, Z+1	; 0x01
    2ca8:	32 81       	ldd	r19, Z+2	; 0x02
    2caa:	89 81       	ldd	r24, Y+1	; 0x01
    2cac:	9a 81       	ldd	r25, Y+2	; 0x02
    2cae:	03 96       	adiw	r24, 0x03	; 3
    2cb0:	28 17       	cp	r18, r24
    2cb2:	39 07       	cpc	r19, r25
    2cb4:	59 f4       	brne	.+22     	; 0x2ccc <vTaskSwitchContext+0xac>
    2cb6:	e9 81       	ldd	r30, Y+1	; 0x01
    2cb8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cba:	01 80       	ldd	r0, Z+1	; 0x01
    2cbc:	f2 81       	ldd	r31, Z+2	; 0x02
    2cbe:	e0 2d       	mov	r30, r0
    2cc0:	82 81       	ldd	r24, Z+2	; 0x02
    2cc2:	93 81       	ldd	r25, Z+3	; 0x03
    2cc4:	e9 81       	ldd	r30, Y+1	; 0x01
    2cc6:	fa 81       	ldd	r31, Y+2	; 0x02
    2cc8:	92 83       	std	Z+2, r25	; 0x02
    2cca:	81 83       	std	Z+1, r24	; 0x01
    2ccc:	e9 81       	ldd	r30, Y+1	; 0x01
    2cce:	fa 81       	ldd	r31, Y+2	; 0x02
    2cd0:	01 80       	ldd	r0, Z+1	; 0x01
    2cd2:	f2 81       	ldd	r31, Z+2	; 0x02
    2cd4:	e0 2d       	mov	r30, r0
    2cd6:	86 81       	ldd	r24, Z+6	; 0x06
    2cd8:	97 81       	ldd	r25, Z+7	; 0x07
    2cda:	90 93 06 03 	sts	0x0306, r25
    2cde:	80 93 05 03 	sts	0x0305, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2ce2:	0f 90       	pop	r0
    2ce4:	0f 90       	pop	r0
    2ce6:	cf 91       	pop	r28
    2ce8:	df 91       	pop	r29
    2cea:	08 95       	ret

00002cec <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2cec:	df 93       	push	r29
    2cee:	cf 93       	push	r28
    2cf0:	00 d0       	rcall	.+0      	; 0x2cf2 <vTaskPlaceOnEventList+0x6>
    2cf2:	00 d0       	rcall	.+0      	; 0x2cf4 <vTaskPlaceOnEventList+0x8>
    2cf4:	00 d0       	rcall	.+0      	; 0x2cf6 <vTaskPlaceOnEventList+0xa>
    2cf6:	cd b7       	in	r28, 0x3d	; 61
    2cf8:	de b7       	in	r29, 0x3e	; 62
    2cfa:	9c 83       	std	Y+4, r25	; 0x04
    2cfc:	8b 83       	std	Y+3, r24	; 0x03
    2cfe:	7e 83       	std	Y+6, r23	; 0x06
    2d00:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2d02:	4b 81       	ldd	r20, Y+3	; 0x03
    2d04:	5c 81       	ldd	r21, Y+4	; 0x04
    2d06:	80 91 05 03 	lds	r24, 0x0305
    2d0a:	90 91 06 03 	lds	r25, 0x0306
    2d0e:	9c 01       	movw	r18, r24
    2d10:	24 5f       	subi	r18, 0xF4	; 244
    2d12:	3f 4f       	sbci	r19, 0xFF	; 255
    2d14:	ca 01       	movw	r24, r20
    2d16:	b9 01       	movw	r22, r18
    2d18:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d1c:	80 91 05 03 	lds	r24, 0x0305
    2d20:	90 91 06 03 	lds	r25, 0x0306
    2d24:	02 96       	adiw	r24, 0x02	; 2
    2d26:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2d2a:	20 91 09 03 	lds	r18, 0x0309
    2d2e:	30 91 0a 03 	lds	r19, 0x030A
    2d32:	8d 81       	ldd	r24, Y+5	; 0x05
    2d34:	9e 81       	ldd	r25, Y+6	; 0x06
    2d36:	82 0f       	add	r24, r18
    2d38:	93 1f       	adc	r25, r19
    2d3a:	9a 83       	std	Y+2, r25	; 0x02
    2d3c:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2d3e:	89 81       	ldd	r24, Y+1	; 0x01
    2d40:	9a 81       	ldd	r25, Y+2	; 0x02
    2d42:	0e 94 70 18 	call	0x30e0	; 0x30e0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2d46:	26 96       	adiw	r28, 0x06	; 6
    2d48:	0f b6       	in	r0, 0x3f	; 63
    2d4a:	f8 94       	cli
    2d4c:	de bf       	out	0x3e, r29	; 62
    2d4e:	0f be       	out	0x3f, r0	; 63
    2d50:	cd bf       	out	0x3d, r28	; 61
    2d52:	cf 91       	pop	r28
    2d54:	df 91       	pop	r29
    2d56:	08 95       	ret

00002d58 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2d58:	df 93       	push	r29
    2d5a:	cf 93       	push	r28
    2d5c:	00 d0       	rcall	.+0      	; 0x2d5e <xTaskRemoveFromEventList+0x6>
    2d5e:	00 d0       	rcall	.+0      	; 0x2d60 <xTaskRemoveFromEventList+0x8>
    2d60:	0f 92       	push	r0
    2d62:	cd b7       	in	r28, 0x3d	; 61
    2d64:	de b7       	in	r29, 0x3e	; 62
    2d66:	9d 83       	std	Y+5, r25	; 0x05
    2d68:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2d6a:	ec 81       	ldd	r30, Y+4	; 0x04
    2d6c:	fd 81       	ldd	r31, Y+5	; 0x05
    2d6e:	05 80       	ldd	r0, Z+5	; 0x05
    2d70:	f6 81       	ldd	r31, Z+6	; 0x06
    2d72:	e0 2d       	mov	r30, r0
    2d74:	86 81       	ldd	r24, Z+6	; 0x06
    2d76:	97 81       	ldd	r25, Z+7	; 0x07
    2d78:	9b 83       	std	Y+3, r25	; 0x03
    2d7a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d80:	0c 96       	adiw	r24, 0x0c	; 12
    2d82:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d86:	80 91 0e 03 	lds	r24, 0x030E
    2d8a:	88 23       	and	r24, r24
    2d8c:	61 f5       	brne	.+88     	; 0x2de6 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2d8e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d90:	9b 81       	ldd	r25, Y+3	; 0x03
    2d92:	02 96       	adiw	r24, 0x02	; 2
    2d94:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2d98:	ea 81       	ldd	r30, Y+2	; 0x02
    2d9a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d9c:	96 89       	ldd	r25, Z+22	; 0x16
    2d9e:	80 91 0c 03 	lds	r24, 0x030C
    2da2:	89 17       	cp	r24, r25
    2da4:	28 f4       	brcc	.+10     	; 0x2db0 <xTaskRemoveFromEventList+0x58>
    2da6:	ea 81       	ldd	r30, Y+2	; 0x02
    2da8:	fb 81       	ldd	r31, Y+3	; 0x03
    2daa:	86 89       	ldd	r24, Z+22	; 0x16
    2dac:	80 93 0c 03 	sts	0x030C, r24
    2db0:	ea 81       	ldd	r30, Y+2	; 0x02
    2db2:	fb 81       	ldd	r31, Y+3	; 0x03
    2db4:	86 89       	ldd	r24, Z+22	; 0x16
    2db6:	28 2f       	mov	r18, r24
    2db8:	30 e0       	ldi	r19, 0x00	; 0
    2dba:	c9 01       	movw	r24, r18
    2dbc:	88 0f       	add	r24, r24
    2dbe:	99 1f       	adc	r25, r25
    2dc0:	88 0f       	add	r24, r24
    2dc2:	99 1f       	adc	r25, r25
    2dc4:	88 0f       	add	r24, r24
    2dc6:	99 1f       	adc	r25, r25
    2dc8:	82 0f       	add	r24, r18
    2dca:	93 1f       	adc	r25, r19
    2dcc:	ac 01       	movw	r20, r24
    2dce:	4d 5e       	subi	r20, 0xED	; 237
    2dd0:	5c 4f       	sbci	r21, 0xFC	; 252
    2dd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2dd6:	9c 01       	movw	r18, r24
    2dd8:	2e 5f       	subi	r18, 0xFE	; 254
    2dda:	3f 4f       	sbci	r19, 0xFF	; 255
    2ddc:	ca 01       	movw	r24, r20
    2dde:	b9 01       	movw	r22, r18
    2de0:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
    2de4:	0a c0       	rjmp	.+20     	; 0x2dfa <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2de6:	8a 81       	ldd	r24, Y+2	; 0x02
    2de8:	9b 81       	ldd	r25, Y+3	; 0x03
    2dea:	9c 01       	movw	r18, r24
    2dec:	24 5f       	subi	r18, 0xF4	; 244
    2dee:	3f 4f       	sbci	r19, 0xFF	; 255
    2df0:	86 e5       	ldi	r24, 0x56	; 86
    2df2:	93 e0       	ldi	r25, 0x03	; 3
    2df4:	b9 01       	movw	r22, r18
    2df6:	0e 94 02 09 	call	0x1204	; 0x1204 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2dfa:	ea 81       	ldd	r30, Y+2	; 0x02
    2dfc:	fb 81       	ldd	r31, Y+3	; 0x03
    2dfe:	96 89       	ldd	r25, Z+22	; 0x16
    2e00:	e0 91 05 03 	lds	r30, 0x0305
    2e04:	f0 91 06 03 	lds	r31, 0x0306
    2e08:	86 89       	ldd	r24, Z+22	; 0x16
    2e0a:	98 17       	cp	r25, r24
    2e0c:	18 f0       	brcs	.+6      	; 0x2e14 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2e0e:	81 e0       	ldi	r24, 0x01	; 1
    2e10:	89 83       	std	Y+1, r24	; 0x01
    2e12:	01 c0       	rjmp	.+2      	; 0x2e16 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2e14:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2e16:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e18:	0f 90       	pop	r0
    2e1a:	0f 90       	pop	r0
    2e1c:	0f 90       	pop	r0
    2e1e:	0f 90       	pop	r0
    2e20:	0f 90       	pop	r0
    2e22:	cf 91       	pop	r28
    2e24:	df 91       	pop	r29
    2e26:	08 95       	ret

00002e28 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2e28:	df 93       	push	r29
    2e2a:	cf 93       	push	r28
    2e2c:	00 d0       	rcall	.+0      	; 0x2e2e <vTaskSetTimeOutState+0x6>
    2e2e:	cd b7       	in	r28, 0x3d	; 61
    2e30:	de b7       	in	r29, 0x3e	; 62
    2e32:	9a 83       	std	Y+2, r25	; 0x02
    2e34:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2e36:	80 91 11 03 	lds	r24, 0x0311
    2e3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e3e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2e40:	80 91 09 03 	lds	r24, 0x0309
    2e44:	90 91 0a 03 	lds	r25, 0x030A
    2e48:	e9 81       	ldd	r30, Y+1	; 0x01
    2e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e4c:	92 83       	std	Z+2, r25	; 0x02
    2e4e:	81 83       	std	Z+1, r24	; 0x01
}
    2e50:	0f 90       	pop	r0
    2e52:	0f 90       	pop	r0
    2e54:	cf 91       	pop	r28
    2e56:	df 91       	pop	r29
    2e58:	08 95       	ret

00002e5a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2e5a:	df 93       	push	r29
    2e5c:	cf 93       	push	r28
    2e5e:	00 d0       	rcall	.+0      	; 0x2e60 <xTaskCheckForTimeOut+0x6>
    2e60:	00 d0       	rcall	.+0      	; 0x2e62 <xTaskCheckForTimeOut+0x8>
    2e62:	0f 92       	push	r0
    2e64:	cd b7       	in	r28, 0x3d	; 61
    2e66:	de b7       	in	r29, 0x3e	; 62
    2e68:	9b 83       	std	Y+3, r25	; 0x03
    2e6a:	8a 83       	std	Y+2, r24	; 0x02
    2e6c:	7d 83       	std	Y+5, r23	; 0x05
    2e6e:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2e70:	0f b6       	in	r0, 0x3f	; 63
    2e72:	f8 94       	cli
    2e74:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2e76:	ea 81       	ldd	r30, Y+2	; 0x02
    2e78:	fb 81       	ldd	r31, Y+3	; 0x03
    2e7a:	90 81       	ld	r25, Z
    2e7c:	80 91 11 03 	lds	r24, 0x0311
    2e80:	98 17       	cp	r25, r24
    2e82:	71 f0       	breq	.+28     	; 0x2ea0 <xTaskCheckForTimeOut+0x46>
    2e84:	ea 81       	ldd	r30, Y+2	; 0x02
    2e86:	fb 81       	ldd	r31, Y+3	; 0x03
    2e88:	21 81       	ldd	r18, Z+1	; 0x01
    2e8a:	32 81       	ldd	r19, Z+2	; 0x02
    2e8c:	80 91 09 03 	lds	r24, 0x0309
    2e90:	90 91 0a 03 	lds	r25, 0x030A
    2e94:	82 17       	cp	r24, r18
    2e96:	93 07       	cpc	r25, r19
    2e98:	18 f0       	brcs	.+6      	; 0x2ea0 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2e9a:	81 e0       	ldi	r24, 0x01	; 1
    2e9c:	89 83       	std	Y+1, r24	; 0x01
    2e9e:	2f c0       	rjmp	.+94     	; 0x2efe <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2ea0:	20 91 09 03 	lds	r18, 0x0309
    2ea4:	30 91 0a 03 	lds	r19, 0x030A
    2ea8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eaa:	fb 81       	ldd	r31, Y+3	; 0x03
    2eac:	81 81       	ldd	r24, Z+1	; 0x01
    2eae:	92 81       	ldd	r25, Z+2	; 0x02
    2eb0:	28 1b       	sub	r18, r24
    2eb2:	39 0b       	sbc	r19, r25
    2eb4:	ec 81       	ldd	r30, Y+4	; 0x04
    2eb6:	fd 81       	ldd	r31, Y+5	; 0x05
    2eb8:	80 81       	ld	r24, Z
    2eba:	91 81       	ldd	r25, Z+1	; 0x01
    2ebc:	28 17       	cp	r18, r24
    2ebe:	39 07       	cpc	r19, r25
    2ec0:	e0 f4       	brcc	.+56     	; 0x2efa <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2ec2:	ec 81       	ldd	r30, Y+4	; 0x04
    2ec4:	fd 81       	ldd	r31, Y+5	; 0x05
    2ec6:	40 81       	ld	r20, Z
    2ec8:	51 81       	ldd	r21, Z+1	; 0x01
    2eca:	ea 81       	ldd	r30, Y+2	; 0x02
    2ecc:	fb 81       	ldd	r31, Y+3	; 0x03
    2ece:	21 81       	ldd	r18, Z+1	; 0x01
    2ed0:	32 81       	ldd	r19, Z+2	; 0x02
    2ed2:	80 91 09 03 	lds	r24, 0x0309
    2ed6:	90 91 0a 03 	lds	r25, 0x030A
    2eda:	b9 01       	movw	r22, r18
    2edc:	68 1b       	sub	r22, r24
    2ede:	79 0b       	sbc	r23, r25
    2ee0:	cb 01       	movw	r24, r22
    2ee2:	84 0f       	add	r24, r20
    2ee4:	95 1f       	adc	r25, r21
    2ee6:	ec 81       	ldd	r30, Y+4	; 0x04
    2ee8:	fd 81       	ldd	r31, Y+5	; 0x05
    2eea:	91 83       	std	Z+1, r25	; 0x01
    2eec:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2eee:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ef2:	0e 94 14 17 	call	0x2e28	; 0x2e28 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2ef6:	19 82       	std	Y+1, r1	; 0x01
    2ef8:	02 c0       	rjmp	.+4      	; 0x2efe <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2efe:	0f 90       	pop	r0
    2f00:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2f02:	89 81       	ldd	r24, Y+1	; 0x01
}
    2f04:	0f 90       	pop	r0
    2f06:	0f 90       	pop	r0
    2f08:	0f 90       	pop	r0
    2f0a:	0f 90       	pop	r0
    2f0c:	0f 90       	pop	r0
    2f0e:	cf 91       	pop	r28
    2f10:	df 91       	pop	r29
    2f12:	08 95       	ret

00002f14 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2f14:	df 93       	push	r29
    2f16:	cf 93       	push	r28
    2f18:	cd b7       	in	r28, 0x3d	; 61
    2f1a:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2f1c:	81 e0       	ldi	r24, 0x01	; 1
    2f1e:	80 93 10 03 	sts	0x0310, r24
}
    2f22:	cf 91       	pop	r28
    2f24:	df 91       	pop	r29
    2f26:	08 95       	ret

00002f28 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2f28:	df 93       	push	r29
    2f2a:	cf 93       	push	r28
    2f2c:	00 d0       	rcall	.+0      	; 0x2f2e <prvIdleTask+0x6>
    2f2e:	cd b7       	in	r28, 0x3d	; 61
    2f30:	de b7       	in	r29, 0x3e	; 62
    2f32:	9a 83       	std	Y+2, r25	; 0x02
    2f34:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2f36:	0e 94 32 18 	call	0x3064	; 0x3064 <prvCheckTasksWaitingTermination>
    2f3a:	fd cf       	rjmp	.-6      	; 0x2f36 <prvIdleTask+0xe>

00002f3c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2f3c:	0f 93       	push	r16
    2f3e:	1f 93       	push	r17
    2f40:	df 93       	push	r29
    2f42:	cf 93       	push	r28
    2f44:	cd b7       	in	r28, 0x3d	; 61
    2f46:	de b7       	in	r29, 0x3e	; 62
    2f48:	29 97       	sbiw	r28, 0x09	; 9
    2f4a:	0f b6       	in	r0, 0x3f	; 63
    2f4c:	f8 94       	cli
    2f4e:	de bf       	out	0x3e, r29	; 62
    2f50:	0f be       	out	0x3f, r0	; 63
    2f52:	cd bf       	out	0x3d, r28	; 61
    2f54:	9a 83       	std	Y+2, r25	; 0x02
    2f56:	89 83       	std	Y+1, r24	; 0x01
    2f58:	7c 83       	std	Y+4, r23	; 0x04
    2f5a:	6b 83       	std	Y+3, r22	; 0x03
    2f5c:	4d 83       	std	Y+5, r20	; 0x05
    2f5e:	3f 83       	std	Y+7, r19	; 0x07
    2f60:	2e 83       	std	Y+6, r18	; 0x06
    2f62:	19 87       	std	Y+9, r17	; 0x09
    2f64:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2f66:	89 81       	ldd	r24, Y+1	; 0x01
    2f68:	9a 81       	ldd	r25, Y+2	; 0x02
    2f6a:	49 96       	adiw	r24, 0x19	; 25
    2f6c:	2b 81       	ldd	r18, Y+3	; 0x03
    2f6e:	3c 81       	ldd	r19, Y+4	; 0x04
    2f70:	b9 01       	movw	r22, r18
    2f72:	48 e0       	ldi	r20, 0x08	; 8
    2f74:	50 e0       	ldi	r21, 0x00	; 0
    2f76:	0e 94 2f 19 	call	0x325e	; 0x325e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f7e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2f80:	8d 81       	ldd	r24, Y+5	; 0x05
    2f82:	85 30       	cpi	r24, 0x05	; 5
    2f84:	10 f0       	brcs	.+4      	; 0x2f8a <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2f86:	84 e0       	ldi	r24, 0x04	; 4
    2f88:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f8e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f90:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2f92:	89 81       	ldd	r24, Y+1	; 0x01
    2f94:	9a 81       	ldd	r25, Y+2	; 0x02
    2f96:	02 96       	adiw	r24, 0x02	; 2
    2f98:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2f9c:	89 81       	ldd	r24, Y+1	; 0x01
    2f9e:	9a 81       	ldd	r25, Y+2	; 0x02
    2fa0:	0c 96       	adiw	r24, 0x0c	; 12
    2fa2:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2fa6:	e9 81       	ldd	r30, Y+1	; 0x01
    2fa8:	fa 81       	ldd	r31, Y+2	; 0x02
    2faa:	89 81       	ldd	r24, Y+1	; 0x01
    2fac:	9a 81       	ldd	r25, Y+2	; 0x02
    2fae:	91 87       	std	Z+9, r25	; 0x09
    2fb0:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2fb2:	8d 81       	ldd	r24, Y+5	; 0x05
    2fb4:	28 2f       	mov	r18, r24
    2fb6:	30 e0       	ldi	r19, 0x00	; 0
    2fb8:	85 e0       	ldi	r24, 0x05	; 5
    2fba:	90 e0       	ldi	r25, 0x00	; 0
    2fbc:	82 1b       	sub	r24, r18
    2fbe:	93 0b       	sbc	r25, r19
    2fc0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc4:	95 87       	std	Z+13, r25	; 0x0d
    2fc6:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2fc8:	e9 81       	ldd	r30, Y+1	; 0x01
    2fca:	fa 81       	ldd	r31, Y+2	; 0x02
    2fcc:	89 81       	ldd	r24, Y+1	; 0x01
    2fce:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd0:	93 8b       	std	Z+19, r25	; 0x13
    2fd2:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2fd4:	29 96       	adiw	r28, 0x09	; 9
    2fd6:	0f b6       	in	r0, 0x3f	; 63
    2fd8:	f8 94       	cli
    2fda:	de bf       	out	0x3e, r29	; 62
    2fdc:	0f be       	out	0x3f, r0	; 63
    2fde:	cd bf       	out	0x3d, r28	; 61
    2fe0:	cf 91       	pop	r28
    2fe2:	df 91       	pop	r29
    2fe4:	1f 91       	pop	r17
    2fe6:	0f 91       	pop	r16
    2fe8:	08 95       	ret

00002fea <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2fea:	df 93       	push	r29
    2fec:	cf 93       	push	r28
    2fee:	0f 92       	push	r0
    2ff0:	cd b7       	in	r28, 0x3d	; 61
    2ff2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2ff4:	19 82       	std	Y+1, r1	; 0x01
    2ff6:	13 c0       	rjmp	.+38     	; 0x301e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2ff8:	89 81       	ldd	r24, Y+1	; 0x01
    2ffa:	28 2f       	mov	r18, r24
    2ffc:	30 e0       	ldi	r19, 0x00	; 0
    2ffe:	c9 01       	movw	r24, r18
    3000:	88 0f       	add	r24, r24
    3002:	99 1f       	adc	r25, r25
    3004:	88 0f       	add	r24, r24
    3006:	99 1f       	adc	r25, r25
    3008:	88 0f       	add	r24, r24
    300a:	99 1f       	adc	r25, r25
    300c:	82 0f       	add	r24, r18
    300e:	93 1f       	adc	r25, r19
    3010:	8d 5e       	subi	r24, 0xED	; 237
    3012:	9c 4f       	sbci	r25, 0xFC	; 252
    3014:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3018:	89 81       	ldd	r24, Y+1	; 0x01
    301a:	8f 5f       	subi	r24, 0xFF	; 255
    301c:	89 83       	std	Y+1, r24	; 0x01
    301e:	89 81       	ldd	r24, Y+1	; 0x01
    3020:	85 30       	cpi	r24, 0x05	; 5
    3022:	50 f3       	brcs	.-44     	; 0x2ff8 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    3024:	80 e4       	ldi	r24, 0x40	; 64
    3026:	93 e0       	ldi	r25, 0x03	; 3
    3028:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    302c:	89 e4       	ldi	r24, 0x49	; 73
    302e:	93 e0       	ldi	r25, 0x03	; 3
    3030:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    3034:	86 e5       	ldi	r24, 0x56	; 86
    3036:	93 e0       	ldi	r25, 0x03	; 3
    3038:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    303c:	8f e5       	ldi	r24, 0x5F	; 95
    303e:	93 e0       	ldi	r25, 0x03	; 3
    3040:	0e 94 c8 08 	call	0x1190	; 0x1190 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3044:	80 e4       	ldi	r24, 0x40	; 64
    3046:	93 e0       	ldi	r25, 0x03	; 3
    3048:	90 93 53 03 	sts	0x0353, r25
    304c:	80 93 52 03 	sts	0x0352, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3050:	89 e4       	ldi	r24, 0x49	; 73
    3052:	93 e0       	ldi	r25, 0x03	; 3
    3054:	90 93 55 03 	sts	0x0355, r25
    3058:	80 93 54 03 	sts	0x0354, r24
}
    305c:	0f 90       	pop	r0
    305e:	cf 91       	pop	r28
    3060:	df 91       	pop	r29
    3062:	08 95       	ret

00003064 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3064:	df 93       	push	r29
    3066:	cf 93       	push	r28
    3068:	00 d0       	rcall	.+0      	; 0x306a <prvCheckTasksWaitingTermination+0x6>
    306a:	0f 92       	push	r0
    306c:	cd b7       	in	r28, 0x3d	; 61
    306e:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    3070:	80 91 07 03 	lds	r24, 0x0307
    3074:	88 23       	and	r24, r24
    3076:	71 f1       	breq	.+92     	; 0x30d4 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    3078:	0e 94 70 14 	call	0x28e0	; 0x28e0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    307c:	80 91 5f 03 	lds	r24, 0x035F
    3080:	1b 82       	std	Y+3, r1	; 0x03
    3082:	88 23       	and	r24, r24
    3084:	11 f4       	brne	.+4      	; 0x308a <prvCheckTasksWaitingTermination+0x26>
    3086:	81 e0       	ldi	r24, 0x01	; 1
    3088:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    308a:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    308e:	8b 81       	ldd	r24, Y+3	; 0x03
    3090:	88 23       	and	r24, r24
    3092:	01 f5       	brne	.+64     	; 0x30d4 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    3094:	0f b6       	in	r0, 0x3f	; 63
    3096:	f8 94       	cli
    3098:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    309a:	e0 91 64 03 	lds	r30, 0x0364
    309e:	f0 91 65 03 	lds	r31, 0x0365
    30a2:	86 81       	ldd	r24, Z+6	; 0x06
    30a4:	97 81       	ldd	r25, Z+7	; 0x07
    30a6:	9a 83       	std	Y+2, r25	; 0x02
    30a8:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    30aa:	89 81       	ldd	r24, Y+1	; 0x01
    30ac:	9a 81       	ldd	r25, Y+2	; 0x02
    30ae:	02 96       	adiw	r24, 0x02	; 2
    30b0:	0e 94 ba 09 	call	0x1374	; 0x1374 <vListRemove>
					--uxCurrentNumberOfTasks;
    30b4:	80 91 08 03 	lds	r24, 0x0308
    30b8:	81 50       	subi	r24, 0x01	; 1
    30ba:	80 93 08 03 	sts	0x0308, r24
					--uxTasksDeleted;
    30be:	80 91 07 03 	lds	r24, 0x0307
    30c2:	81 50       	subi	r24, 0x01	; 1
    30c4:	80 93 07 03 	sts	0x0307, r24
				}
				taskEXIT_CRITICAL();
    30c8:	0f 90       	pop	r0
    30ca:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    30cc:	89 81       	ldd	r24, Y+1	; 0x01
    30ce:	9a 81       	ldd	r25, Y+2	; 0x02
    30d0:	0e 94 09 19 	call	0x3212	; 0x3212 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	0f 90       	pop	r0
    30da:	cf 91       	pop	r28
    30dc:	df 91       	pop	r29
    30de:	08 95       	ret

000030e0 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    30e0:	df 93       	push	r29
    30e2:	cf 93       	push	r28
    30e4:	00 d0       	rcall	.+0      	; 0x30e6 <prvAddCurrentTaskToDelayedList+0x6>
    30e6:	cd b7       	in	r28, 0x3d	; 61
    30e8:	de b7       	in	r29, 0x3e	; 62
    30ea:	9a 83       	std	Y+2, r25	; 0x02
    30ec:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    30ee:	e0 91 05 03 	lds	r30, 0x0305
    30f2:	f0 91 06 03 	lds	r31, 0x0306
    30f6:	89 81       	ldd	r24, Y+1	; 0x01
    30f8:	9a 81       	ldd	r25, Y+2	; 0x02
    30fa:	93 83       	std	Z+3, r25	; 0x03
    30fc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    30fe:	20 91 09 03 	lds	r18, 0x0309
    3102:	30 91 0a 03 	lds	r19, 0x030A
    3106:	89 81       	ldd	r24, Y+1	; 0x01
    3108:	9a 81       	ldd	r25, Y+2	; 0x02
    310a:	82 17       	cp	r24, r18
    310c:	93 07       	cpc	r25, r19
    310e:	70 f4       	brcc	.+28     	; 0x312c <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3110:	80 91 54 03 	lds	r24, 0x0354
    3114:	90 91 55 03 	lds	r25, 0x0355
    3118:	20 91 05 03 	lds	r18, 0x0305
    311c:	30 91 06 03 	lds	r19, 0x0306
    3120:	2e 5f       	subi	r18, 0xFE	; 254
    3122:	3f 4f       	sbci	r19, 0xFF	; 255
    3124:	b9 01       	movw	r22, r18
    3126:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>
    312a:	1e c0       	rjmp	.+60     	; 0x3168 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    312c:	40 91 52 03 	lds	r20, 0x0352
    3130:	50 91 53 03 	lds	r21, 0x0353
    3134:	80 91 05 03 	lds	r24, 0x0305
    3138:	90 91 06 03 	lds	r25, 0x0306
    313c:	9c 01       	movw	r18, r24
    313e:	2e 5f       	subi	r18, 0xFE	; 254
    3140:	3f 4f       	sbci	r19, 0xFF	; 255
    3142:	ca 01       	movw	r24, r20
    3144:	b9 01       	movw	r22, r18
    3146:	0e 94 4e 09 	call	0x129c	; 0x129c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    314a:	20 91 65 00 	lds	r18, 0x0065
    314e:	30 91 66 00 	lds	r19, 0x0066
    3152:	89 81       	ldd	r24, Y+1	; 0x01
    3154:	9a 81       	ldd	r25, Y+2	; 0x02
    3156:	82 17       	cp	r24, r18
    3158:	93 07       	cpc	r25, r19
    315a:	30 f4       	brcc	.+12     	; 0x3168 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    315c:	89 81       	ldd	r24, Y+1	; 0x01
    315e:	9a 81       	ldd	r25, Y+2	; 0x02
    3160:	90 93 66 00 	sts	0x0066, r25
    3164:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    3168:	0f 90       	pop	r0
    316a:	0f 90       	pop	r0
    316c:	cf 91       	pop	r28
    316e:	df 91       	pop	r29
    3170:	08 95       	ret

00003172 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    3172:	df 93       	push	r29
    3174:	cf 93       	push	r28
    3176:	cd b7       	in	r28, 0x3d	; 61
    3178:	de b7       	in	r29, 0x3e	; 62
    317a:	28 97       	sbiw	r28, 0x08	; 8
    317c:	0f b6       	in	r0, 0x3f	; 63
    317e:	f8 94       	cli
    3180:	de bf       	out	0x3e, r29	; 62
    3182:	0f be       	out	0x3f, r0	; 63
    3184:	cd bf       	out	0x3d, r28	; 61
    3186:	9c 83       	std	Y+4, r25	; 0x04
    3188:	8b 83       	std	Y+3, r24	; 0x03
    318a:	7e 83       	std	Y+6, r23	; 0x06
    318c:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    318e:	81 e2       	ldi	r24, 0x21	; 33
    3190:	90 e0       	ldi	r25, 0x00	; 0
    3192:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    3196:	9a 83       	std	Y+2, r25	; 0x02
    3198:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    319a:	89 81       	ldd	r24, Y+1	; 0x01
    319c:	9a 81       	ldd	r25, Y+2	; 0x02
    319e:	00 97       	sbiw	r24, 0x00	; 0
    31a0:	69 f1       	breq	.+90     	; 0x31fc <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    31a2:	8d 81       	ldd	r24, Y+5	; 0x05
    31a4:	9e 81       	ldd	r25, Y+6	; 0x06
    31a6:	00 97       	sbiw	r24, 0x00	; 0
    31a8:	39 f4       	brne	.+14     	; 0x31b8 <prvAllocateTCBAndStack+0x46>
    31aa:	8b 81       	ldd	r24, Y+3	; 0x03
    31ac:	9c 81       	ldd	r25, Y+4	; 0x04
    31ae:	0e 94 5c 08 	call	0x10b8	; 0x10b8 <pvPortMalloc>
    31b2:	98 87       	std	Y+8, r25	; 0x08
    31b4:	8f 83       	std	Y+7, r24	; 0x07
    31b6:	04 c0       	rjmp	.+8      	; 0x31c0 <prvAllocateTCBAndStack+0x4e>
    31b8:	8d 81       	ldd	r24, Y+5	; 0x05
    31ba:	9e 81       	ldd	r25, Y+6	; 0x06
    31bc:	98 87       	std	Y+8, r25	; 0x08
    31be:	8f 83       	std	Y+7, r24	; 0x07
    31c0:	e9 81       	ldd	r30, Y+1	; 0x01
    31c2:	fa 81       	ldd	r31, Y+2	; 0x02
    31c4:	8f 81       	ldd	r24, Y+7	; 0x07
    31c6:	98 85       	ldd	r25, Y+8	; 0x08
    31c8:	90 8f       	std	Z+24, r25	; 0x18
    31ca:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    31cc:	e9 81       	ldd	r30, Y+1	; 0x01
    31ce:	fa 81       	ldd	r31, Y+2	; 0x02
    31d0:	87 89       	ldd	r24, Z+23	; 0x17
    31d2:	90 8d       	ldd	r25, Z+24	; 0x18
    31d4:	00 97       	sbiw	r24, 0x00	; 0
    31d6:	39 f4       	brne	.+14     	; 0x31e6 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    31d8:	89 81       	ldd	r24, Y+1	; 0x01
    31da:	9a 81       	ldd	r25, Y+2	; 0x02
    31dc:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
			pxNewTCB = NULL;
    31e0:	1a 82       	std	Y+2, r1	; 0x02
    31e2:	19 82       	std	Y+1, r1	; 0x01
    31e4:	0b c0       	rjmp	.+22     	; 0x31fc <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    31e6:	e9 81       	ldd	r30, Y+1	; 0x01
    31e8:	fa 81       	ldd	r31, Y+2	; 0x02
    31ea:	87 89       	ldd	r24, Z+23	; 0x17
    31ec:	90 8d       	ldd	r25, Z+24	; 0x18
    31ee:	2b 81       	ldd	r18, Y+3	; 0x03
    31f0:	3c 81       	ldd	r19, Y+4	; 0x04
    31f2:	65 ea       	ldi	r22, 0xA5	; 165
    31f4:	70 e0       	ldi	r23, 0x00	; 0
    31f6:	a9 01       	movw	r20, r18
    31f8:	0e 94 28 19 	call	0x3250	; 0x3250 <memset>
		}
	}

	return pxNewTCB;
    31fc:	89 81       	ldd	r24, Y+1	; 0x01
    31fe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3200:	28 96       	adiw	r28, 0x08	; 8
    3202:	0f b6       	in	r0, 0x3f	; 63
    3204:	f8 94       	cli
    3206:	de bf       	out	0x3e, r29	; 62
    3208:	0f be       	out	0x3f, r0	; 63
    320a:	cd bf       	out	0x3d, r28	; 61
    320c:	cf 91       	pop	r28
    320e:	df 91       	pop	r29
    3210:	08 95       	ret

00003212 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    3212:	df 93       	push	r29
    3214:	cf 93       	push	r28
    3216:	00 d0       	rcall	.+0      	; 0x3218 <prvDeleteTCB+0x6>
    3218:	cd b7       	in	r28, 0x3d	; 61
    321a:	de b7       	in	r29, 0x3e	; 62
    321c:	9a 83       	std	Y+2, r25	; 0x02
    321e:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    3220:	e9 81       	ldd	r30, Y+1	; 0x01
    3222:	fa 81       	ldd	r31, Y+2	; 0x02
    3224:	87 89       	ldd	r24, Z+23	; 0x17
    3226:	90 8d       	ldd	r25, Z+24	; 0x18
    3228:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
		vPortFree( pxTCB );
    322c:	89 81       	ldd	r24, Y+1	; 0x01
    322e:	9a 81       	ldd	r25, Y+2	; 0x02
    3230:	0e 94 a2 08 	call	0x1144	; 0x1144 <vPortFree>
	}
    3234:	0f 90       	pop	r0
    3236:	0f 90       	pop	r0
    3238:	cf 91       	pop	r28
    323a:	df 91       	pop	r29
    323c:	08 95       	ret

0000323e <memcpy>:
    323e:	fb 01       	movw	r30, r22
    3240:	dc 01       	movw	r26, r24
    3242:	02 c0       	rjmp	.+4      	; 0x3248 <memcpy+0xa>
    3244:	01 90       	ld	r0, Z+
    3246:	0d 92       	st	X+, r0
    3248:	41 50       	subi	r20, 0x01	; 1
    324a:	50 40       	sbci	r21, 0x00	; 0
    324c:	d8 f7       	brcc	.-10     	; 0x3244 <memcpy+0x6>
    324e:	08 95       	ret

00003250 <memset>:
    3250:	dc 01       	movw	r26, r24
    3252:	01 c0       	rjmp	.+2      	; 0x3256 <memset+0x6>
    3254:	6d 93       	st	X+, r22
    3256:	41 50       	subi	r20, 0x01	; 1
    3258:	50 40       	sbci	r21, 0x00	; 0
    325a:	e0 f7       	brcc	.-8      	; 0x3254 <memset+0x4>
    325c:	08 95       	ret

0000325e <strncpy>:
    325e:	fb 01       	movw	r30, r22
    3260:	dc 01       	movw	r26, r24
    3262:	41 50       	subi	r20, 0x01	; 1
    3264:	50 40       	sbci	r21, 0x00	; 0
    3266:	48 f0       	brcs	.+18     	; 0x327a <strncpy+0x1c>
    3268:	01 90       	ld	r0, Z+
    326a:	0d 92       	st	X+, r0
    326c:	00 20       	and	r0, r0
    326e:	c9 f7       	brne	.-14     	; 0x3262 <strncpy+0x4>
    3270:	01 c0       	rjmp	.+2      	; 0x3274 <strncpy+0x16>
    3272:	1d 92       	st	X+, r1
    3274:	41 50       	subi	r20, 0x01	; 1
    3276:	50 40       	sbci	r21, 0x00	; 0
    3278:	e0 f7       	brcc	.-8      	; 0x3272 <strncpy+0x14>
    327a:	08 95       	ret

0000327c <_exit>:
    327c:	f8 94       	cli

0000327e <__stop_program>:
    327e:	ff cf       	rjmp	.-2      	; 0x327e <__stop_program>
